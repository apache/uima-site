<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Apache UIMA Ruta&#8482; Guide and Reference</title><link rel="stylesheet" type="text/css" href="css/stylesheet-html.css"><meta name="generator" content="DocBook XSL-NS Stylesheets V1.76.1"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div lang="en" class="book" title="Apache UIMA Ruta&#8482; Guide and Reference" id="d5e1"><div xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div><h1 class="title">Apache UIMA Ruta&#8482; Guide and Reference</h1></div><div><div class="authorgroup">
      <h3 class="corpauthor">Written and maintained by the Apache UIMA Development Community</h3>
    </div></div><div><p class="releaseinfo">Version 2.4.0</p></div><div><p class="copyright">Copyright &copy; 2011, 2016 The Apache Software Foundation</p></div><div><div class="legalnotice" title="Legal Notice"><a name="d5e8"></a>
      <p> </p>
      <p title="License and Disclaimer">
        <b>License and Disclaimer.&nbsp;</b>

        The ASF licenses this documentation
           to you under the Apache License, Version 2.0 (the
           "License"); you may not use this documentation except in compliance
           with the License.  You may obtain a copy of the License at
         
         </p><div class="blockquote"><blockquote class="blockquote">
           <a class="ulink" href="http://www.apache.org/licenses/LICENSE-2.0" target="_top">http://www.apache.org/licenses/LICENSE-2.0</a>
         </blockquote></div><p title="License and Disclaimer">
         
           Unless required by applicable law or agreed to in writing,
           this documentation and its contents are distributed under the License 
           on an 
           "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
           KIND, either express or implied.  See the License for the
           specific language governing permissions and limitations
           under the License.
         
      </p>
      <p> </p>
      <p> </p>
      <p title="Trademarks">
        <b>Trademarks.&nbsp;</b>
        All terms mentioned in the text that are known to be trademarks or 
        service marks have been appropriately capitalized.  Use of such terms
        in this book should not be regarded as affecting the validity of the
        the trademark or service mark.
        
      </p>
    </div></div><div><p class="pubdate">January, 2016</p></div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="chapter"><a href="#ugr.tools.ruta.overview">1. Apache UIMA Ruta Overview</a></span></dt><dd><dl><dt><span class="section"><a href="#ugr.tools.ruta.overview.intro">1.1. What is Apache UIMA Ruta?</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.overview.gettingstarted">1.2. Getting started</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.overview.coreconcepts">1.3. Core Concepts</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.overview.examples">1.4. Learning by Example</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.ae">1.5. UIMA Analysis Engines</a></span></dt><dd><dl><dt><span class="section"><a href="#ugr.tools.ruta.ae.basic">1.5.1. Ruta Engine</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.ae.annotationwriter">1.5.2. Annotation Writer</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.ae.plaintext">1.5.3. Plain Text Annotator</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.ae.modifier">1.5.4. Modifier</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.ae.html">1.5.5. HTML Annotator</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.ae.htmlconverter">1.5.6. HTML Converter</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.ae.stylemap">1.5.7. Style Map Creator</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.ae.cutter">1.5.8. Cutter</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.ae.view">1.5.9. View Writer</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.ae.xmi">1.5.10. XMI Writer</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#ugr.tools.ruta.language.language">2. Apache UIMA Ruta Language</a></span></dt><dd><dl><dt><span class="section"><a href="#ugr.tools.ruta.language.syntax">2.1. Syntax</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.language.anchoring">2.2. Rule elements and their matching order</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.language.seeding">2.3. Basic annotations and tokens</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.language.quantifier">2.4. Quantifiers</a></span></dt><dd><dl><dt><span class="section"><a href="#ugr.tools.ruta.language.quantifier.sg">2.4.1. * Star Greedy</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.language.quantifier.sr">2.4.2. *? Star Reluctant</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.language.quantifier.pg">2.4.3. + Plus Greedy</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.language.quantifier.pr">2.4.4. +? Plus Reluctant</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.language.quantifier.qg">2.4.5. ? Question Greedy</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.language.quantifier.qr">2.4.6. ?? Question Reluctant</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.language.quantifier.mmg">2.4.7. [x,y] Min Max Greedy</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.language.quantifier.mmr">2.4.8. [x,y]? Min Max Reluctant</a></span></dt></dl></dd><dt><span class="section"><a href="#ugr.tools.ruta.language.declarations">2.5. Declarations</a></span></dt><dd><dl><dt><span class="section"><a href="#ugr.tools.ruta.language.declarations.type">2.5.1. Types</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.language.declarations.variable">2.5.2. Variables</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.language.declarations.ressource">2.5.3. Resources</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.language.declarations.scripts">2.5.4. Scripts</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.language.declarations.components">2.5.5. Components</a></span></dt></dl></dd><dt><span class="section"><a href="#ugr.tools.ruta.language.expressions">2.6. Expressions</a></span></dt><dd><dl><dt><span class="section"><a href="#ugr.tools.ruta.language.expressions.type">2.6.1. Type Expressions</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.language.expressions.number">2.6.2. Number Expressions</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.language.expressions.string">2.6.3. String Expressions</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.language.expressions.boolean">2.6.4. Boolean Expressions</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.language.expressions.lists">2.6.5. List Expressions</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.language.expressions.features">2.6.6. Feature Expressions</a></span></dt></dl></dd><dt><span class="section"><a href="#ugr.tools.ruta.language.conditions">2.7. Conditions</a></span></dt><dd><dl><dt><span class="section"><a href="#ugr.tools.ruta.language.conditions.after">2.7.1. AFTER</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.language.conditions.and">2.7.2. AND</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.language.conditions.before">2.7.3. BEFORE</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.language.conditions.contains">2.7.4. CONTAINS</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.language.conditions.contextcount">2.7.5. CONTEXTCOUNT</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.language.conditions.count">2.7.6. COUNT</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.language.conditions.currentcount">2.7.7. CURRENTCOUNT</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.language.conditions.endswith">2.7.8. ENDSWITH</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.language.conditions.feature">2.7.9. FEATURE</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.language.conditions.if">2.7.10. IF</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.language.conditions.inlist">2.7.11. INLIST</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.language.conditions.is">2.7.12. IS</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.language.conditions.last">2.7.13. LAST</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.language.conditions.mofn">2.7.14. MOFN</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.language.conditions.near">2.7.15. NEAR</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.language.conditions.not">2.7.16. NOT</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.language.conditions.or">2.7.17. OR</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.language.conditions.parse">2.7.18. PARSE</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.language.conditions.partof">2.7.19. PARTOF</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.language.conditions.partofneq">2.7.20. PARTOFNEQ</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.language.conditions.position">2.7.21. POSITION</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.language.conditions.regexp">2.7.22. REGEXP</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.language.conditions.score">2.7.23. SCORE</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.language.conditions.size">2.7.24. SIZE</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.language.conditions.startswith">2.7.25. STARTSWITH</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.language.conditions.totalcount">2.7.26. TOTALCOUNT</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.language.conditions.vote">2.7.27. VOTE</a></span></dt></dl></dd><dt><span class="section"><a href="#ugr.tools.ruta.language.actions">2.8. Actions</a></span></dt><dd><dl><dt><span class="section"><a href="#ugr.tools.ruta.language.actions.add">2.8.1. ADD</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.language.actions.addfiltertype">2.8.2. ADDFILTERTYPE</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.language.actions.addretaintype">2.8.3. ADDRETAINTYPE</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.language.actions.assign">2.8.4. ASSIGN</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.language.actions.call">2.8.5. CALL</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.language.actions.clear">2.8.6. CLEAR</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.language.actions.color">2.8.7. COLOR</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.language.actions.configure">2.8.8. CONFIGURE</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.language.actions.create">2.8.9. CREATE</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.language.actions.del">2.8.10. DEL</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.language.actions.dynamicanchoring">2.8.11. DYNAMICANCHORING</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.language.actions.exec">2.8.12. EXEC</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.language.actions.fill">2.8.13. FILL</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.language.actions.filtertype">2.8.14. FILTERTYPE</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.language.actions.gather">2.8.15. GATHER</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.language.actions.get">2.8.16. GET</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.language.actions.getfeature">2.8.17. GETFEATURE</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.language.actions.getlist">2.8.18. GETLIST</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.language.actions.greedyanchoring">2.8.19. GREEDYANCHORING</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.language.actions.log">2.8.20. LOG</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.language.actions.mark">2.8.21. MARK</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.language.actions.markfast">2.8.22. MARKFAST</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.language.actions.markfirst">2.8.23. MARKFIRST</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.language.actions.marklast">2.8.24. MARKLAST</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.language.actions.markonce">2.8.25. MARKONCE</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.language.actions.markscore">2.8.26. MARKSCORE</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.language.actions.marktable">2.8.27. MARKTABLE</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.language.actions.matchedtext">2.8.28. MATCHEDTEXT</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.language.actions.merge">2.8.29. MERGE</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.language.actions.remove">2.8.30. REMOVE</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.language.actions.removeduplicate">2.8.31. REMOVEDUPLICATE</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.language.actions.removefiltertype">2.8.32. REMOVEFILTERTYPE</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.language.actions.removeretaintype">2.8.33. REMOVERETAINTYPE</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.language.actions.replace">2.8.34. REPLACE</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.language.actions.retaintype">2.8.35. RETAINTYPE</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.language.actions.setfeature">2.8.36. SETFEATURE</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.language.actions.shift">2.8.37. SHIFT</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.language.actions.split">2.8.38. SHIFT</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.language.actions.transfer">2.8.39. TRANSFER</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.language.actions.trie">2.8.40. TRIE</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.language.actions.trim">2.8.41. TRIM</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.language.actions.unmark">2.8.42. UNMARK</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.language.actions.unmarkall">2.8.43. UNMARKALL</a></span></dt></dl></dd><dt><span class="section"><a href="#ugr.tools.ruta.language.filtering">2.9. Robust extraction using filtering</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.language.blocks">2.10. Blocks</a></span></dt><dd><dl><dt><span class="section"><a href="#ugr.tools.ruta.language.blocks.condition">2.10.1. Conditioned statements</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.language.blocks.foreach">2.10.2. 
        <span class="quote">&#8220;<span class="quote">Foreach</span>&#8221;</span>
        -Loops
      </a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.language.blocks.procedure">2.10.3. Procedures</a></span></dt></dl></dd><dt><span class="section"><a href="#ugr.tools.ruta.language.inlined">2.11. Inlined rules</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.language.score">2.12. Heuristic extraction using scoring rules</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.language.modification">2.13. Modification</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.language.external_resources">2.14. External resources</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e2394">2.14.1. WORDLISTs</a></span></dt><dt><span class="section"><a href="#d5e2414">2.14.2. WORDTABLEs</a></span></dt></dl></dd><dt><span class="section"><a href="#ugr.tools.ruta.language.regexprule">2.15. Simple Rules based on Regular Expressions</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.language.extensions">2.16. Language Extensions</a></span></dt><dd><dl><dt><span class="section"><a href="#ugr.tools.ruta.language.extensions.core-ext">2.16.1. Provided Extensions</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.language.extensions.core-ext.onlyonce">2.16.2. ONLYONCE</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.language.extensions.core-ext.stringfunctions">2.16.3. Stringfunctions</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.language.extensions.new">2.16.4. Adding new Language Elements</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#ugr.tools.ruta.workbench">3. Apache UIMA Ruta Workbench</a></span></dt><dd><dl><dt><span class="section"><a href="#section.ugr.tools.ruta.workbench.install">3.1. Installation</a></span></dt><dt><span class="section"><a href="#section.ugr.tools.ruta.workbench.overview">3.2. UIMA Ruta Workbench Overview</a></span></dt><dt><span class="section"><a href="#section.ugr.tools.ruta.workbench.projects">3.3. UIMA Ruta Projects</a></span></dt><dd><dl><dt><span class="section"><a href="#section.ugr.tools.ruta.workbench.projects.create_projects">3.3.1. UIMA Ruta create project wizard</a></span></dt></dl></dd><dt><span class="section"><a href="#section.ugr.tools.ruta.workbench.ruta_perspective">3.4. UIMA Ruta Perspective</a></span></dt><dd><dl><dt><span class="section"><a href="#section.ugr.tools.ruta.workbench.ruta_perspective.annotation_browser">3.4.1. Annotation Browser</a></span></dt><dt><span class="section"><a href="#section.ugr.tools.ruta.workbench.ruta_perspective.selection">3.4.2. Selection</a></span></dt></dl></dd><dt><span class="section"><a href="#section.ugr.tools.ruta.workbench.explain_perspective">3.5. UIMA Ruta Explain Perspective</a></span></dt><dd><dl><dt><span class="section"><a href="#section.ugr.tools.ruta.workbench.explain_perspective.applied_rules">3.5.1. Applied Rules</a></span></dt><dt><span class="section"><a href="#section.ugr.tools.ruta.workbench.explain_perspective.matched_and_failed_rules">3.5.2. Matched Rules and Failed Rules</a></span></dt><dt><span class="section"><a href="#section.ugr.tools.ruta.workbench.explain_perspective.rule_elements">3.5.3. Rule Elements</a></span></dt><dt><span class="section"><a href="#section.ugr.tools.ruta.workbench.explain_perspective.covering_rules">3.5.4. Covering Rules</a></span></dt><dt><span class="section"><a href="#section.ugr.tools.ruta.workbench.explain_perspective.rule_list">3.5.5. Rule List</a></span></dt><dt><span class="section"><a href="#section.ugr.tools.ruta.workbench.explain_perspective.created_by">3.5.6. Created By</a></span></dt><dt><span class="section"><a href="#section.ugr.tools.ruta.workbench.explain_perspective.statistics">3.5.7. Statistics</a></span></dt></dl></dd><dt><span class="section"><a href="#section.tools.ruta.workbench.cde">3.6. UIMA Ruta CDE perspective</a></span></dt><dd><dl><dt><span class="section"><a href="#section.tools.ruta.workbench.cde.documents">3.6.1. CDE Documents view</a></span></dt><dt><span class="section"><a href="#section.tools.ruta.workbench.cde.constraints">3.6.2. CDE Constraints view</a></span></dt><dt><span class="section"><a href="#section.tools.ruta.workbench.cde.result">3.6.3. CDE Result view</a></span></dt></dl></dd><dt><span class="section"><a href="#section.ugr.tools.ruta.workbench.ruta_query">3.7. Ruta Query View</a></span></dt><dt><span class="section"><a href="#section.ugr.tools.ruta.workbench.testing">3.8. Testing</a></span></dt><dd><dl><dt><span class="section"><a href="#section.ugr.tools.ruta.workbench.testing.usage">3.8.1. Usage</a></span></dt><dt><span class="section"><a href="#section.ugr.tools.ruta.workbench.testing.evaluators">3.8.2. Evaluators</a></span></dt></dl></dd><dt><span class="section"><a href="#section.tools.ruta.workbench.textruler">3.9. TextRuler</a></span></dt><dd><dl><dt><span class="section"><a href="#section.tools.ruta.workbench.textruler.learner">3.9.1. Included rule learning algorithms</a></span></dt><dt><span class="section"><a href="#section.tools.ruta.workbench.textruler.ui">3.9.2. The TextRuler view</a></span></dt></dl></dd><dt><span class="section"><a href="#section.tools.ruta.workbench.check">3.10. Check Annotations view</a></span></dt><dt><span class="section"><a href="#section.ugr.tools.ruta.workbench.create_dictionaries">3.11. Creation of Tree Word Lists</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.workbench.apply">3.12. Apply a UIMA Ruta script to a folder</a></span></dt></dl></dd><dt><span class="chapter"><a href="#ugr.tools.ruta.howtos">4. Apache UIMA Ruta HowTos</a></span></dt><dd><dl><dt><span class="section"><a href="#ugr.tools.ruta.ae.basic.apply">4.1. Apply UIMA Ruta Analysis Engine in plain Java</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.integration">4.2. Integrating UIMA Ruta in an existing UIMA Annotator</a></span></dt><dd><dl><dt><span class="section"><a href="#ugr.tools.ruta.ae.integration.mvn">4.2.1. Adding Ruta to our Annotator</a></span></dt><dt><span class="section"><a href="#ugr.tools.ruta.ae.integration.loading">4.2.2. Developing Ruta rules and applying them from inside Java code
			</a></span></dt></dl></dd><dt><span class="section"><a href="#ugr.tools.ruta.maven">4.3. UIMA Ruta Maven Plugin</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e3309">4.3.1. generate goal</a></span></dt><dt><span class="section"><a href="#d5e3314">4.3.2. twl goal</a></span></dt><dt><span class="section"><a href="#d5e3318">4.3.3. mtwl goal</a></span></dt></dl></dd><dt><span class="section"><a href="#section.tools.ruta.workbench.textruler.example">4.4. Induce rules with the TextRuler framework</a></span></dt><dt><span class="section"><a href="#section.tools.ruta.howto.html">4.5. HTML annotations in plain text</a></span></dt><dt><span class="section"><a href="#section.tools.ruta.howto.sorter">4.6. Sorting files with UIMA Ruta</a></span></dt><dt><span class="section"><a href="#section.tools.ruta.howto.xml">4.7. Converting XML documents with UIMA Ruta</a></span></dt></dl></dd></dl></div>
  
  
    
  
  
  <div class="chapter" title="Chapter&nbsp;1.&nbsp;Apache UIMA Ruta Overview" id="ugr.tools.ruta.overview"><div class="titlepage"><div><div><h2 class="title">Chapter&nbsp;1.&nbsp;Apache UIMA Ruta Overview</h2></div></div></div>
  
  <p>
   
  </p>
  <div class="section" title="1.1.&nbsp;What is Apache UIMA Ruta?"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.tools.ruta.overview.intro">1.1.&nbsp;What is Apache UIMA Ruta?</h2></div></div></div>
    
    <p>
      Apache UIMA Ruta&#8482; is a rule-based script language supported by Eclipse-based tooling.
      The language is designed to enable rapid development of text processing applications within Apache UIMA&#8482;. 
      A special focus lies on the intuitive and flexible domain specific language for defining 
      patterns of annotations. Writing rules for information extraction or other text processing 
      applications is a tedious process. The Eclipse-based tooling for UIMA Ruta, called the Apache UIMA Ruta Workbench,
      was created to support the user and to facilitate every step when writing UIMA Ruta rules. Both the 
      Ruta rule language and the UIMA Ruta Workbench integrate smoothly with Apache UIMA.
    </p>
  </div>
  
  <div class="section" title="1.2.&nbsp;Getting started"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.tools.ruta.overview.gettingstarted">1.2.&nbsp;Getting started</h2></div></div></div>
    
    <p>
      This section gives a short roadmap how to read the documentation and gives some recommendations how to 
      start developing UIMA Ruta-based applications. This documentation assumes that the reader knows about 
      the core concepts of Apache UIMA. Knowledge of the meaning and usage of the terms <span class="quote">&#8220;<span class="quote">CAS</span>&#8221;</span>, 
      <span class="quote">&#8220;<span class="quote">Feature Structure</span>&#8221;</span>, <span class="quote">&#8220;<span class="quote">Annotation</span>&#8221;</span>, <span class="quote">&#8220;<span class="quote">Type</span>&#8221;</span>, <span class="quote">&#8220;<span class="quote">Type System</span>&#8221;</span> 
      and <span class="quote">&#8220;<span class="quote">Analysis Engine</span>&#8221;</span> is required. Please refer to the documentation of Apache UIMA for an introduction.
    </p>
    <p>  
      Unexperienced users that want to learn about UIMA Ruta can start with the next two sections: 
      <a class="xref" href="#ugr.tools.ruta.overview.coreconcepts" title="1.3.&nbsp;Core Concepts">Section&nbsp;1.3, &#8220;Core Concepts&#8221;</a>
      gives a short overview of the core ideas and features of the UIMA Ruta language and Workbench. 
      This section introduces the main concepts of the UIMA Ruta language. It explains how UIMA Ruta rules 
      are composed and applied, and discusses the advantages of the UIMA Ruta system.
      The following <a class="xref" href="#ugr.tools.ruta.overview.examples" title="1.4.&nbsp;Learning by Example">Section&nbsp;1.4, &#8220;Learning by Example&#8221;</a> approaches the UIMA Ruta language using a different
      perspective. Here, the language is introduced by examples. The first example starts with explaining how a simple rule
      looks like, and each following example extends the syntax or semantics of the UIMA Ruta language. 
      After the consultation of these two sections, the reader is expected to have gained enough 
      knowledge to start writing her first UIMA Ruta-based application.
    </p>  
    <p>
      The UIMA Ruta Workbench was created to support the user and to facilitate the development process. It is strongly recommended to 
      use this Eclipse-based IDE since it, for example, automatically configures the component descriptors and provides editing support like
      syntax checking. <a class="xref" href="#section.ugr.tools.ruta.workbench.install" title="3.1.&nbsp;Installation">Section&nbsp;3.1, &#8220;Installation&#8221;</a> describes how the UIMA Ruta Workbench is installed.
      UIMA Ruta rules can also be applied on CAS without using the UIMA Ruta Workbench. 
      <a class="xref" href="#ugr.tools.ruta.ae.basic.apply" title="4.1.&nbsp;Apply UIMA Ruta Analysis Engine in plain Java">Section&nbsp;4.1, &#8220;Apply UIMA Ruta Analysis Engine in plain Java&#8221;</a> contains examples how to execute UIMA Ruta rules in plain java.
      A good way to get started with UIMA Ruta is to play around with an exemplary UIMA Ruta project, e.g., 
      <span class="quote">&#8220;<span class="quote">ExampleProject</span>&#8221;</span> in the example-projects of the UIMA Ruta source release.
      This UIMA Ruta project contains some simple rules for processing citation metadata.
    </p>  
    <p>    
      <a class="xref" href="#ugr.tools.ruta.language.language" title="Chapter&nbsp;2.&nbsp;Apache UIMA Ruta Language">Chapter&nbsp;2, <i>Apache UIMA Ruta Language</i></a> and <a class="xref" href="#ugr.tools.ruta.workbench" title="Chapter&nbsp;3.&nbsp;Apache UIMA Ruta Workbench">Chapter&nbsp;3, <i>Apache UIMA Ruta Workbench</i></a> provide 
      more detailed descriptions and can be referred to in order to gain knowledge of specific parts 
      of the UIMA Ruta language or the UIMA Ruta Workbench.    
    </p>  
  </div>
  
  <div class="section" title="1.3.&nbsp;Core Concepts"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.tools.ruta.overview.coreconcepts">1.3.&nbsp;Core Concepts</h2></div></div></div>
    
    <p>
      The UIMA Ruta language is an imperative rule language extended with scripting elements. A UIMA Ruta rule defines a
      pattern of annotations with additional conditions. If this pattern applies, then the actions of the rule are performed 
      on the matched annotations. A rule is composed of a sequence of rule elements and a rule element essentially consist of four parts: 
      A matching condition, an optional quantifier, a list of conditions and a list of actions.
      The matching condition is typically a type of an annotation by which the rule element matches on the covered text of one of those annotations.
      The quantifier specifies, whether it is necessary that the rule element successfully matches and how often the rule element may match.
      The list of conditions specifies additional constraints that the matched text or annotations need to fulfill. The list of actions defines
      the consequences of the rule and often creates new annotations or modifies existing annotations. 
      They are only applied if all rule elements of the rule have successfully matched. Examples for UIMA Ruta rules can be found in 
      <a class="xref" href="#ugr.tools.ruta.overview.examples" title="1.4.&nbsp;Learning by Example">Section&nbsp;1.4, &#8220;Learning by Example&#8221;</a>.
    </p>
    <p>
      When UIMA Ruta rules are applied on a document, respectively on a CAS, then they are always grouped in a script file. However, a UIMA Ruta
      script file does not only contain rules, but also other statements. First of all, each script file starts with a package declaration followed by
      a list of optional imports. Then, common statements like rules, type declarations or blocks build the body and functionality of a script.
      <a class="xref" href="#ugr.tools.ruta.ae.basic.apply" title="4.1.&nbsp;Apply UIMA Ruta Analysis Engine in plain Java">Section&nbsp;4.1, &#8220;Apply UIMA Ruta Analysis Engine in plain Java&#8221;</a> gives an example, how UIMA Ruta scripts can be applied in plain Java.
      UIMA Ruta script files are naturally organized in UIMA Ruta projects, which is a concept of the UIMA Ruta Workbench. 
      The structure of a UIMA Ruta project is described in <a class="xref" href="#section.ugr.tools.ruta.workbench.projects" title="3.3.&nbsp;UIMA Ruta Projects">Section&nbsp;3.3, &#8220;UIMA Ruta Projects&#8221;</a>
    </p>
    <p>
      The inference of UIMA Ruta rules, that is the approach how the rules are applied, can be described as imperative depth-first matching.
      In contrast to similar rule-based systems, UIMA Ruta rules are applied in the order they are defined in the script.
      The imperative execution of the matching rules may have disadvantages, but also many advantages like an increased rate of development or 
      an easier explanation. The second main property of the UIMA Ruta inference is the depth-first matching. When a rule matches on a pattern of annotations, then
      an alternative is always tracked until it has matched or failed before the next alternative is considered. The behavior of a rule may change, if 
      it has already matched on an early alternative and thus has performed an action, which influences some constraints of the rule.
      Examples, how UIMA Ruta rules are applied, are given in <a class="xref" href="#ugr.tools.ruta.overview.examples" title="1.4.&nbsp;Learning by Example">Section&nbsp;1.4, &#8220;Learning by Example&#8221;</a>.
    </p>
    <p>
      The UIMA Ruta language provides the possibility to approach an annotation problem in different ways. Let us distinguish 
      some approaches as an example.
      It is common in the UIMA Ruta language to create many annotations of different types. These annotations are probably not the targeted annotation of the domain,
      but can be helpful to incrementally approximate the annotation of interest. This enables the user to work <span class="quote">&#8220;<span class="quote">bottom-up</span>&#8221;</span> and <span class="quote">&#8220;<span class="quote">top-down</span>&#8221;</span>.
      In the former approach, the rules add incrementally more complex annotations using simple ones until the target annotation can be created.
      In the latter approach, the rules get more specific while partitioning the document in smaller segments, which result in the targeted annotation, eventually.
      By using many <span class="quote">&#8220;<span class="quote">helper</span>&#8221;</span>-annotations, the engineering task becomes easier and more comprehensive.
      The UIMA Ruta language provides distinctive language elements for different tasks. There are, for example, actions 
      that are able to create new annotations, actions that are able to remove annotations and actions that are able to modify the
      offsets of annotations. This enables, amongst other things, a transformation-based approach. The user starts by creating general rules that are able to
      annotate most of the text fragments of interest. Then, instead of making these rules more complex by adding more conditions for situations where they fail,
      additional rules are defined that correct the mistakes of the general rules, e.g., by deleting false positive annotations.
      <a class="xref" href="#ugr.tools.ruta.overview.examples" title="1.4.&nbsp;Learning by Example">Section&nbsp;1.4, &#8220;Learning by Example&#8221;</a> provides some examples how UIMA Ruta rules can be engineered.
    </p>
    <p>
      To write rules manually is a tedious and error-prone process. The <a class="link" href="#ugr.tools.ruta.workbench" title="Chapter&nbsp;3.&nbsp;Apache UIMA Ruta Workbench">UIMA Ruta Workbench</a>
      was developed to facilitate writing rules by providing as much tooling support as possible. This includes, for example, syntax checking and auto completion, which
      make the development less error-prone. The user can annotate documents and use these documents as unit tests for test-driven development or 
      quality maintenance. Sometimes, it is necessary to debug the rules because they do not match as expected. In this case, the explanation perspective provides views
      that explain every detail of the matching process. Finally, the UIMA Ruta language can also be used by the tooling, for example, by the <span class="quote">&#8220;<span class="quote">Query</span>&#8221;</span> view.
      Here, UIMA Ruta rules can be used as query statements in order to investigate annotated documents.
    </p>
    <p>
      UIMA Ruta smoothly integrates with Apache UIMA. First of all, the UIMA Ruta rules are applied using a generic Analysis Engine and thus UIMA Ruta scripts can 
      easily be added to Apache UIMA pipelines. UIMA Ruta also provides the functionality to import and use other UIMA components like Analysis Engines and Type Systems.
      UIMA Ruta rules can refer to every type defined in an imported type system, and the UIMA Ruta Workbench generates a type system descriptor file containing all 
      types that were defined in a script file. Any Analysis Engine can be executed by rules as long as their implementation is available in the classpath. Therefore,
      functionality outsourced in an arbitrary Analysis Engine can be added and used within UIMA Ruta.
    </p>
  </div>
  
  <div class="section" title="1.4.&nbsp;Learning by Example"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.tools.ruta.overview.examples">1.4.&nbsp;Learning by Example</h2></div></div></div>
    
    <p>
      This section gives an introduction to the UIMA Ruta language by explaining the rule syntax 
      and inference with some simplified examples. It is recommended to use the UIMA Ruta Workbench to write UIMA Ruta rules
      in order to gain advantages like syntax checking. A short description how to install the UIMA Ruta Workbench 
      is given <a class="link" href="#section.ugr.tools.ruta.workbench.install" title="3.1.&nbsp;Installation">here</a>. The following examples make use of the 
      annotations added by the default seeding of the UIMA Ruta Analysis Engine. Their meaning is explained along with the examples. 
    </p>
    <p>
      The first example consists of a declaration of a type followed by a simple rule. Type declarations always start with the keyword 
      <span class="quote">&#8220;<span class="quote">DECLARE</span>&#8221;</span> followed by the short name of the new type. The namespace of the type is equal to the package declaration of the script file.
      If there is no package declaration, then the types declared in the script file have no namespace.
      There is also the possibility to create more complex types with features or specific parent types, but this will be neglected for now.
      In the example, a simple annotation type with the short name <span class="quote">&#8220;<span class="quote">Animal</span>&#8221;</span> is defined.
      After the declaration of the type, a rule with one rule element is given. 
      UIMA Ruta rules in general can consist of a sequence of rule elements. Simple rule elements themselves consist of four parts: A matching condition,
      an optional quantifier, an optional list of conditions and an optional list of actions. The rule element in the 
      following example has a matching condition <span class="quote">&#8220;<span class="quote">W</span>&#8221;</span>, an annotation type standing for normal words. 
      Statements like declarations and rules always end with a semicolon. 
    </p>
    
    <pre class="programlisting">DECLARE Animal;
W{REGEXP("dog") -&gt; MARK(Animal)};</pre>

    <p>
      The rule element also contains one condition and one action, both surrounded by curly parentheses. In order to distinguish conditions from actions
      they are separated by <span class="quote">&#8220;<span class="quote">-&gt;</span>&#8221;</span>. The condition <span class="quote">&#8220;<span class="quote">REGEXP("dog")</span>&#8221;</span> indicates that the matched 
      word must match the regular expression <span class="quote">&#8220;<span class="quote">dog</span>&#8221;</span>. If the matching condition and the additional regular expression are fulfilled, then the action
      is executed, which creates a new annotation of the type <span class="quote">&#8220;<span class="quote">Animal</span>&#8221;</span> with the same offsets as the matched token.
      The default seeder does actually not add annotations of the type <span class="quote">&#8220;<span class="quote">W</span>&#8221;</span>, but annotations of the types <span class="quote">&#8220;<span class="quote">SW</span>&#8221;</span> and 
      <span class="quote">&#8220;<span class="quote">CW</span>&#8221;</span> for small written words and capitalized words, which both have the parent type <span class="quote">&#8220;<span class="quote">W</span>&#8221;</span>.
    </p>
    
    <p>
      There is also the possibility to add implicit actions and conditions, which have no explicit name, but consist only of an expression.
      In the part of the conditions, boolean expressions and feature match expression can be applied, and in the part of the actions,
      type expressions and feature assignment expression can be added. The following example contains one implicit condition and one implicit action.
      The additional condition is a boolean expression (boolean variable), which is set to <span class="quote">&#8220;<span class="quote">true</span>&#8221;</span>, and therefore is always fulfills the condition.
      The <span class="quote">&#8220;<span class="quote">MARK</span>&#8221;</span> action was replaced by a type expression, which refer to the type <span class="quote">&#8220;<span class="quote">Animal</span>&#8221;</span>. The following rule shows, therefore,
      the same behavior as the rule in the last example.
    </p>
    
    <pre class="programlisting">DECLARE Animal;
BOOLEAN active = true;
W{REGEXP("dog"), active -&gt; Animal};</pre>
    
    <p>
      There is also a special kind of rules, which follow a different syntax and semantic, and enables a simplified creation of annotations based on regular expression.
      The following rule, for example, creates an <span class="quote">&#8220;<span class="quote">Animal</span>&#8221;</span> annotation for each occurrence of <span class="quote">&#8220;<span class="quote">dog</span>&#8221;</span> or <span class="quote">&#8220;<span class="quote">cat</span>&#8221;</span>.
    </p>
    
    <pre class="programlisting">DECLARE Animal;
"dog|cat" -&gt; Animal;</pre>
    
    <p>
      Since it is tedious to create Animal annotations by matching on different regular expression, we apply an external dictionary in the next example.
      The first line defines a word list named <span class="quote">&#8220;<span class="quote">AnimalsList</span>&#8221;</span>, which is located in the resource folder (the file <span class="quote">&#8220;<span class="quote">Animals.txt</span>&#8221;</span> 
      contains one animal name in each line). After the declaration of the type, a rule uses this word list to find all occurrences of animals
      in the complete document.
    </p>

    <pre class="programlisting">WORDLIST AnimalsList = 'Animals.txt;'
DECLARE Animal;
Document{-&gt; MARKFAST(Animal, AnimalsList)};
</pre>
    
    <p>
      The matching condition of the rule element refers to the complete document, or more specific to the annotation of the type 
      <span class="quote">&#8220;<span class="quote">DocumentAnnotation</span>&#8221;</span>, which covers the whole document.
      The action <span class="quote">&#8220;<span class="quote">MARKFAST</span>&#8221;</span> of this rule element creates an annotation of the type <span class="quote">&#8220;<span class="quote">Animal</span>&#8221;</span> for each found
      entry of the dictionary <span class="quote">&#8220;<span class="quote">AnimalsList</span>&#8221;</span>.
    </p>
    
    <p>
      The next example introduces rules with more than one rule element, whereby one of them is a composed rule element. The following rule tries to
      annotate occurrences of animals separated by commas, e.g., <span class="quote">&#8220;<span class="quote">dog, cat, bird</span>&#8221;</span>. 
    </p>
    
    <pre class="programlisting">DECLARE AnimalEnum;
(Animal COMMA)+{-&gt; MARK(AnimalEnum,1,2)} Animal;</pre>
    
    <p>
      The rule consists of two rule elements, with <span class="quote">&#8220;<span class="quote">(Animal COMMA)+{-&gt; MARK(AnimalEnum,1,2)}</span>&#8221;</span> being the first rule element and 
      <span class="quote">&#8220;<span class="quote">Animal</span>&#8221;</span> the second one. Let us take a closer look at the first rule element. This rule element is actually composed of two normal rule elements, 
      that are <span class="quote">&#8220;<span class="quote">Animal</span>&#8221;</span> and <span class="quote">&#8220;<span class="quote">COMMA</span>&#8221;</span>, and contains a greedy quantifier and one action. This rule element, therefore, matches on 
      one Animal annotation and a following comma. This is repeated until one of the inner rule elements does not match anymore. Then, there has to be
      another Animal annotation afterwards, specified by the second rule element of the rule. In this case, the rule matches and its action is executed:
      The MARK action creates a new annotation of the type <span class="quote">&#8220;<span class="quote">AnimalEnum</span>&#8221;</span>. However, in contrast to the previous examples, this action also
      contains two numbers. These numbers refer to the rule elements that should be used to calculate the span of the created annotation. The numbers 
      <span class="quote">&#8220;<span class="quote">1, 2</span>&#8221;</span> state that the new annotation should start with the first rule element, the composed one, and should end with the second rule element.
    </p>

    <p>
      Let us make the composed rule element more complex. The following rule also matches on lists of animals, which are
      separated by semicolon. A disjunctive rule element is therefore added, indicated by the symbol <span class="quote">&#8220;<span class="quote">|</span>&#8221;</span>, which matches on
      annotations of the type <span class="quote">&#8220;<span class="quote">COMMA</span>&#8221;</span> or <span class="quote">&#8220;<span class="quote">SEMICOLON</span>&#8221;</span>.
    </p>
    <pre class="programlisting">(Animal (COMMA | SEMICOLON))+{-&gt; MARK(AnimalEnum,1,2)} Animal;</pre>

    <p>
      There two more special symbols that can be used to link rule elements. If the symbol <span class="quote">&#8220;<span class="quote">|</span>&#8221;</span> is replaced by the
      symbol <span class="quote">&#8220;<span class="quote">&amp;</span>&#8221;</span> in the last example, then the token after the animal need to be a comma and a semicolon, which is of course not possible.
      Another symbol with a special meaning is <span class="quote">&#8220;<span class="quote">%</span>&#8221;</span>, which cannot only be used within a composed rule element (parentheses).
      This symbol can be interpreted as a global <span class="quote">&#8220;<span class="quote">and</span>&#8221;</span>: It links several rules, which only fire, if all rules have successfully matched. 
      In the following example, an annotation of the type <span class="quote">&#8220;<span class="quote">FoundIt</span>&#8221;</span> is created, if the document contains two periods in a row and two commas in a row:
    </p>
    
    <pre class="programlisting">PERIOD PERIOD % COMMA COMMA{-&gt; FoundIt};</pre>


    <p>
      There is a <span class="quote">&#8220;<span class="quote">wild card</span>&#8221;</span> rule element, which can be used to skip some text or annotations until the next rule element is able to match.
    </p>
    
    <pre class="programlisting">DECLARE Sentence;
PERIOD #{-&gt; MARK(Sentence)} PERIOD;</pre>
    
    <p>
      This rule annotates everything between two <span class="quote">&#8220;<span class="quote">PERIOD</span>&#8221;</span> annotations with the type <span class="quote">&#8220;<span class="quote">Sentence</span>&#8221;</span>. Please note that the resulting 
      annotations is automatically trimmed using the current filtering settings.
    </p>

    <p>
      Rule elements can contain more then one condition. The rule in the next example tries to identify headlines, which are bold, 
      underlined and end with a colon.
    </p>

    <pre class="programlisting">DECLARE Headline;
Paragraph{CONTAINS(Bold, 90, 100, true), 
    CONTAINS(Underlined, 90, 100, true), ENDSWITH(COLON) 
    -&gt; MARK(Headline)};</pre>
    
    <p>
      The matching condition of this rule element is given with the type <span class="quote">&#8220;<span class="quote">Paragraph</span>&#8221;</span>, thus the rule takes a look at all Paragraph annotations.
      The rule matches only if the three conditions, separated by commas, are fulfilled. The first condition <span class="quote">&#8220;<span class="quote">CONTAINS(Bold, 90, 100, true)</span>&#8221;</span> states that
      90%-100% of the matched paragraph annotation should also be annotated with annotations of the type <span class="quote">&#8220;<span class="quote">Bold</span>&#8221;</span>. The boolean parameter <span class="quote">&#8220;<span class="quote">true</span>&#8221;</span>
      indicates that amount of Bold annotations should be calculated relatively to the matched annotation. The two numbers <span class="quote">&#8220;<span class="quote">90,100</span>&#8221;</span> are, therefore, interpreted as
      percent amounts. The exact calculation of the coverage is dependent on the tokenization of the document and is neglected for now. The second condition 
      <span class="quote">&#8220;<span class="quote">CONTAINS(Underlined, 90, 100, true)</span>&#8221;</span> consequently states that the paragraph should also contain at least 90% of annotations of the type <span class="quote">&#8220;<span class="quote">underlined</span>&#8221;</span>.
      The third condition <span class="quote">&#8220;<span class="quote">ENDSWITH(COLON)</span>&#8221;</span> finally forces the Paragraph annotation to end with a colon. It is only fulfilled, if there is an annotation of the type
      <span class="quote">&#8220;<span class="quote">COLON</span>&#8221;</span>, which has an end offset equal to the end offset of the matched Paragraph annotation.
    </p>
    
    <p>
      The readability and maintenance of rules does not increase, if more conditions are added.
      One of the strengths of the UIMA Ruta language is that it provides different approaches to solve an annotation task. The next two examples 
      introduce actions for transformation-based rules.  
    </p>
    
    <pre class="programlisting">Headline{-CONTAINS(W) -&gt; UNMARK(Headline)};</pre>
    
    <p>
      This rule consists of one condition and one action. The condition <span class="quote">&#8220;<span class="quote">-CONTAINS(W)</span>&#8221;</span> is negated (indicated by the character <span class="quote">&#8220;<span class="quote">-</span>&#8221;</span>), 
      and is therefore only fulfilled, if there are no annotations of the type <span class="quote">&#8220;<span class="quote">W</span>&#8221;</span> within the bound of the matched Headline annotation.
      The action <span class="quote">&#8220;<span class="quote">UNMARK(Headline)</span>&#8221;</span> removes the matched Headline annotation. Put into simple words, headlines that contain no words at all are not headlines.
    </p>
    
    <p>
      The next rule does not remove an annotation, but changes its offsets dependent on the context.
    </p>
    
    <pre class="programlisting">Headline{-&gt; SHIFT(Headline, 1, 2)} COLON;</pre>
    
    <p>
      Here, the action <span class="quote">&#8220;<span class="quote">SHIFT(Headline, 1, 2)</span>&#8221;</span> expands the matched Headline annotation to the next colon, if that Headline annotation
      is followed by a COLON annotation.
    </p>
    
    <p>
      UIMA Ruta rules can contain arbitrary conditions and actions, which is illustrated by the next example.
    </p>
    
    <pre class="programlisting">DECLARE Month, Year, Date;
ANY{INLIST(MonthsList) -&gt; MARK(Month), MARK(Date,1,3)}
    PERIOD? NUM{REGEXP(".{2,4}") -&gt; MARK(Year))};</pre>

    <p>
      This rule consists of three rule elements. The first one matches on every token, which has a covered text that occurs in a word lists named <span class="quote">&#8220;<span class="quote">MonthsList</span>&#8221;</span>.
      The second rule element is optional and does not need to be fulfilled, which is indicated by the quantifier <span class="quote">&#8220;<span class="quote">?</span>&#8221;</span>. The last rule element matches
      on numbers that fulfill the regular expression <span class="quote">&#8220;<span class="quote">REGEXP(".{2,4}"</span>&#8221;</span> and are therefore at least two characters to a maximum of four characters long.
      If this rule successfully matches on a text passage, then its three actions are executed: An annotation of the type <span class="quote">&#8220;<span class="quote">Month</span>&#8221;</span> is created for the first rule element,
      an annotation of the type <span class="quote">&#8220;<span class="quote">Year</span>&#8221;</span> is created for the last rule element and an annotation of the type <span class="quote">&#8220;<span class="quote">Date</span>&#8221;</span> 
      is created for the span of all three rule elements. If the word list contains the correct entries, then this rule matches on strings like 
      <span class="quote">&#8220;<span class="quote">Dec. 2004</span>&#8221;</span>, <span class="quote">&#8220;<span class="quote">July 85</span>&#8221;</span> or <span class="quote">&#8220;<span class="quote">11.2008</span>&#8221;</span> and creates the corresponding annotations.
    </p>

    <p>
      After introducing the composition of rule elements, the default matching strategy is examined. The two rules in the next example create an annotation
      for a sequence of arbitrary tokens with the only difference of one condition.
    </p>

    <pre class="programlisting">DECLARE Text1, Text2;
ANY+{ -&gt; MARK(Text1)};
ANY+{-PARTOF(Text2) -&gt; MARK(Text2)};</pre>

    <p>
      The first rule matches on each occurrence of an arbitrary token and continues this until the end of the document is reached. 
      This is caused by the greedy quantifier <span class="quote">&#8220;<span class="quote">+</span>&#8221;</span>. Note that this rule considers each occurrence of a token and is therefore
      executed for each token resulting many overlapping annotations. This behavior is illustrated with an example:
      When applied on the document <span class="quote">&#8220;<span class="quote">Peter works for Frank</span>&#8221;</span>, the rule creates four annotations with the covered texts 
      <span class="quote">&#8220;<span class="quote">Peter works for Frank</span>&#8221;</span>, <span class="quote">&#8220;<span class="quote">works for Frank</span>&#8221;</span>, <span class="quote">&#8220;<span class="quote">for Frank</span>&#8221;</span> and <span class="quote">&#8220;<span class="quote">Frank</span>&#8221;</span>.
      The rule first tries to match on the token <span class="quote">&#8220;<span class="quote">Peter</span>&#8221;</span> and continues its matching. Then, it tries to match on the token <span class="quote">&#8220;<span class="quote">works</span>&#8221;</span> and
      continues its matching, and so on.
    </p>
    <p>
      In this example, the second rule only returns one annotation, which covers the complete document. This is caused by the additional
      condition <span class="quote">&#8220;<span class="quote">-PARTOF(Text2)</span>&#8221;</span>. The PARTOF condition is fulfilled, if the matched annotation is located within an annotation of the given type, or
      put in simple words, if the matched annotation is part of an annotation of the type <span class="quote">&#8220;<span class="quote">Text2</span>&#8221;</span>. When applied on the 
      document <span class="quote">&#8220;<span class="quote">Peter works for Frank</span>&#8221;</span>, the rule matches on the first token <span class="quote">&#8220;<span class="quote">Peter</span>&#8221;</span>, continues its match and 
      creates an annotation of the type <span class="quote">&#8220;<span class="quote">Text2</span>&#8221;</span> for the complete document. Then it tries to match on the second token <span class="quote">&#8220;<span class="quote">works</span>&#8221;</span>, but fails, 
      because this token is already part of an Text2 annotation.
    </p>
    
    <p>
      UIMA Ruta rules can not only be used to create or modify annotations, but also to create features for annotations. The next example defines 
      and assigns a relation of employment, by storing the given annotations as feature values.
    </p>
    
    <pre class="programlisting">DECLARE Annotation EmplRelation 
    (Employee employeeRef, Employer employerRef);
Sentence{CONTAINS(EmploymentIndicator) -&gt; CREATE(EmplRelation,
    "employeeRef" = Employee, "employerRef" = Employer)};</pre>

    <p>
      The first statement of this example is a declaration that defines a new type of annotation named <span class="quote">&#8220;<span class="quote">EmplRelation</span>&#8221;</span>. 
      This annotation has two features: 
      One feature with the name <span class="quote">&#8220;<span class="quote">employeeRef</span>&#8221;</span> of the type <span class="quote">&#8220;<span class="quote">Employee</span>&#8221;</span> and 
      one feature with the name <span class="quote">&#8220;<span class="quote">employerRef</span>&#8221;</span> of the type <span class="quote">&#8220;<span class="quote">Employer</span>&#8221;</span>.
      If the parent type is Annotation, then it can be omitted resulting in the following declaration:
      </p><pre class="programlisting">DECLARE EmplRelation (Employee employeeRef, Employer employerRef);</pre><p>
      The second statement of the example, which is a simple rule, creates one annotation of the type <span class="quote">&#8220;<span class="quote">EmplRelation</span>&#8221;</span> for
      each Sentence annotation that contains at least one annotation of the type <span class="quote">&#8220;<span class="quote">EmploymentIndicator</span>&#8221;</span>. Additionally to creating an annotation,
      the CREATE action also assigns an annotation of the <span class="quote">&#8220;<span class="quote">Employee</span>&#8221;</span>, which needs to be located within the span of the matched sentence, 
      to the feature <span class="quote">&#8220;<span class="quote">employeeRef</span>&#8221;</span> and an Employer annotation to the feature <span class="quote">&#8220;<span class="quote">employerRef</span>&#8221;</span>. The annotations mentioned in this 
      example need to be present in advance.
    </p>

    <p>
      In order to refer to annotations and, for example, assigning them to some features, 
      special kinds of local and global variables can be utilized. Local variables for annotations 
      do not need to be defined by are specified by a label at a rule element. This label can be utilized
      for referring to the matched annoation of this rule element within the current rule match alone.
      Global variables for annotations are declared like other variables and are able to store annotations
      across rules. The following example illustrate some simple use cases using local variables:
    </p>

    <pre class="programlisting">DECLARE Annotation EmplRelation 
   (Employee employeeRef, Employer employerRef);
e1:Employer # EmploymentIndicator # e2:Employee)
    {-&gt; EmplRelation, EmplRelation.employeeRef=e2, EmplRelation.employerRef=e1};</pre>

    <p>
      In the last examples, the values of features were defined as annotation types. However, also primitive 
      types can be used, as will be shown in the next example, together with a short introduction of variables.
    </p>

    <pre class="programlisting">DECLARE Annotation MoneyAmount(STRING currency, INT amount);
INT moneyAmount;
STRING moneyCurrency;
NUM{PARSE(moneyAmount)} SPECIAL{REGEXP("&#8364;") -&gt; MATCHEDTEXT(moneyCurrency),
    CREATE(MoneyAmount, 1, 2, "amount" = moneyAmount,
        "currency" = moneyCurrency)};</pre>
    
    <p>
      First, a new annotation with the name <span class="quote">&#8220;<span class="quote">MoneyAmount</span>&#8221;</span> and two features are defined, one string feature and one integer feature.
      Then, two UIMA Ruta variables are declared, one integer variable and one string variable. The rule matches on a number, whose value is stored 
      in the variable <span class="quote">&#8220;<span class="quote">moneyAmount</span>&#8221;</span>, followed by a special token that needs to be equal to the string <span class="quote">&#8220;<span class="quote">&#8364;</span>&#8221;</span>. Then,
      the covered text of the special annotation is stored in the string variable <span class="quote">&#8220;<span class="quote">moneyCurrency</span>&#8221;</span> and annotation of the
      type <span class="quote">&#8220;<span class="quote">MoneyAmount</span>&#8221;</span> spanning over both rule elements is created. Additionally, the variables are assigned as feature values.
    </p>

    <p>
      Using feature expression for conditions and action, can reduce the complexity of a rule. The first rule in the following example set the value of the feature
      <span class="quote">&#8220;<span class="quote">currency</span>&#8221;</span> of the annotation of the type <span class="quote">&#8220;<span class="quote">MoneyAmount</span>&#8221;</span> to <span class="quote">&#8220;<span class="quote">Euro</span>&#8221;</span>, if it was <span class="quote">&#8220;<span class="quote">&#8364;</span>&#8221;</span> before.
      The second rule creates an annotation of the type <span class="quote">&#8220;<span class="quote">LessThan</span>&#8221;</span> for all annotations of the type <span class="quote">&#8220;<span class="quote">MoneyAmount</span>&#8221;</span>, 
      if their amount is less than 100 and the currency is <span class="quote">&#8220;<span class="quote">Euro</span>&#8221;</span>. 
    </p>
    
    <pre class="programlisting">DECLARE LessThan;
MoneyAmount.currency=="&#8364;"{-&gt; MoneyAmount.currency="Euro"};
MoneyAmount{(MoneyAmount.amount&lt;=100), 
    MoneyAmount.currency=="Euro" -&gt; LessThan};</pre>

    <p>
      UIMA Ruta script files with many rules can quickly confuse the reader. The UIMA Ruta language, therefore, allows to import other script files in order to increase
      the modularity of a project or to create rule libraries. The next example imports the rules together with all known types of another script file 
      and executes that script file.
    </p>

    <pre class="programlisting">SCRIPT uima.ruta.example.SecondaryScript;
Document{-&gt; CALL(SecondaryScript)};</pre>

    <p>
      The script file with the name <span class="quote">&#8220;<span class="quote">SecondaryScript.ruta</span>&#8221;</span>, which is located in the package <span class="quote">&#8220;<span class="quote">uima/ruta/example</span>&#8221;</span>, is imported and executed
      by the CALL action on the complete document. The script needs to be located in the folder specified by the parameter 
      <a class="link" href="#ugr.tools.ruta.ae.basic.parameter.scriptPaths" title="scriptPaths">scriptPaths</a>, or in a coresponding packgae in the classpath. It is also possible to import script files of other UIMA Ruta projects, e.g.,
      by adapting the configuration parameters of the UIMA Ruta Analysis Engine or 
      by setting a project reference in the project properties of a UIMA Ruta project.
    </p>

    <p>
      For simple rules that match on the complete document and only specify actions, a simplified syntax exists that omits the matching parts:
    </p>
    
    <pre class="programlisting">SCRIPT uima.ruta.example.SecondaryScript;
CALL(SecondaryScript);</pre>

    <p>
      The types of important annotations of the application are often defined in a separate type system. The next example shows how to import those types.
    </p>

    <pre class="programlisting">TYPESYSTEM my.package.NamedEntityTypeSystem;
Person{PARTOF(Organization) -&gt; UNMARK(Person)};
</pre>

    <p>
      The type system descriptor file with the name <span class="quote">&#8220;<span class="quote">NamedEntityTypeSystem.xml</span>&#8221;</span> located in the package <span class="quote">&#8220;<span class="quote">my/package</span>&#8221;</span> is imported.
      The descriptor needs to be located in a folder specified by the parameter 
      <a class="link" href="#ugr.tools.ruta.ae.basic.parameter.descriptorPaths" title="descriptorPaths">descriptorPaths</a>.
    </p>


    <p>
      It is sometimes easier to express functionality with control structures known by programming languages rather than to engineer all functionality 
      only with matching rules. The UIMA Ruta language provides the BLOCK element for some of these use cases. 
      The UIMA Ruta BLOCK element starts with the keyword <span class="quote">&#8220;<span class="quote">BLOCK</span>&#8221;</span> followed by its name in parentheses. The name of a block has two purposes:
      On the one hand, it is easier to distinguish the block, if they have different names, e.g., in the 
      <a class="link" href="#section.ugr.tools.ruta.workbench.explain_perspective" title="3.5.&nbsp;UIMA Ruta Explain Perspective">explain perspective</a> of the UIMA Ruta Workbench. On the other hand,
      the name can be used to execute this block using the CALL action. Hereby, it is possible to access only specific sets of rules of other script files, 
      or to implement a recursive call of rules. After the name of the block, a single rule element is given, which has curly parentheses, 
      even if no conditions or actions are specified. Then, the body of the block is framed by curly brackets.
    </p>

    <pre class="programlisting">BLOCK(English) Document{FEATURE("language", "en")} {
    // rules for english documents
}
BLOCK(German) Document{FEATURE("language", "de")} {
    // rules for german documents
}</pre>

    <p>
      This example contains two simple BLOCK statements. The rules defined within the block are only executed, if the condition in the head of the block is fulfilled.
      The rules of the first block are only considered if the feature <span class="quote">&#8220;<span class="quote">language</span>&#8221;</span> of the document annotation has the value <span class="quote">&#8220;<span class="quote">en</span>&#8221;</span>.
      Following this, the rules of the second block are only considered for German documents.
    </p>

    <p>
      The rule element of the block definition can also refer to other annotation types than <span class="quote">&#8220;<span class="quote">Document</span>&#8221;</span>. While the last example implemented something similar 
      to an if-statement, the next example provides a show case for something similar to a for-each-statement.
    </p>

    <pre class="programlisting">DECLARE SentenceWithNoLeadingNP;
BLOCK(ForEach) Sentence{} {
    Document{-STARTSWITH(NP) -&gt; MARK(SentenceWithNoLeadingNP)};
}
</pre>
    
    <p>
      Here, the rule in the block statement is performed for each occurrence of an annotation of the type <span class="quote">&#8220;<span class="quote">Sentence</span>&#8221;</span>. 
      The rule within the block matches on the complete document, which is the current sentence in the context of the block statement. 
      As a consequence, this example creates an annotation of the type <span class="quote">&#8220;<span class="quote">SentenceWithNoLeadingNP</span>&#8221;</span> for each sentence 
      that does not start with a NP annotation.
    </p>

    <p>
      There are two more language constructs (<span class="quote">&#8220;<span class="quote">-&gt;</span>&#8221;</span> and <span class="quote">&#8220;<span class="quote">&lt;-</span>&#8221;</span>) that allow to apply rules within a certain context. These rules are added to an arbitrary rule element 
      and are called inlined rules. The first example interprets the inlined rules as actions. They are executed if the surrounding rule was able to match, 
      which makes this one very similar to the block statement.
    </p>

    <pre class="programlisting">DECLARE SentenceWithNoLeadingNP;
Sentence{}-&gt;{
    Document{-STARTSWITH(NP) -&gt; SentenceWithNoLeadingNP};
};
</pre>

    <p>
      The second one (<span class="quote">&#8220;<span class="quote">&lt;-</span>&#8221;</span>) interprets the inlined rules as conditions. The surrounding rule can only match if at least one inlined rule was successfully applied.
      In the following example, a sentence is annotated with the type SentenceWithNPNP, if there are two successive NP annotations within this sentence.
    </p>
    <pre class="programlisting">DECLARE SentenceWithNPNP;
Sentence{-&gt; SentenceWithNPNP}&lt;-{
    NP NP;
};
</pre>
    <p>
      Let us take a closer look on what exactly the UIMA Ruta rules match. The following rule matches on a word followed by another word:
    </p>
    <pre class="programlisting">W W;</pre>
    
    <p>
      To be more precise, this rule matches on all documents like <span class="quote">&#8220;<span class="quote">Apache UIMA</span>&#8221;</span>, <span class="quote">&#8220;<span class="quote">Apache     UIMA</span>&#8221;</span>, <span class="quote">&#8220;<span class="quote">ApacheUIMA</span>&#8221;</span>,
      <span class="quote">&#8220;<span class="quote">Apache &lt;b&gt;UIMA&lt;/b&gt;</span>&#8221;</span>. There are two main reasons for this: First of all, it depends on how the available annotations are defined. The default seeder
      for the initial annotations creates an annotation for all characters until an upper case character occurs. Thus, the string <span class="quote">&#8220;<span class="quote">ApacheUIMA</span>&#8221;</span> consists of 
      two tokens.
      However, more important, the UIMA Ruta language provides a concept of visibility of the annotations. By default, all annotations of the types 
      <span class="quote">&#8220;<span class="quote">SPACE</span>&#8221;</span>, <span class="quote">&#8220;<span class="quote">NBSP</span>&#8221;</span>, <span class="quote">&#8220;<span class="quote">BREAK</span>&#8221;</span> and <span class="quote">&#8220;<span class="quote">MARKUP</span>&#8221;</span> (whitespace and XML elements) are filtered and not visible. This holds of course for
      their covered text, too. The rule elements skip all positions of the
      document where those annotations occur. The rule in the last example matches on all examples. Without the default filtering settings, 
      with all annotations set to visible, the rule matches only on the document <span class="quote">&#8220;<span class="quote">ApacheUIMA</span>&#8221;</span> since it is the only one that contains two word annotations without
      any whitespace between them. 
    </p>
    
    <p>
      The filtering setting can also be modified by the UIMA Ruta rules themselves. The next example provides rules that extend and limit 
      the amount of visible text of the document.
    </p>
    
    <pre class="programlisting">Sentence;
Document{-&gt; RETAINTYPE(SPACE)};
Sentence;
Document{-&gt; FILTERTYPE(CW)};
Sentence;
Document{-&gt; RETAINTYPE, FILTERTYPE};</pre>

    <p>
      The first rule matches on sentences, which do not start with any filtered type. Sentences that start with whitespace or markup, 
      for example, are not considered. 
      The next rule retains all text that is covered by annotations of the type <span class="quote">&#8220;<span class="quote">SPACE</span>&#8221;</span> meaning 
      that the rule elements are now sensible to whitespaces. The following rule will, therefore, match on sentences that start with whitespaces.
      The third rule now filters the type <span class="quote">&#8220;<span class="quote">CW</span>&#8221;</span> with the consequence that all capitalized words are invisible.
      If the following rule now wants to match on sentences, then this is only possible for Sentence annotations that do not start with a capitalized word.
      The last rule finally resets the filtering setting to the default configuration in the UIMA Ruta Analysis Engine.
    </p>
    
    <p>
      The next example gives a showcase for importing external Analysis Engines and for modifying the documents by creating a new view called <span class="quote">&#8220;<span class="quote">modified</span>&#8221;</span>.
      Additional Analysis Engines can be imported with the keyword <span class="quote">&#8220;<span class="quote">ENGINE</span>&#8221;</span> followed by the name of the descriptor. These imported Analysis Engines can be 
      executed with the actions <span class="quote">&#8220;<span class="quote">CALL</span>&#8221;</span> or <span class="quote">&#8220;<span class="quote">EXEC</span>&#8221;</span>. If the executed Analysis Engine adds, removes or modifies annotations, then their types need 
      to be mentioned when calling the descriptor, or else these annotations will not be correctly processed by the following UIMA Ruta rules.
    </p>

    <pre class="programlisting">ENGINE utils.Modifier;
Date{-&gt; DEL};
MoneyAmount{-&gt; REPLACE("&lt;MoneyAmount/&gt;")};
Document{-&gt; COLOR(Headline, "green")};
Document{-&gt; EXEC(Modifier)};
</pre>

  <p>
    In this example, we first import an Analysis Engine defined by the descriptor <span class="quote">&#8220;<span class="quote">Modifier.xml</span>&#8221;</span> located in the folder <span class="quote">&#8220;<span class="quote">utils</span>&#8221;</span>. 
    The descriptor needs to be located in the folder specified by the parameter <a class="link" href="#ugr.tools.ruta.ae.basic.parameter.descriptorPaths" title="descriptorPaths">descriptorPaths</a>.
    The first rule deletes all text covered by annotations of the type <span class="quote">&#8220;<span class="quote">Date</span>&#8221;</span>. The second rule replaces the text of all annotations of the type <span class="quote">&#8220;<span class="quote">MoneyAmount</span>&#8221;</span> 
    with the string <span class="quote">&#8220;<span class="quote">&lt;MoneyAmount/&gt;</span>&#8221;</span>. The third rule remembers to set the background color of text in Headline annotation to green. The last rule
    finally performs all of these changes in an additional view called <span class="quote">&#8220;<span class="quote">modified</span>&#8221;</span>, which is specified in the configuration parameters of the analysis engine.
    <a class="xref" href="#ugr.tools.ruta.ae.modifier" title="1.5.4.&nbsp;Modifier">Section&nbsp;1.5.4, &#8220;Modifier&#8221;</a> and <a class="xref" href="#ugr.tools.ruta.language.modification" title="2.13.&nbsp;Modification">Section&nbsp;2.13, &#8220;Modification&#8221;</a> provide a more detailed description.
  </p>
  
  <p>
    In the last example, a descriptor file was loaded in order to import and apply an external analysis engine. Analysis engines can also be loaded using uimaFIT, 
    whereas the given class name has to be present in the classpath. In the UIMA Ruta Workbench, you can add a dependency to a java project, which contains the 
    implementation, to the UIMA Ruta project. If the UIMA Ruta script is applied in a UIMA Pipeline, then the configuration parameter 
    <a class="link" href="#ugr.tools.ruta.ae.basic.parameter.additionalUimafitEngines" title="additionalUimafitEngines">additionalUimafitEngines</a> has to list the class of the analysis engine. 
    The following example loads an analysis engine without an descriptor and applies it on the document. The additional list of types states that
    the annotations of those types created by the analysis engine should be available to the following Ruta rules.
    
  </p>
      <pre class="programlisting">UIMAFIT my.package.impl.MyAnalysisEngine;
Document{-&gt; EXEC(MyAnalysisEngine, {MyType1, MyType2})};
</pre>
  
  </div>
  
  <div class="section" title="1.5.&nbsp;UIMA Analysis Engines"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.tools.ruta.ae">1.5.&nbsp;UIMA Analysis Engines</h2></div></div></div>
    
    <p>This section gives an overview of the UIMA Analysis Engines shipped with UIMA Ruta. The most 
      important one is <span class="quote">&#8220;<span class="quote">RutaEngine</span>&#8221;</span>, a generic analysis engine, which is able to interpret 
      and execute script files. The other analysis engines provide support for some additional functionality or
      add certain types of annotations.
    </p>
    <div class="section" title="1.5.1.&nbsp;Ruta Engine"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.ae.basic">1.5.1.&nbsp;Ruta Engine</h3></div></div></div>
      
      <p>
         This generic Analysis Engine is the most important one for the UIMA Ruta language since it is
         responsible for applying the UIMA Ruta rules on a CAS. Its functionality is configured by the configuration parameters, 
         which, for example, specify the rule file that should be executed. In the UIMA Ruta Workbench, a basic template named <span class="quote">&#8220;<span class="quote">BasicEngine.xml</span>&#8221;</span>
         is given in the descriptor folder of a UIMA Ruta project and correctly configured descriptors typically named <span class="quote">&#8220;<span class="quote">MyScriptEngine.xml</span>&#8221;</span>
         are generated in the descriptor folder corresponding to the package namespace of the script file.
         The available configuration parameters of the UIMA Ruta Analysis Engine are described in the following.   
      </p>
      
      <div class="section" title="1.5.1.1.&nbsp;Configuration Parameters"><div class="titlepage"><div><div><h4 class="title" id="ugr.tools.ruta.ae.basic.parameter">1.5.1.1.&nbsp;Configuration Parameters</h4></div></div></div>
        
        <p>
          The configuration parameters of the UIMA Ruta Analysis Engine can be subdivided into three
          different groups: parameters for the setup of the environment (<a class="link" href="#ugr.tools.ruta.ae.basic.parameter.mainScript" title="mainScript">mainScript</a>
          to <a class="link" href="#ugr.tools.ruta.ae.basic.parameter.additionalExtensions" title="additionalExtensions">additionalExtensions</a>), 
          parameters that change the behavior of the analysis engine (<a class="link" href="#ugr.tools.ruta.ae.basic.parameter.reloadScript" title="reloadScript">reloadScript</a>
          to <a class="link" href="#ugr.tools.ruta.ae.basic.parameter.simpleGreedyForComposed" title="simpleGreedyForComposed">simpleGreedyForComposed</a>) 
          and parameters for creating additional information how the rules were executed 
          (<a class="link" href="#ugr.tools.ruta.ae.basic.parameter.debug" title="debug">debug</a>
          to <a class="link" href="#ugr.tools.ruta.ae.basic.parameter.createdBy" title="createdBy">createdBy</a>). First, a short overview of the configuration parameters is given in
          <a class="xref" href="#table.ugr.tools.ruta.ae.parameter" title="Table&nbsp;1.1.&nbsp;Configuration parameters of the UIMA Ruta Analysis Engine">Table&nbsp;1.1, &#8220;Configuration parameters of the UIMA Ruta Analysis Engine   &#8221;</a>. Afterwards, all parameters are described in detail with examples.
        </p>
        <p>
          To change the value of any configuration parameter within a UIMA Ruta script, the CONFIGURE action (see <a class="xref" href="#ugr.tools.ruta.language.actions.configure" title="2.8.8.&nbsp;CONFIGURE">Section&nbsp;2.8.8, &#8220;CONFIGURE&#8221;</a>)
          can be used. For changing behavior of <a class="link" href="#ugr.tools.ruta.ae.basic.parameter.dynamicAnchoring" title="dynamicAnchoring">dynamicAnchoring</a> the DYNAMICANCHORING action 
          (see <a class="xref" href="#ugr.tools.ruta.language.actions.dynamicanchoring" title="2.8.11.&nbsp;DYNAMICANCHORING">Section&nbsp;2.8.11, &#8220;DYNAMICANCHORING&#8221;</a>) is recommended.
        </p>
        <p>
          </p><div class="table"><a name="table.ugr.tools.ruta.ae.parameter"></a><p class="title"><b>Table&nbsp;1.1.&nbsp;Configuration parameters of the UIMA Ruta Analysis Engine   </b></p><div class="table-contents">
            
            <table summary="Configuration parameters of the UIMA Ruta Analysis Engine   " style="border-collapse: collapse;border-top: 0.5pt solid black; border-bottom: 0.5pt solid black; border-left: 0.5pt solid black; border-right: 0.5pt solid black; "><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><thead><tr><th style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; " align="center">Name</th><th style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; " align="center">Short description</th><th style="border-bottom: 0.5pt solid black; " align="center">Type</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">
                    <a class="link" href="#ugr.tools.ruta.ae.basic.parameter.mainScript" title="mainScript">mainScript</a>
                  </td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">Name with complete namespace of the script which will be interpreted and
                    executed by the analysis engine.
                  </td><td style="border-bottom: 0.5pt solid black; ">Single String</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">
                    <a class="link" href="#ugr.tools.ruta.ae.basic.parameter.rules" title="rules">rules</a>
                  </td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">Script (list of rules) to be applied.
                  </td><td style="border-bottom: 0.5pt solid black; ">Single String</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">
                    <a class="link" href="#ugr.tools.ruta.ae.basic.parameter.scriptEncoding" title="scriptEncoding">scriptEncoding</a>
                  </td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">Encoding of all UIMA Ruta script files.</td><td style="border-bottom: 0.5pt solid black; ">Single String</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">
                    <a class="link" href="#ugr.tools.ruta.ae.basic.parameter.scriptPaths" title="scriptPaths">scriptPaths</a>
                  </td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">List of absolute locations, which contain the necessary script files like
                    the main script.
                  </td><td style="border-bottom: 0.5pt solid black; ">Multi String</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">
                    <a class="link" href="#ugr.tools.ruta.ae.basic.parameter.descriptorPaths" title="descriptorPaths">descriptorPaths</a>
                  </td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">List of absolute locations, which contain the necessary descriptor files
                    like type systems.
                  </td><td style="border-bottom: 0.5pt solid black; ">Multi String</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">
                    <a class="link" href="#ugr.tools.ruta.ae.basic.parameter.resourcePaths" title="resourcePaths">resourcePaths</a>
                  </td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">List of absolute locations, which contain the necessary resource files like
                    word lists.
                  </td><td style="border-bottom: 0.5pt solid black; ">Multi String</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">
                    <a class="link" href="#ugr.tools.ruta.ae.basic.parameter.additionalScripts" title="additionalScripts">additionalScripts</a>
                  </td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">List of names with complete namespace of additional scripts, which can be
                    referred to.
                  </td><td style="border-bottom: 0.5pt solid black; ">Multi String</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">
                    <a class="link" href="#ugr.tools.ruta.ae.basic.parameter.additionalEngines" title="additionalEngines">additionalEngines</a>
                  </td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">List of names with complete namespace of additional analysis engines, which
                    can be called by UIMA Ruta rules.
                  </td><td style="border-bottom: 0.5pt solid black; ">Multi String</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">
                    <a class="link" href="#ugr.tools.ruta.ae.basic.parameter.additionalUimafitEngines" title="additionalUimafitEngines">additionalUimafitEngines</a>
                  </td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">List of class names with complete namespace of additional uimaFIT analysis engines, which
                    can be called by UIMA Ruta rules.
                  </td><td style="border-bottom: 0.5pt solid black; ">Multi String</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">
                    <a class="link" href="#ugr.tools.ruta.ae.basic.parameter.additionalEngineLoaders" title="additionalEngineLoaders">additionalEngineLoaders</a>
                  </td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">List of class names of implementations that are able to perform additional
                    task when loading external analysis engines.
                  </td><td style="border-bottom: 0.5pt solid black; ">Multi String</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">
                    <a class="link" href="#ugr.tools.ruta.ae.basic.parameter.additionalExtensions" title="additionalExtensions">additionalExtensions</a>
                  </td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">List of factory classes for additional extensions of the UIMA Ruta language
                    like proprietary conditions.
                  </td><td style="border-bottom: 0.5pt solid black; ">Multi String</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">
                    <a class="link" href="#ugr.tools.ruta.ae.basic.parameter.reloadScript" title="reloadScript">reloadScript</a>
                  </td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">Option to initialize the rule script each time the analysis engine processes
                    a CAS.
                  </td><td style="border-bottom: 0.5pt solid black; ">Single Boolean</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">
                    <a class="link" href="#ugr.tools.ruta.ae.basic.parameter.seeders" title="seeders">seeders</a>
                  </td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">List of class names that provide additional annotations before the rules are
                    executed.
                  </td><td style="border-bottom: 0.5pt solid black; ">Multi String</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">
                    <a class="link" href="#ugr.tools.ruta.ae.basic.parameter.defaultFilteredTypes" title="defaultFilteredTypes">defaultFilteredTypes</a>
                  </td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">List of complete type names of annotations that are invisible by default.
                  </td><td style="border-bottom: 0.5pt solid black; ">Multi String</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">
                    <a class="link" href="#ugr.tools.ruta.ae.basic.parameter.removeBasics" title="removeBasics">removeBasics</a>
                  </td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">Option to remove all inference annotations after execution of the rule script.
                  </td><td style="border-bottom: 0.5pt solid black; ">Single Boolean</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">
                    <a class="link" href="#ugr.tools.ruta.ae.basic.parameter.reindexOnly" title="reindexOnly">reindexOnly</a>
                  </td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">Option to select annotation types that should be reindex internally in ruta.
                  </td><td style="border-bottom: 0.5pt solid black; ">Multi String</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">
                    <a class="link" href="#ugr.tools.ruta.ae.basic.parameter.strictImports" title="strictImports">strictImports</a>
                  </td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">Option to restrict short type names resolution to those in the declared typesystems.
                  </td><td style="border-bottom: 0.5pt solid black; ">Single Boolean</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">
                    <a class="link" href="#ugr.tools.ruta.ae.basic.parameter.dynamicAnchoring" title="dynamicAnchoring">dynamicAnchoring</a>
                  </td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">Option to allow rule matches to start at any rule element.</td><td style="border-bottom: 0.5pt solid black; ">Single Boolean</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">
                    <a class="link" href="#ugr.tools.ruta.ae.basic.parameter.lowMemoryProfile" title="lowMemoryProfile">lowMemoryProfile</a>
                  </td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">Option to decrease the memory consumption when processing a large CAS.</td><td style="border-bottom: 0.5pt solid black; ">Single Boolean</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">
                    <a class="link" href="#ugr.tools.ruta.ae.basic.parameter.simpleGreedyForComposed" title="simpleGreedyForComposed">simpleGreedyForComposed</a>
                  </td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">Option to activate a different inferencer for composed rule elements.</td><td style="border-bottom: 0.5pt solid black; ">Single Boolean</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">
                    <a class="link" href="#ugr.tools.ruta.ae.basic.parameter.debug" title="debug">debug</a>
                  </td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">Option to add debug information to the CAS.</td><td style="border-bottom: 0.5pt solid black; ">Single Boolean</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">
                    <a class="link" href="#ugr.tools.ruta.ae.basic.parameter.debugWithMatches" title="debugWithMatches">debugWithMatches</a>
                  </td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">Option to add information about the rule matches to the CAS.</td><td style="border-bottom: 0.5pt solid black; ">Single Boolean</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">
                    <a class="link" href="#ugr.tools.ruta.ae.basic.parameter.debugOnlyFor" title="debugOnlyFor">debugOnlyFor</a>
                  </td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">List of rule ids. If provided, then debug information is only created for
                    those rules.
                  </td><td style="border-bottom: 0.5pt solid black; ">Multi String</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">
                    <a class="link" href="#ugr.tools.ruta.ae.basic.parameter.profile" title="profile">profile</a>
                  </td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">Option to add profile information to the CAS.</td><td style="border-bottom: 0.5pt solid black; ">Single Boolean</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">
                    <a class="link" href="#ugr.tools.ruta.ae.basic.parameter.statistics" title="statistics">statistics</a>
                  </td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">Option to add statistics of conditions and actions to the CAS.</td><td style="border-bottom: 0.5pt solid black; ">Single Boolean</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">
                    <a class="link" href="#ugr.tools.ruta.ae.basic.parameter.createdBy" title="createdBy">createdBy</a>
                  </td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">Option to add additional information, which rule created an annotation.
                  </td><td style="border-bottom: 0.5pt solid black; ">Single Boolean</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">
                    <a class="link" href="#ugr.tools.ruta.ae.basic.parameter.varNames" title="varNames">varNames</a>
                  </td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">String array with names of variables. Is used in combination with varValues.
                  </td><td style="border-bottom: 0.5pt solid black; ">Multi String</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">
                    <a class="link" href="#ugr.tools.ruta.ae.basic.parameter.varValues" title="varValues">varValues</a>
                  </td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">String array with values of variables. Is used in combination with varNames.
                  </td><td style="border-bottom: 0.5pt solid black; ">Multi String</td></tr><tr><td style="border-right: 0.5pt solid black; ">
                    <a class="link" href="#ugr.tools.ruta.ae.basic.parameter.dictRemoveWS" title="dictRemoveWS">dictRemoveWS</a>
                  </td><td style="border-right: 0.5pt solid black; ">Remove whitespaces when loading dictionaries.
                  </td><td style="">Single Boolean</td></tr></tbody></table>
          </div></div><p><br class="table-break">
        </p>
        <div class="section" title="mainScript"><div class="titlepage"><div><div><h5 class="title" id="ugr.tools.ruta.ae.basic.parameter.mainScript">mainScript</h5></div></div></div>
          
          <p>
            This parameter specifies the rule file that will be executed by the analysis engine and is,
            therefore, one of the most important ones. The exact name of the script is given by the complete namespace of the file, which corresponds to its location
            relative to the given parameter <a class="link" href="#ugr.tools.ruta.ae.basic.parameter.scriptPaths" title="scriptPaths">scriptPaths</a>.
            The single names of packages (or folders) are separated by periods. An exemplary value for this parameter could be "org.apache.uima.Main", 
            whereas "Main" specifies the file containing the rules and "org.apache.uima" its package.
            In this case, the analysis engine loads the script file "Main.ruta", which is located in the folder structure "org/apache/uima/".
            This parameter has no default value and has to be provided, although it is not specified as mandatory.
          </p>
        </div>
        <div class="section" title="rules"><div class="titlepage"><div><div><h5 class="title" id="ugr.tools.ruta.ae.basic.parameter.rules">rules</h5></div></div></div>
          
          <p>
          A String parameter representing the rule that should be applied by the analysis engine.
          If set, it replaces the content of file specified by the <a class="link" href="#ugr.tools.ruta.ae.basic.parameter.mainScript" title="mainScript">mainScript</a> parameter.
          </p>
        </div>
        <div class="section" title="scriptEncoding"><div class="titlepage"><div><div><h5 class="title" id="ugr.tools.ruta.ae.basic.parameter.scriptEncoding">scriptEncoding</h5></div></div></div>
          
          <p>
            This parameter specifies the encoding of the rule files. Its default value is "UTF-8".
          </p>
        </div>
        <div class="section" title="scriptPaths"><div class="titlepage"><div><div><h5 class="title" id="ugr.tools.ruta.ae.basic.parameter.scriptPaths">scriptPaths</h5></div></div></div>
          
          <p>
            The parameter scriptPaths refers to a list of String values, which specify the possible locations of script files. 
            The given locations are absolute paths. A typical value for this parameter is, for example, "C:/Ruta/MyProject/script/".
            If the parameter <a class="link" href="#ugr.tools.ruta.ae.basic.parameter.mainScript" title="mainScript">mainScript</a> is set to org.apache.uima.Main, 
            then the absolute path of the script file has to be "C:/Ruta/MyProject/script/org/apache/uima/Main.ruta". 
            This parameter can contain multiple values, as the main script can refer to multiple projects similar to a class path in Java.
          </p>
        </div>
        <div class="section" title="descriptorPaths"><div class="titlepage"><div><div><h5 class="title" id="ugr.tools.ruta.ae.basic.parameter.descriptorPaths">descriptorPaths</h5></div></div></div>
          
          <p>
            This parameter specifies the possible locations for descriptors like analysis engines or type systems, similar to the parameter
            <a class="link" href="#ugr.tools.ruta.ae.basic.parameter.scriptPaths" title="scriptPaths">scriptPaths</a> for the script files. A typical value for this parameter 
            is for example "C:/Ruta/MyProject/descriptor/".
            The relative values of the parameter <a class="link" href="#ugr.tools.ruta.ae.basic.parameter.additionalEngines" title="additionalEngines">additionalEngines</a> are
            resolved to these absolute locations.
            This parameter can contain multiple values, as the main script can refer to multiple projects similar to a class path in Java.
          </p>
        </div>
        <div class="section" title="resourcePaths"><div class="titlepage"><div><div><h5 class="title" id="ugr.tools.ruta.ae.basic.parameter.resourcePaths">resourcePaths</h5></div></div></div>
          
          <p>
            This parameter specifies the possible locations of additional resources like word lists or CSV tables. The string values have to contain absolute
            locations, for example, "C:/Ruta/MyProject/resources/".
          </p>
        </div>
        <div class="section" title="additionalScripts"><div class="titlepage"><div><div><h5 class="title" id="ugr.tools.ruta.ae.basic.parameter.additionalScripts">additionalScripts</h5></div></div></div>
          
          <p>
            The parameter additionalScripts is defined as a list of string values and contains script files, which are additionally loaded by the analysis engine. These script files are specified by their 
            complete namespace, exactly like the value of the parameter <a class="link" href="#ugr.tools.ruta.ae.basic.parameter.mainScript" title="mainScript">mainScript</a> 
            and can be refered to by language elements, e.g., by executing the containing rules. An exemplary value of this parameter is "org.apache.uima.SecondaryScript". In this example, the main script could import 
            this script file by the declaration "SCRIPT org.apache.uima.SecondaryScript;" and then could execute it with the rule 
            "Document{-&gt; CALL(SecondaryScript)};". 
          </p>
        </div>
        <div class="section" title="additionalEngines"><div class="titlepage"><div><div><h5 class="title" id="ugr.tools.ruta.ae.basic.parameter.additionalEngines">additionalEngines</h5></div></div></div>
          
          <p>
            This parameter contains a list of additional analysis engines, which can be executed by the UIMA Ruta rules. The single values
            are given by the name of the analysis engine with their complete namespace and have to be located relative to one value of the parameter
            <a class="link" href="#ugr.tools.ruta.ae.basic.parameter.descriptorPaths" title="descriptorPaths">descriptorPaths</a>, the location where the analysis engine searches for the descriptor file.
            An example for one value of the parameter is "utils.HtmlAnnotator", which points to the descriptor "HtmlAnnotator.xml" in the folder "utils".
          </p>
        </div>
        <div class="section" title="additionalEngineLoaders"><div class="titlepage"><div><div><h5 class="title" id="ugr.tools.ruta.ae.basic.parameter.additionalEngineLoaders">additionalEngineLoaders</h5></div></div></div>
          
          <p>
            The parameter "additionalEngineLoaders" specifies a list of optional implementations of the interface 
            "org.apache.uima.ruta.extensions.IEngineLoader", which can be used to application-specific configurations of
            additional analysis engines.
          </p>
        </div>
        <div class="section" title="additionalUimafitEngines"><div class="titlepage"><div><div><h5 class="title" id="ugr.tools.ruta.ae.basic.parameter.additionalUimafitEngines">additionalUimafitEngines</h5></div></div></div>
          
          <p>
            This parameter contains a list of additional analysis engines, which can be executed by the UIMA Ruta rules. The single values
            are given by the name of the implementation with the complete namespace and have to be present int he classpath of the application.
            An example for one value of the parameter is "org.apache.uima.ruta.engine.HtmlAnnotator", which points to the "HtmlAnnotator" class.
          </p>
        </div>
        <div class="section" title="additionalExtensions"><div class="titlepage"><div><div><h5 class="title" id="ugr.tools.ruta.ae.basic.parameter.additionalExtensions">additionalExtensions</h5></div></div></div>
          
          <p>
            This parameter specifies optional extensions of the UIMA Ruta language. The elements of the string list have to implement the interface 
            "org.apache.uima.ruta.extensions.IRutaExtension". With these extensions, application-specific conditions and actions can be
            added to the set of provided ones.
          </p>
        </div>
        <div class="section" title="reloadScript"><div class="titlepage"><div><div><h5 class="title" id="ugr.tools.ruta.ae.basic.parameter.reloadScript">reloadScript</h5></div></div></div>
          
          <p>
            This boolean parameter indicates whether the script or resource files should be reloaded when processing a CAS. The default value is set to false. 
            In this case, the script files are loaded when the analysis engine is initialized. If script files or resource files are extended, e.g., a dictionary is filled
            yet when a collection of documents are processed, then the parameter is needed to be set to true in order to include the changes.
          </p>
        </div>
        <div class="section" title="seeders"><div class="titlepage"><div><div><h5 class="title" id="ugr.tools.ruta.ae.basic.parameter.seeders">seeders</h5></div></div></div>
          
          <p>
            This list of string values refers to implementations of the interface "org.apache.uima.ruta.seed.RutaAnnotationSeeder", 
            which can be used to automatically add annotations to the CAS. The default value of the parameter is a single seeder, namely "org.apache.uima.ruta.seed.DefaultSeeder"
            that adds annotations for token classes like CW, MARKUP or SEMICOLON. Remember that additional annotations can also be added with 
            an additional engine that is executed by a UIMA Ruta rule.
          </p>
        </div>
        <div class="section" title="defaultFilteredTypes"><div class="titlepage"><div><div><h5 class="title" id="ugr.tools.ruta.ae.basic.parameter.defaultFilteredTypes">defaultFilteredTypes</h5></div></div></div>
          
          <p>
            This parameter specifies a list of types, which are filtered by default when executing a script file. Using the default values of this parameter,
            whitespaces, line breaks and markup elements are not visible to Ruta rules. The visibility of annotations and, therefore, the covered text can be changed
            using the actions <a class="link" href="#ugr.tools.ruta.language.actions.filtertype" title="2.8.14.&nbsp;FILTERTYPE">FILTERTYPE</a> and 
            <a class="link" href="#ugr.tools.ruta.language.actions.retaintype" title="2.8.35.&nbsp;RETAINTYPE">RETAINTYPE</a>.
          </p>
        </div>
        <div class="section" title="removeBasics"><div class="titlepage"><div><div><h5 class="title" id="ugr.tools.ruta.ae.basic.parameter.removeBasics">removeBasics</h5></div></div></div>
          
          <p>
            This parameter specifies whether the inference annotations created by the analysis engine should be removed after processing the CAS.
            The default value is set to true.
          </p>
        </div>
        <div class="section" title="reindexOnly"><div class="titlepage"><div><div><h5 class="title" id="ugr.tools.ruta.ae.basic.parameter.reindexOnly">reindexOnly</h5></div></div></div>
          
          <p>
            This parameter specifies the annotation types which should be reindex for ruta's internal annotations
            All annotation types that changed since the last call of a ruta script need to be listed here. 
            The value of this parameter needs only be adapted for performance optimization in pipelines that 
            contains several ruta analysis engines.
            Default value is uima.tcas.Annotation
          </p>
        </div>
        <div class="section" title="strictImports"><div class="titlepage"><div><div><h5 class="title" id="ugr.tools.ruta.ae.basic.parameter.strictImports">strictImports</h5></div></div></div>
          
          <p>
            This parameter specifies whether short type names should be resolved against the typesystems declared in the script (true) or at runtime in the CAS typesystem (false).
            The default value is set to false.
          </p>
        </div>
        <div class="section" title="dynamicAnchoring"><div class="titlepage"><div><div><h5 class="title" id="ugr.tools.ruta.ae.basic.parameter.dynamicAnchoring">dynamicAnchoring</h5></div></div></div>
          
          <p>
            If this parameter is set to true, then the Ruta rules are not forced to start to match with the first rule element. 
            Rather, the rule element referring to the most rare type is chosen. This option can be utilized to optimize the performance.
            Please mind that the matching result can vary in some cases when greedy rule elements are applied.
            The default value is set to false.
          </p>
        </div>
        <div class="section" title="lowMemoryProfile"><div class="titlepage"><div><div><h5 class="title" id="ugr.tools.ruta.ae.basic.parameter.lowMemoryProfile">lowMemoryProfile</h5></div></div></div>
          
          <p>
            This parameter specifies whether the memory consumption should be reduced. This parameter should be set to true for 
            very large CAS documents (e.g., &gt; 500k tokens), but it also reduces the performance. The default value is set to false.
          </p>
        </div>
        <div class="section" title="simpleGreedyForComposed"><div class="titlepage"><div><div><h5 class="title" id="ugr.tools.ruta.ae.basic.parameter.simpleGreedyForComposed">simpleGreedyForComposed</h5></div></div></div>
          
          <p>
            This parameter specifies whether a different inference strategy for composed rule elements should be applied. This option is only necessary 
            when the composed rule element is expected to match very often, e.g., a rule element like (ANY ANY)+.
            The default value of this parameter is set to false.
          </p>
        </div>
        <div class="section" title="debug"><div class="titlepage"><div><div><h5 class="title" id="ugr.tools.ruta.ae.basic.parameter.debug">debug</h5></div></div></div>
          
          <p>
            If this parameter is set to true, then additional information about the execution of a rule script is added to the CAS.
            The actual information is specified by the following parameters.
            The default value of this parameter is set to false.
          </p>
        </div>
        <div class="section" title="debugWithMatches"><div class="titlepage"><div><div><h5 class="title" id="ugr.tools.ruta.ae.basic.parameter.debugWithMatches">debugWithMatches</h5></div></div></div>
          
          <p>
            This parameter specifies whether the match information (covered text) of the rules should be stored in the CAS.
            The default value of this parameter is set to false.
          </p>
        </div>
        <div class="section" title="debugOnlyFor"><div class="titlepage"><div><div><h5 class="title" id="ugr.tools.ruta.ae.basic.parameter.debugOnlyFor">debugOnlyFor</h5></div></div></div>
          
          <p>
            This parameter specifies a list of rule-ids that enumerate the rule for which debug information should be created. 
            No specific ids are given by default.
          </p>
        </div>
        <div class="section" title="profile"><div class="titlepage"><div><div><h5 class="title" id="ugr.tools.ruta.ae.basic.parameter.profile">profile</h5></div></div></div>
          
          <p>
            If this parameter is set to true, then additional information about the runtime of applied rules is added to the CAS.
            The default value of this parameter is set to false.
          </p>
        </div>
        <div class="section" title="statistics"><div class="titlepage"><div><div><h5 class="title" id="ugr.tools.ruta.ae.basic.parameter.statistics">statistics</h5></div></div></div>
          
          <p>
            If this parameter is set to true, then additional information about the runtime of UIMA Ruta language elements like conditions and actions
            is added to the CAS.
            The default value of this parameter is set to false.
          </p>
        </div>
        <div class="section" title="createdBy"><div class="titlepage"><div><div><h5 class="title" id="ugr.tools.ruta.ae.basic.parameter.createdBy">createdBy</h5></div></div></div>
          
          <p>
            If this parameter is set to true, then additional information about what annotation was created by which rule is added to the CAS.
            The default value of this parameter is set to false.
          </p>
        </div>
        <div class="section" title="varNames"><div class="titlepage"><div><div><h5 class="title" id="ugr.tools.ruta.ae.basic.parameter.varNames">varNames</h5></div></div></div>
          
          <p>
            This parameter specifies the names of variables and is used in combination with the parameter
            varValues, which contains the values of the corresponding variables. The n-th entry of this
            string array specifies the variable of the n-th entry of the string array of the parameter
            varValues. If the variables is defined in the root of a script, then the name of the variable
            suffices. If the variable is defined in a BLOCK or imported script, then the the name must
            contain the namespaces of the blocks as a prefix, e.g., InnerBlock.varName or OtherScript.SomeBlock.varName.
          </p>
        </div>
        <div class="section" title="varValues"><div class="titlepage"><div><div><h5 class="title" id="ugr.tools.ruta.ae.basic.parameter.varValues">varValues</h5></div></div></div>
          
          <p>
            This parameter specifies the values of variables as string values in an string array. It is
            used in combination with the parameter varNames, which contains the names of the corresponding
            variables. The n-th entry of this string array specifies the value of the n-th entry of the
            string array of the parameter varNames. Only value of the kinds string, boolean, int, double
            and float are allowed.
          </p>
        </div>
        <div class="section" title="dictRemoveWS"><div class="titlepage"><div><div><h5 class="title" id="ugr.tools.ruta.ae.basic.parameter.dictRemoveWS">dictRemoveWS</h5></div></div></div>
          
          <p>
            If this parameter is set to true, then whitespaces are removed when dictionaries are loaded.
          </p>
        </div>
      </div>
    </div>
    <div class="section" title="1.5.2.&nbsp;Annotation Writer"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.ae.annotationwriter">1.5.2.&nbsp;Annotation Writer</h3></div></div></div>
      
      <p>
        This Analysis Engine can be utilized to write the covered text of annotations in a text file, whereas each covered text is put into a new line.
        If the Analyis engine, for example, is configured for the type <span class="quote">&#8220;<span class="quote">uima.example.Person</span>&#8221;</span>, then all covered texts of all Person annotations are stored
        in a text file, one person in each line.
        A descriptor file for this Analysis Engine is located in the folder <span class="quote">&#8220;<span class="quote">descriptor/utils</span>&#8221;</span> of a UIMA Ruta project.
      </p>
      <div class="section" title="1.5.2.1.&nbsp;Configuration Parameters"><div class="titlepage"><div><div><h4 class="title" id="ugr.tools.ruta.ae.annotationwriter.parameter">1.5.2.1.&nbsp;Configuration Parameters</h4></div></div></div>
        
        <p>
        </p>
        <div class="section" title="Output"><div class="titlepage"><div><div><h5 class="title" id="ugr.tools.ruta.ae.annotationwriter.parameter.output">Output</h5></div></div></div>
          
          <p>
            This string parameter specifies the absolute path of the resulting file named <span class="quote">&#8220;<span class="quote">output.txt</span>&#8221;</span>. However, if an annotation of the 
            type <span class="quote">&#8220;<span class="quote">org.apache.uima.examples.SourceDocumentInformation</span>&#8221;</span> is given, then the value of this parameter is interpreted to be relative
            to the URI stored in the annotation and the name of the file will be adapted to the name of the source file. If this functionality is activated in the preferences, 
            then the UIMA Ruta Workbench adds
            the SourceDocumentInformation annotation when the user launches a script file.
             The default value of this parameter is <span class="quote">&#8220;<span class="quote">/../output/</span>&#8221;</span>.
          </p>
        </div>
        <div class="section" title="Encoding"><div class="titlepage"><div><div><h5 class="title" id="ugr.tools.ruta.ae.annotationwriter.parameter.encoding">Encoding</h5></div></div></div>
          
          <p>
           This string parameter specifies the encoding of the resulting file. The default value of this parameter is <span class="quote">&#8220;<span class="quote">UTF-8</span>&#8221;</span>.
          </p>
        </div>
        <div class="section" title="Type"><div class="titlepage"><div><div><h5 class="title" id="ugr.tools.ruta.ae.annotationwriter.parameter.type">Type</h5></div></div></div>
          
          <p>
            Only the covered texts of annotations of the type specified with this parameter are stored in the resulting file.
            The default value of this parameter is <span class="quote">&#8220;<span class="quote">uima.tcas.DocumentAnnotation</span>&#8221;</span>, which will store the complete document in a new file.
          </p>
        </div>
      </div>
    </div>
    <div class="section" title="1.5.3.&nbsp;Plain Text Annotator"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.ae.plaintext">1.5.3.&nbsp;Plain Text Annotator</h3></div></div></div>
      
      <p>
        This Analysis Engines adds annotations for lines and paragraphs.
        A descriptor file for this Analysis Engine is located in the folder <span class="quote">&#8220;<span class="quote">descriptor/utils</span>&#8221;</span> of a UIMA Ruta project. There are no configuration parameters.
      </p>
    </div>
    <div class="section" title="1.5.4.&nbsp;Modifier"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.ae.modifier">1.5.4.&nbsp;Modifier</h3></div></div></div>
      
      <p>
        The Modifier Analysis Engine can be used to create an additional view, which contains all textual modifications and HTML highlightings that
        were specified by the executed rules. This Analysis Engine can be applied, e.g., 
        for anonymization where all annotations of persons are replaced by the string <span class="quote">&#8220;<span class="quote">Person</span>&#8221;</span>. 
        Furthermore, the content of the new view can optionally be stored in a new HTML file.
        A descriptor file for this Analysis Engine is located in the folder <span class="quote">&#8220;<span class="quote">descriptor/utils</span>&#8221;</span> of a UIMA Ruta project.
      </p>
      <div class="section" title="1.5.4.1.&nbsp;Configuration Parameters"><div class="titlepage"><div><div><h4 class="title" id="ugr.tools.ruta.ae.modifier.parameter">1.5.4.1.&nbsp;Configuration Parameters</h4></div></div></div>
        
        <p>
        </p>
        <div class="section" title="styleMap"><div class="titlepage"><div><div><h5 class="title" id="ugr.tools.ruta.ae.modifier.parameter.styleMap">styleMap</h5></div></div></div>
          
          <p>
            This string parameter specifies the name of the style map file created by the Style Map Creator Analysis Engine, which stores the colors for
            additional highlightings in the modified view.
          </p>
        </div>
        <div class="section" title="descriptorPaths"><div class="titlepage"><div><div><h5 class="title" id="ugr.tools.ruta.ae.modifier.parameter.descriptorPaths">descriptorPaths</h5></div></div></div>
          
          <p>
            This parameter can contain multiple string values and specifies the absolute paths where the style map file can be found.
          </p>
        </div>
        <div class="section" title="outputLocation"><div class="titlepage"><div><div><h5 class="title" id="ugr.tools.ruta.ae.modifier.parameter.outputLocation">outputLocation</h5></div></div></div>
          
          <p>
            This optional string parameter specifies the absolute path of the resulting file named <span class="quote">&#8220;<span class="quote">output.modified.html</span>&#8221;</span>. However, if an annotation of the 
            type <span class="quote">&#8220;<span class="quote">org.apache.uima.examples.SourceDocumentInformation</span>&#8221;</span> is given, then the value of this parameter is interpreted to be relative
            to the URI stored in the annotation and the name of the file will be adapted to the name of the source file. If this functionality is activated in the preferences, 
            then the UIMA Ruta Workbench adds
            the SourceDocumentInformation annotation when the user launches a script file.
            The default value of this parameter is empty. 
            In this case no additional html file will be created.
          </p>
        </div>
        <div class="section" title="outputView"><div class="titlepage"><div><div><h5 class="title" id="ugr.tools.ruta.ae.modifier.parameter.outputView">outputView</h5></div></div></div>
          
          <p>
            This string parameter specifies the name of the view, which will contain the modified document. A view of this name must not yet exist.
            The default value of this parameter is <span class="quote">&#8220;<span class="quote">modified</span>&#8221;</span>.
          </p>
        </div>
      </div>
    </div>
    <div class="section" title="1.5.5.&nbsp;HTML Annotator"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.ae.html">1.5.5.&nbsp;HTML Annotator</h3></div></div></div>
      
      <p>
        This Analysis Engine provides support for HTML files by adding annotations for the HTML elements. Using the default values, the HTML Annotator creates annotations
        for each HTML element spanning the content of the element, whereas the most common elements are represented by own types. 
        The document <span class="quote">&#8220;<span class="quote">This text is &lt;b&gt;bold&lt;/b&gt;.</span>&#8221;</span>, for example, would be annotated with an annotation of the type 
        <span class="quote">&#8220;<span class="quote">org.apache.uima.ruta.type.html.B</span>&#8221;</span> for the word <span class="quote">&#8220;<span class="quote">bold</span>&#8221;</span>. The HTML annotator can be configured 
        in order to include the start and end elements in the created annotations. 
        A descriptor file for this Analysis Engine is located in the folder <span class="quote">&#8220;<span class="quote">descriptor/utils</span>&#8221;</span> of a UIMA Ruta project.
      </p>
      <div class="section" title="1.5.5.1.&nbsp;Configuration Parameters"><div class="titlepage"><div><div><h4 class="title" id="ugr.tools.ruta.ae.html.parameter">1.5.5.1.&nbsp;Configuration Parameters</h4></div></div></div>
        
        <p>
        </p>
        <div class="section" title="onlyContent"><div class="titlepage"><div><div><h5 class="title" id="ugr.tools.ruta.ae.html.parameter.onlyContent">onlyContent</h5></div></div></div>
          
          <p>
            This parameter specifies whether created annotations should cover only the content of the HTML elements or also their start and end elements. 
            The default value is <span class="quote">&#8220;<span class="quote">true</span>&#8221;</span>.
          </p>
        </div>
      </div>
    </div>
    <div class="section" title="1.5.6.&nbsp;HTML Converter"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.ae.htmlconverter">1.5.6.&nbsp;HTML Converter</h3></div></div></div>
      
      <p>
        This Analysis Engine is able to convert html content from a source view into a plain string representation stored in an output view. 
        Especially, the Analysis Engine transfers annotations under consideration of the changed document text and annotation offsets in the new view. 
        The copy process also sets features, however, features of type annotation are currently not supported. 
        Note that if an annotation would have the same start and end positions in the new view, i.e., 
        if it would be mapped to an annotation of length 0, it is not moved to the new view.
        
        The HTML Converter also supports heuristic and explicit conversion patterns which default to html4 decoding, 
        e.g., "&amp;nbsp;", "&amp;lt;", etc. Concepts like tables or lists are not supported.
        
        Note that in general it is suggested to run an html cleaner before any further processing to avoid problems with malformed html. 
        
        A descriptor file for this Analysis Engine is located in the folder <span class="quote">&#8220;<span class="quote">descriptor/utils</span>&#8221;</span> of a UIMA Ruta project.
      </p>
      <div class="section" title="1.5.6.1.&nbsp;Configuration Parameters"><div class="titlepage"><div><div><h4 class="title" id="ugr.tools.ruta.ae.htmlconverter.parameter">1.5.6.1.&nbsp;Configuration Parameters</h4></div></div></div>
        
        <p>
        </p>
        <div class="section" title="outputView"><div class="titlepage"><div><div><h5 class="title" id="ugr.tools.ruta.ae.htmlconverter.parameter.outputView">outputView</h5></div></div></div>
          
          <p>
            This string parameter specifies the name of the new view. 
            The default value is <span class="quote">&#8220;<span class="quote">plaintext</span>&#8221;</span>.
          </p>
        </div>
        <div class="section" title="inputView"><div class="titlepage"><div><div><h5 class="title" id="ugr.tools.ruta.ae.htmlconverter.parameter.inputView">inputView</h5></div></div></div>
          
          <p>
            This string parameter can optionally be set to specify the name of the input view.
          </p>
        </div>
        <div class="section" title="newlineInducingTags"><div class="titlepage"><div><div><h5 class="title" id="ugr.tools.ruta.ae.htmlconverter.parameter.newlineInducingTags">newlineInducingTags</h5></div></div></div>
          
          <p>
            This string array parameter sets the names of the html tags that create linebreaks in the output view.
            The default is <span class="quote">&#8220;<span class="quote">br, p, div, ul, ol, dl, li, h1, ..., h6, blockquote</span>&#8221;</span>.
          </p>
        </div>
        <div class="section" title="replaceLinebreaks"><div class="titlepage"><div><div><h5 class="title" id="ugr.tools.ruta.ae.htmlconverter.parameter.replaceLinebreaks">replaceLinebreaks</h5></div></div></div>
          
          <p>
            This boolean parameter determines if linebreaks inside the text nodes are kept or removed.
            The default behavior is <span class="quote">&#8220;<span class="quote">true</span>&#8221;</span>.
          </p>
        </div>
        <div class="section" title="replaceLinebreaks"><div class="titlepage"><div><div><h5 class="title" id="ugr.tools.ruta.ae.htmlconverter.parameter.linebreakReplacement">replaceLinebreaks</h5></div></div></div>
          
          <p>
            This string parameter determines the character sequence that replaces a linebreak.
            The default behavior is the empty string.
          </p>
        </div>
        <div class="section" title="conversionPolicy"><div class="titlepage"><div><div><h5 class="title" id="ugr.tools.ruta.ae.htmlconverter.parameter.conversionPolicy">conversionPolicy</h5></div></div></div>
          
          <p>
            This string parameter determines the conversion policy used, either "heuristic", "explicit", or "none". 
            When the value is "explicit", the parameters <span class="quote">&#8220;<span class="quote">conversionPatterns</span>&#8221;</span> and optionally <span class="quote">&#8220;<span class="quote">conversionReplacements</span>&#8221;</span> are considered.
            The "heuristic" conversion policy uses simple regular expressions to decode html4 entities such as "&amp;nbsp;".
            The default behavior is "heuristic".
          </p>
        </div>
        <div class="section" title="conversionPatterns"><div class="titlepage"><div><div><h5 class="title" id="ugr.tools.ruta.ae.htmlconverter.parameter.conversionPatterns">conversionPatterns</h5></div></div></div>
          
          <p>
            This string array parameter can be used to apply custom conversions.
            It defaults to a list of commonly used codes, e.g., &amp;nbsp;, 
            which are converted using html 4 entity unescaping. 
            However, explicit conversion strings can also be passed via the parameter <span class="quote">&#8220;<span class="quote">conversionReplacements</span>&#8221;</span>.
            Remember to enable explicit conversion via <span class="quote">&#8220;<span class="quote">conversionPolicy</span>&#8221;</span> first.
          </p>
        </div>
        <div class="section" title="conversionReplacements"><div class="titlepage"><div><div><h5 class="title" id="ugr.tools.ruta.ae.htmlconverter.parameter.conversionReplacements">conversionReplacements</h5></div></div></div>
          
          <p>
            This string array parameter corresponds to <span class="quote">&#8220;<span class="quote">conversionPatterns</span>&#8221;</span> 
            such that <span class="quote">&#8220;<span class="quote">conversionPatterns[i]</span>&#8221;</span> will be replaced by <span class="quote">&#8220;<span class="quote">conversionReplacements[i]</span>&#8221;</span>; 
            replacements should be shorter than the source pattern.
            Per default, the replacement strings are computed using Html4 decoding.
            Remember to enable explicit conversion via <span class="quote">&#8220;<span class="quote">conversionPolicy</span>&#8221;</span> first.
          </p>
        </div>
        <div class="section" title="skipWhitespaces"><div class="titlepage"><div><div><h5 class="title" id="ugr.tools.ruta.ae.htmlconverter.parameter.skipWhitespaces">skipWhitespaces</h5></div></div></div>
          
          <p>
            This boolean parameter determines if the converter should skip whitespaces. 
            Html documents often contains whitespaces for indentation and formatting, 
            which should not be reproduced in the converted plain text document.
            If the parameter is set to false, then the whitespces are not removed. 
            This behavior is useful, if not Html documents are converted, but XMl files.
            The default value is true.
          </p>
        </div>
        <div class="section" title="processAll"><div class="titlepage"><div><div><h5 class="title" id="ugr.tools.ruta.ae.htmlconverter.parameter.processAll">processAll</h5></div></div></div>
          
          <p>
            If this boolean parameter is set to true, then the tags of the complete document is processed
            and not only those within the body tag.
          </p>
        </div>
        <div class="section" title="newlineInducingTagRegExp"><div class="titlepage"><div><div><h5 class="title" id="ugr.tools.ruta.ae.htmlconverter.parameter.newlineInducingTagRegExp">newlineInducingTagRegExp</h5></div></div></div>
          
          <p>
            This string parameter contains a regular expression for HTML/XML elements. If the pattern
    matches, then the element will introduce a new line break similar to the element of the
    parameter <span class="quote">&#8220;<span class="quote">newlineInducingTags</span>&#8221;</span>.
          </p>
        </div>
        <div class="section" title="gapInducingTags"><div class="titlepage"><div><div><h5 class="title" id="ugr.tools.ruta.ae.htmlconverter.parameter.gapInducingTags">gapInducingTags</h5></div></div></div>
          
          <p>
            This string array parameter sets the names of the html tags that create additional text in the
   output view. The acutal string of the gap is defined by the parameter <span class="quote">&#8220;<span class="quote">gapText</span>&#8221;</span>.
          </p>
        </div>
        <div class="section" title="gapText"><div class="titlepage"><div><div><h5 class="title" id="ugr.tools.ruta.ae.htmlconverter.parameter.gapText">gapText</h5></div></div></div>
          
          <p>
           This string parameter determines the character sequence that is introduced by the html tags
    specified in the <span class="quote">&#8220;<span class="quote">gapInducingTags</span>&#8221;</span>.
          </p>
        </div>
        <div class="section" title="useSpaceGap"><div class="titlepage"><div><div><h5 class="title" id="ugr.tools.ruta.ae.htmlconverter.parameter.useSpaceGap">useSpaceGap</h5></div></div></div>
          
          <p>
          This boolean parameter sets the value of the parameter <span class="quote">&#8220;<span class="quote">gapText</span>&#8221;</span> to a single space..
          </p>
        </div>
      </div>
    </div><div class="section" title="1.5.7.&nbsp;Style Map Creator"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.ae.stylemap">1.5.7.&nbsp;Style Map Creator</h3></div></div></div>
      
      <p>
        This Analysis Engine can be utilized to create style map information, which is needed by the Modifier Analysis Engine in order to create
        highlightings for some annotations.
        Style map information can be created using the <a class="link" href="#ugr.tools.ruta.language.actions.color" title="2.8.7.&nbsp;COLOR">COLOR</a> action.
        A descriptor file for this Analysis Engine is located in the folder <span class="quote">&#8220;<span class="quote">descriptor/utils</span>&#8221;</span> of a UIMA Ruta project.
      </p>
      <div class="section" title="1.5.7.1.&nbsp;Configuration Parameters"><div class="titlepage"><div><div><h4 class="title" id="ugr.tools.ruta.ae.stylemap.parameter">1.5.7.1.&nbsp;Configuration Parameters</h4></div></div></div>
        
        <p>
        </p>
        <div class="section" title="styleMap"><div class="titlepage"><div><div><h5 class="title" id="ugr.tools.ruta.ae.stylemap.parameter.styleMap">styleMap</h5></div></div></div>
          
          <p>
            This string parameter specifies the name of the style map file created by the Style Map Creator Analysis Engine, which stores the colors for
            additional highlightings in the modified view.
          </p>
        </div>
        <div class="section" title="descriptorPaths"><div class="titlepage"><div><div><h5 class="title" id="ugr.tools.ruta.ae.stylemap.parameter.descriptorPaths">descriptorPaths</h5></div></div></div>
          
          <p>
            This parameter can contain multiple string values and specifies the absolute paths where the style map can be found.
          </p>
        </div>
      </div>
    </div>
    <div class="section" title="1.5.8.&nbsp;Cutter"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.ae.cutter">1.5.8.&nbsp;Cutter</h3></div></div></div>
      
      <p>
        This Analysis Engine is able to cut the document of the CAS. Only the text covered by annotations of the specified type will be retained and all other parts of the documents will be removed.
        The offsets of annotations in the index will be updated, but not feature structures nested as feature values.
      </p>
      <div class="section" title="1.5.8.1.&nbsp;Configuration Parameters"><div class="titlepage"><div><div><h4 class="title" id="ugr.tools.ruta.ae.cutter.parameter">1.5.8.1.&nbsp;Configuration Parameters</h4></div></div></div>
        
        <p>
        </p>
        <div class="section" title="keep"><div class="titlepage"><div><div><h5 class="title" id="ugr.tools.ruta.ae.cutter.parameter.keep">keep</h5></div></div></div>
          
          <p>
            This string parameter specifies the complete name of a type. Only the text covered by annotations of this type will be retained and all other parts of the documents will be removed.
          </p>
        </div>
        <div class="section" title="inputView"><div class="titlepage"><div><div><h5 class="title" id="ugr.tools.ruta.ae.cutter.parameter.inputView">inputView</h5></div></div></div>
          
          <p>
            The name of the view that should be processed.
          </p>
        </div>
        <div class="section" title="outputView"><div class="titlepage"><div><div><h5 class="title" id="ugr.tools.ruta.ae.cutter.parameter.outputView">outputView</h5></div></div></div>
          
          <p>
            The name of the view, which will contain the modified CAS. 
          </p>
        </div>
      </div>
    </div>
    <div class="section" title="1.5.9.&nbsp;View Writer"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.ae.view">1.5.9.&nbsp;View Writer</h3></div></div></div>
      
      <p>
        This Analysis Engine is able to serialize the processed CAS to an XMI file whereas the the source and destination view can be specified 
        A descriptor file for this Analysis Engine is located in the folder <span class="quote">&#8220;<span class="quote">descriptor/utils</span>&#8221;</span> of a UIMA Ruta project.
      </p>
      <div class="section" title="1.5.9.1.&nbsp;Configuration Parameters"><div class="titlepage"><div><div><h4 class="title" id="ugr.tools.ruta.ae.view.parameter">1.5.9.1.&nbsp;Configuration Parameters</h4></div></div></div>
        
        <p>
        </p>
        <div class="section" title="output"><div class="titlepage"><div><div><h5 class="title" id="ugr.tools.ruta.ae.view.parameter.output">output</h5></div></div></div>
          
          <p>
            This string parameter specifies the absolute path of the resulting file named <span class="quote">&#8220;<span class="quote">output.xmi</span>&#8221;</span>. However, if an annotation of the 
            type <span class="quote">&#8220;<span class="quote">org.apache.uima.examples.SourceDocumentInformation</span>&#8221;</span> is given, then the value of this parameter is interpreted to be relative
            to the URI stored in the annotation and the name of the file will be adapted to the name of the source file. If this functionality is activated in the preferences, 
            then the UIMA Ruta Workbench adds
            the SourceDocumentInformation annotation when the user launches a script file.
          </p>
        </div>
        <div class="section" title="inputView"><div class="titlepage"><div><div><h5 class="title" id="ugr.tools.ruta.ae.view.parameter.inputView">inputView</h5></div></div></div>
          
          <p>
            The name of the view that should be stored in a file.
          </p>
        </div>
        <div class="section" title="outputView"><div class="titlepage"><div><div><h5 class="title" id="ugr.tools.ruta.ae.view.parameter.outputView">outputView</h5></div></div></div>
          
          <p>
            The name, which should be used, to store the view in the file. 
          </p>
        </div>
      </div>
    </div>
    <div class="section" title="1.5.10.&nbsp;XMI Writer"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.ae.xmi">1.5.10.&nbsp;XMI Writer</h3></div></div></div>
      
      <p>
        This Analysis Engine is able to serialize the processed CAS to an XMI file. One use case for the XMI Writer is, for example, a rule-based sort,
        which stores the processed XMI files in different folder, dependent on the execution of the rules, e.g., whether a pattern of annotations occurs or not.
        A descriptor file for this Analysis Engine is located in the folder <span class="quote">&#8220;<span class="quote">descriptor/utils</span>&#8221;</span> of a UIMA Ruta project.
      </p>
      <div class="section" title="1.5.10.1.&nbsp;Configuration Parameters"><div class="titlepage"><div><div><h4 class="title" id="ugr.tools.ruta.ae.xmi.parameter">1.5.10.1.&nbsp;Configuration Parameters</h4></div></div></div>
        
        <p>
        </p>
        <div class="section" title="Output"><div class="titlepage"><div><div><h5 class="title" id="ugr.tools.ruta.ae.xmi.parameter.output">Output</h5></div></div></div>
          
          <p>
            This string parameter specifies the absolute path of the resulting file named <span class="quote">&#8220;<span class="quote">output.xmi</span>&#8221;</span>. However, if an annotation of the 
            type <span class="quote">&#8220;<span class="quote">org.apache.uima.examples.SourceDocumentInformation</span>&#8221;</span> is given, then the value of this parameter is interpreted to be relative
            to the URI stored in the annotation and the name of the file will be adapted to the name of the source file. If this functionality is activated in the preferences, 
            then the UIMA Ruta Workbench adds
            the SourceDocumentInformation annotation when the user launches a script file.
            The default value is <span class="quote">&#8220;<span class="quote">/../output/</span>&#8221;</span>
          </p>
        </div>
      </div>
    </div>
    
  </div>
</div>
  
  <div class="chapter" title="Chapter&nbsp;2.&nbsp;Apache UIMA Ruta Language" id="ugr.tools.ruta.language.language"><div class="titlepage"><div><div><h2 class="title">Chapter&nbsp;2.&nbsp;Apache UIMA Ruta Language</h2></div></div></div>
  
  <p>
    This chapter provides a complete description of the Apache UIMA Ruta
    language.
  </p>

  <div class="section" title="2.1.&nbsp;Syntax"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.tools.ruta.language.syntax">2.1.&nbsp;Syntax</h2></div></div></div>
  
  <p>
    UIMA Ruta defines its own language for writing rules and rule
    scripts. This section gives a formal overview of its syntax.
  </p>
  <p>
    Structure: The overall structure of a UIMA Ruta
    script is defined by
    the following syntax.
    </p><pre class="programlisting">Script              -&gt; PackageDeclaration? GlobalStatements Statements
PackageDeclaration  -&gt; "PACKAGE" DottedIdentifier ";"
GlobalStatments     -&gt; GlobalStatement*   
GlobalStatment      -&gt; ("SCRIPT" | "ENGINE") 
                       DottedIdentifier2 ";"
                       | UimafitImport | ImportStatement
UimafitImport       -&gt; "UIMAFIT" DottedIdentifier2 
                      ("(" DottedIdentifier2 
                      (COMMA DottedIdentifier2)+ ")")?;    
Statements          -&gt; Statement*
Statement           -&gt; Declaration | VariableDeclaration 
                        | BlockDeclaration | SimpleStatement ";"</pre><p>
    Comments are excluded from the syntax definition. Comments start with
    "//" and always go to the end of the line.
  </p>
  <p>
    Syntax of import statements:
   
    </p><pre class="programlisting">ImportStatement  -&gt; (ImportType | ImportPackage | ImportTypeSystem) ";"
ImportType       -&gt; "IMPORT" Type ("FROM" Typesystem)? 
                    ("AS" Alias)?
ImportPackage    -&gt; "IMPORT" "PAKAGE" Package ("FROM" Typesystem)? 
                    ("AS" Alias)?
ImportTypeSystem -&gt; "IMPORT" "PACKAGE" "*" "FROM" TypeSystem ("AS" Alias)?
                    | "IMPORT" "*" "FROM" Typesystem
                    | "TYPESYSTEM" Typesystem
Type             -&gt; DottedIdentifier
Package          -&gt; DottedIdentifier
TypeSystem       -&gt; DottedIdentifier2
Alias            -&gt; Identifier</pre><p>

    Example beginning of a UIMA Ruta file:
    </p><pre class="programlisting">PACKAGE uima.ruta.example;

// import the types of this type system 
// (located in the descriptor folder -&gt; types folder)
IMPORT * FROM types.BibtexTypeSystem;

SCRIPT uima.ruta.example.Author;
SCRIPT uima.ruta.example.Title;
SCRIPT uima.ruta.example.Year;
</pre><p>

    Syntax of declarations:
    </p><pre class="programlisting">Declaration -&gt; "DECLARE" (AnnotationType)? Identifier ("," Identifier )*
               | "DECLARE" AnnotationType? Identifier ( "("
               FeatureDeclaration ")" )?
FeatureDeclaration  -&gt; ( (AnnotationType | "STRING" | "INT" | "FLOAT"
                       "DOUBLE" | "BOOLEAN") Identifier) )+
VariableDeclaration -&gt; (("TYPE" Identifier ("," Identifier)*
                                                   ("=" AnnotationType)?)
                     | ("STRING" Identifier ("," Identifier)*
                                                 ("=" StringExpression)?)
                     | (("INT" | "DOUBLE" | "FLOAT") Identifier
                               ("," Identifier)* ("=" NumberExpression)?)
                     | ("BOOLEAN" Identifier ("," Identifier)*
                                                ("=" BooleanExpression)?)
                     | ("ANNOTATION" Identifier ("=" AnnotationExpression)?)
                     | ("WORDLIST" Identifier ("=" WordListExpression)?)
                     | ("WORDTABLE" Identifier ("=" WordTableExpression)?)
                     | ("TYPELIST" Identifier ("=" TypeListExpression)?)
                     | ("STRINGLIST" Identifier
                                             ("=" StringListExpression)?)
                     | (("INTLIST" | "DOUBLELIST" | "FLOATLIST")
                                  Identifier ("=" NumberListExpression)?)
                     | ("BOOLEANLIST" Identifier
                                           ("=" BooleanListExpression)?))
                     | ("ANNOTATIONLIST" Identifier 
                                         ("=" AnnotationListExpression)?)
AnnotationType      -&gt;  BasicAnnotationType | declaredAnnotationType
BasicAnnotationType -&gt;  ('COLON'| 'SW' | 'MARKUP' | 'PERIOD' | 'CW'| 'NUM'
                      | 'QUESTION' | 'SPECIAL' | 'CAP' | 'COMMA'
                      | 'EXCLAMATION' | 'SEMICOLON' | 'NBSP'| 'AMP' | '_'
                      | 'SENTENCEEND' | 'W' | 'PM' | 'ANY' | 'ALL'
                      | 'SPACE' | 'BREAK')
BlockDeclaration    -&gt; "BLOCK" "(" Identifier ")" RuleElementWithCA
                                                       "{" Statements "}"</pre><p>
actionDeclaration   -&gt; "ACTION" Identifier "(" VarType Identifier ("," VarType Identifier)*")"  
                      "=" Action ( "," Action)* ";"
conditionDeclaration-&gt; "CONDITION" Identifier "(" VarType Identifier ("," VarType Identifier)*")"  
                      "=" Condition ( "," Condition)* ";"  
    Syntax of statements and rule elements:
    </p><pre class="programlisting">SimpleStatement        -&gt; SimpleRule | RegExpRule | ConjunctRules 
                          | DocumentActionRule
SimpleRule             -&gt; RuleElements ";"
RegExpRule             -&gt; StringExpression "-&gt;" GroupAssignment 
                          ("," GroupAssignment)* ";"
ConjunctRules          -&gt; RuleElements ("%" RuleElements)+ ";"
DocumentActionRule     -&gt; Actions ";"
GroupAssignment        -&gt; TypeExpression 
                        | NumberEpxression "=" TypeExpression
RuleElements           -&gt; RuleElement+
RuleElement            -&gt; (Identifier ":")? "@"? 
                        RuleElementType | RuleElementLiteral
                        | RuleElementComposed | RuleElementWildCard
RuleElementType        -&gt;  MatchReference OptionalRuleElementPart
RuleElementWithCA      -&gt;  MatchReference ("{" Conditions?  Actions? "}")?
MatchReference         -&gt; TypeExpression | FeatureMatchExpression
FeatureMatchExpression -&gt; TypeExpression ( "." Feature)+ 
                          ( Operator (Expression | "null"))?
RuleElementLiteral     -&gt;  SimpleStringExpression OptionalRuleElementPart
RuleElementComposed    -&gt; "(" RuleElement ("&amp;" RuleElement)+ ")"
                          | "(" RuleElement ("|" RuleElement)+ ")"
                          | "(" RuleElements ")"
                          OptionalRuleElementPart
OptionalRuleElementPart-&gt; QuantifierPart? ("{" Conditions?  Actions? "}")?
                          InlinedRules?
InlinedRules           -&gt;  ("&lt;-" "{" SimpleStatement+ "}")?
                           ("-&gt;"  "{" SimpleStatement+ "}")?
RuleElementWildCard    -&gt; "#"("{" Conditions?  Actions? }")? InlinedRules?
QuantifierPart         -&gt; "*" | "*?" | "+" | "+?" | "?" | "??"
                        | "[" NumberExpression "," NumberExpression "]"
                        | "[" NumberExpression "," NumberExpression "]?"
Conditions             -&gt; Condition ( "," Condition )*
Actions                -&gt; "-&gt;" Action ( "," Action)*
</pre><p>
    Since each condition and each action has its own syntax, conditions
    and actions are described in their own section. For conditions see
    <a class="xref" href="#ugr.tools.ruta.language.conditions" title="2.7.&nbsp;Conditions">Section&nbsp;2.7, &#8220;Conditions&#8221;</a>
    , for actions see
    <a class="xref" href="#ugr.tools.ruta.language.actions" title="2.8.&nbsp;Actions">Section&nbsp;2.8, &#8220;Actions&#8221;</a>.
    The syntax of expressions is explained in
    <a class="xref" href="#ugr.tools.ruta.language.expressions" title="2.6.&nbsp;Expressions">Section&nbsp;2.6, &#8220;Expressions&#8221;</a>.
  </p>
  <p>
    It is also possible to use specific expression as implicit conditions or action additionally to the set of available conditions and actions.
        </p><pre class="programlisting">Condition -&gt; BooleanExpression | FeatureMatchExpression
Action    -&gt; TypeExpression | FeatureAssignmentExpression | VariableAssignmentExpression 
</pre><p>
  

  </p>
  
  
  <p>
    Identifier:
    </p><pre class="programlisting">DottedIdentifier    -&gt;  Identifier ("." Identifier)*
DottedIdentifier2   -&gt;  Identifier (("."|"-") Identifier)*
Identifier          -&gt;  letter (letter|digit)*
</pre><p>
  </p>
</div>
  <div class="section" title="2.2.&nbsp;Rule elements and their matching order"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.tools.ruta.language.anchoring">2.2.&nbsp;Rule elements and their matching order</h2></div></div></div>
  
  <p>
    If not specified otherwise, then the UIMA Ruta rules normally start the matching 
    process with their first rule element. The first rule element searches for possible positions for its matching
    condition and then will advise the next rule element to continue the matching process.
    For that reason, writing rules that contain a first rule element with an optional quantifier is discouraged 
    and will result in ignoring the optional attribute of the quantifier.
  </p>
  <p>
    The starting rule element can also be manually specified by adding <span class="quote">&#8220;<span class="quote">@</span>&#8221;</span> directly in front of the matching condition.
    In the following example, the rule first searches for capitalized words (CW) and then checks whether 
    there is a period in front of the matched word.
    </p><pre class="programlisting">PERIOD @CW;</pre><p>
    This functionality can also be used for rules that start with an optional rule element by manually specifying a later
    rule element to start the matching process.
  </p>
  <p>
    The choice of the starting rule element can greatly influence the performance speed of the rule execution. 
    This circumstance is illustrated with the following example that contains two rules, whereas already an annotation 
    of the type <span class="quote">&#8220;<span class="quote">LastToken</span>&#8221;</span> was added to the last token of the document:
    </p><pre class="programlisting">ANY LastToken;
ANY @LastToken;</pre><p>
    The first rule matches on each token of the document and checks whether the next annotation is the last token of the document.
    This will result in many index operations because all tokens of the document are considered. 
    The second rule, however, matches on the last token and then checks if there is any token in front of it. This
    rule, therefore, considers only one token. 
  </p>
  <p>
    The UIMA Ruta language provides also a concept for automatically selecting the starting rule element called dynamic anchoring.
    Here, a simple heuristic concerning the position of the rule element and the involved types is applied in order to identify
    the favorable rule element. This functionality can be activated in the <a class="link" href="#ugr.tools.ruta.ae.basic.parameter" title="1.5.1.1.&nbsp;Configuration Parameters">configuration parameters</a> of the analysis engine or 
    directly in the script file with the <a class="link" href="#ugr.tools.ruta.language.actions.dynamicanchoring" title="2.8.11.&nbsp;DYNAMICANCHORING">DYNAMICANCHORING</a> action. 
  </p>
  
  <p>
    A list of rule elements normally specifies a sequential pattern. The rule is able to match if the first rule element successfully matches 
    and then the following rule element at the position after the match of the first rule element, and so on. There are three language constructs that break up that
    sequential matching: <span class="quote">&#8220;<span class="quote">&amp;</span>&#8221;</span>, <span class="quote">&#8220;<span class="quote">|</span>&#8221;</span> and <span class="quote">&#8220;<span class="quote">%</span>&#8221;</span>. A composed rule element where all inner rule elements are linked by the symbol <span class="quote">&#8220;<span class="quote">&amp;</span>&#8221;</span>
    matches only if all inner rule elements successfully match at the given position. A composed rule element with inner rule elements linked by the 
    symbol <span class="quote">&#8220;<span class="quote">|</span>&#8221;</span> matches if one of the inner rule element successfully matches. These composed rule elements therefore specify a conjunction (<span class="quote">&#8220;<span class="quote">and</span>&#8221;</span>) 
    and a disjunction (<span class="quote">&#8220;<span class="quote">or</span>&#8221;</span>) of its rule element at the given position. The symbol <span class="quote">&#8220;<span class="quote">%</span>&#8221;</span> specifies a different use case.
    Here, rules themselves are linked and they are only able to fire if each one of the linked rules successfully matched. In contrast to <span class="quote">&#8220;<span class="quote">&amp;</span>&#8221;</span>, 
    this linkage of rule elements does not introduce constraints for the matched positions. In the following, a few examples of these three language constructs are given.
  </p>
  <pre class="programlisting">(Token.posTag=="DET" &amp; Lemma.value=="the");</pre>
  <p>
    This rule is fulfilled, if there is a token whose feature <span class="quote">&#8220;<span class="quote">posTag</span>&#8221;</span> has the value <span class="quote">&#8220;<span class="quote">DET</span>&#8221;</span> and an annotation of the type <span class="quote">&#8220;<span class="quote">Lemma</span>&#8221;</span> whose feature <span class="quote">&#8220;<span class="quote">value</span>&#8221;</span> 
    has the value <span class="quote">&#8220;<span class="quote">the</span>&#8221;</span>. Both rule elements need to be fulfilled at the same position.
  </p>
  <pre class="programlisting">NUM (W{REGEXP("Peter") -&gt; Name} &amp; (ANY CW{PARTOF(Name)}));</pre>
  <p>
    This rule matches on a number and then validates if the next word is <span class="quote">&#8220;<span class="quote">Peter</span>&#8221;</span> and if next but one token is capitalized and part of an annotation of the type <span class="quote">&#8220;<span class="quote">Name</span>&#8221;</span>.
    If all rule elements successfully matched, then a new annotation of the type <span class="quote">&#8220;<span class="quote">Name</span>&#8221;</span> will be created covering the largest match of the linked rule elements. In this example,
    the new annotation covers also the token after the word <span class="quote">&#8220;<span class="quote">Peter</span>&#8221;</span> even if the actions was specified at the rule element with the smaller match.
  </p>
  <pre class="programlisting">((W{REGEXP("Peter")} CW) | ("Mr" PERIOD CW)){-&gt; Name};</pre>
  <p>
    In this example, an annotation of the type <span class="quote">&#8220;<span class="quote">Name</span>&#8221;</span> will be created for the token <span class="quote">&#8220;<span class="quote">Peter</span>&#8221;</span> followed by a 
    capitalized word or the word <span class="quote">&#8220;<span class="quote">Mr</span>&#8221;</span> followed by a period and a capitalized word.   
  </p>
  <pre class="programlisting">(Animal ((COMMA | "and") Animal)+){-&gt; AnimalEnum};</pre>
  <p>
    This rule annotates enumerations of animal annotations whereas each animal annotation is separated by either a comma or the word <span class="quote">&#8220;<span class="quote">and</span>&#8221;</span>.
  </p>
  <pre class="programlisting">BLOCK(forEach) Sentence{}{
  CW NUM % SW NUM{-&gt; MARK(Found, 1, 2)};
}</pre>
  <p>
    Here, annotations of the type <span class="quote">&#8220;<span class="quote">Found</span>&#8221;</span> are created if a sentence contains a capitalized word followed by a number and a small written word followed by a number 
    regardless of where these annotations occur in the sentence.
  </p>
  
  
</div>
  <div class="section" title="2.3.&nbsp;Basic annotations and tokens"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.tools.ruta.language.seeding">2.3.&nbsp;Basic annotations and tokens</h2></div></div></div>
  
  <p>
    The UIMA Ruta system uses a JFlex lexer to initially create a
    seed of basic token annotations. These tokens build a hierarchy shown in <a class="xref" href="#figure.ugr.tools.ruta.language.seeding.basic_token" title="Figure&nbsp;2.1.&nbsp;Basic token hierarchy">Figure&nbsp;2.1, &#8220;Basic token hierarchy
      &#8221;</a>. The
    <span class="quote">&#8220;<span class="quote">ALL</span>&#8221;</span> (green) annotation is the root of the hierarchy. ALL and the red
    marked annotation types are abstract. This means that they are actually not
    created by the lexer. An overview of these abstract types can
    be found in <a class="xref" href="#table.ugr.tools.ruta.language.seeding.basic_token.abstract" title="Table&nbsp;2.1.&nbsp;Abstract annotations">Table&nbsp;2.1, &#8220;Abstract annotations&#8221;</a>. The leafs of the hierarchy (blue) are created by the lexer. Each
    leaf is an own type, but also inherits the types of the abstract
    annotation types further up in the hierarchy. The leaf types are
    described in more detail in <a class="xref" href="#table.ugr.tools.ruta.language.seeding.basic_token.created" title="Table&nbsp;2.2.&nbsp;Annotations created by lexer">Table&nbsp;2.2, &#8220;Annotations created by lexer&#8221;</a>.
    Each text unit within an input document belongs to exactly one of these
    annotation types.
  </p>
  <p>
    </p><div class="figure"><a name="figure.ugr.tools.ruta.language.seeding.basic_token"></a><div class="figure-contents">
      
      <div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="576"><tr><td align="center"><img src="images/tools/ruta/language/basic_token/basic_token.png" align="middle" width="576" alt="Basic token hierarchy."></td></tr></table></div>
    </div><p class="title"><b>Figure&nbsp;2.1.&nbsp;Basic token hierarchy
      </b></p></div><p><br class="figure-break">
  </p>
  <p>
    </p><div class="table"><a name="table.ugr.tools.ruta.language.seeding.basic_token.abstract"></a><p class="title"><b>Table&nbsp;2.1.&nbsp;Abstract annotations</b></p><div class="table-contents">
      
      <table summary="Abstract annotations" style="border-collapse: collapse;border-top: 0.5pt solid black; border-bottom: 0.5pt solid black; border-left: 0.5pt solid black; border-right: 0.5pt solid black; "><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><thead><tr><th style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; " align="center">Annotation</th><th style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; " align="center">Parent</th><th style="border-bottom: 0.5pt solid black; " align="center">Description</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">ALL</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">-</td><td style="border-bottom: 0.5pt solid black; ">parent type of all tokens</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">ANY</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">ALL</td><td style="border-bottom: 0.5pt solid black; ">all tokens except for markup</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">W</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">ANY</td><td style="border-bottom: 0.5pt solid black; ">all kinds of words</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">PM</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">ANY</td><td style="border-bottom: 0.5pt solid black; ">all kinds of punctuation marks</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">WS</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">ANY</td><td style="border-bottom: 0.5pt solid black; ">all kinds of white spaces</td></tr><tr><td style="border-right: 0.5pt solid black; ">SENTENCEEND</td><td style="border-right: 0.5pt solid black; ">PM</td><td style="">all kinds of punctuation marks that indicate the end of a
              sentence
            </td></tr></tbody></table>
    </div></div><p><br class="table-break">
  </p>
  <p>
    </p><div class="table"><a name="table.ugr.tools.ruta.language.seeding.basic_token.created"></a><p class="title"><b>Table&nbsp;2.2.&nbsp;Annotations created by lexer</b></p><div class="table-contents">
      
      <table summary="Annotations created by lexer" style="border-collapse: collapse;border-top: 0.5pt solid black; border-bottom: 0.5pt solid black; border-left: 0.5pt solid black; border-right: 0.5pt solid black; "><colgroup><col class="c1"><col class="c2"><col class="c3"><col class="c4"></colgroup><thead><tr><th style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; " align="center">Annotation</th><th style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; " align="center">Parent</th><th style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; " align="center">Description</th><th style="border-bottom: 0.5pt solid black; " align="center">Example</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">MARKUP</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">ALL</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">HTML and XML elements</td><td style="border-bottom: 0.5pt solid black; ">&lt;p class="Headline"&gt;</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">NBSP</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">SPACE</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">non breaking space</td><td style="border-bottom: 0.5pt solid black; ">" "</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">AMP</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">ANY</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">ampersand expression</td><td style="border-bottom: 0.5pt solid black; ">&amp;amp;</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">BREAK</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">WS</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">line break</td><td style="border-bottom: 0.5pt solid black; ">\n</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">SPACE</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">WS</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">spaces</td><td style="border-bottom: 0.5pt solid black; ">" "</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">COLON</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">PM</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">colon</td><td style="border-bottom: 0.5pt solid black; ">:</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">COMMA</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">PM</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">comma</td><td style="border-bottom: 0.5pt solid black; ">,</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">PERIOD</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">SENTENCEEND</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">period</td><td style="border-bottom: 0.5pt solid black; ">.</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">EXCLAMATION</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">SENTENCEEND</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">exclamation mark</td><td style="border-bottom: 0.5pt solid black; ">!</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">SEMICOLON</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">PM</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">semicolon</td><td style="border-bottom: 0.5pt solid black; ">;</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">QUESTION</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">SENTENCEEND</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">question mark</td><td style="border-bottom: 0.5pt solid black; ">?</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">SW</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">W</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">lower case work</td><td style="border-bottom: 0.5pt solid black; ">annotation</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">CW</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">W</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">work starting with one capitalized letter</td><td style="border-bottom: 0.5pt solid black; ">Annotation</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">CAP</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">W</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">word only containing capitalized letters</td><td style="border-bottom: 0.5pt solid black; ">ANNOTATION</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">NUM</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">ANY</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">sequence of digits</td><td style="border-bottom: 0.5pt solid black; ">0123</td></tr><tr><td style="border-right: 0.5pt solid black; ">SPECIAL</td><td style="border-right: 0.5pt solid black; ">ANY</td><td style="border-right: 0.5pt solid black; ">all other tokens and symbols</td><td style="">/</td></tr></tbody></table>
    </div></div><p><br class="table-break">
  </p>
</div>
  <div class="section" title="2.4.&nbsp;Quantifiers"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.tools.ruta.language.quantifier">2.4.&nbsp;Quantifiers</h2></div></div></div>
  
  <p>
  </p>
  <div class="section" title="2.4.1.&nbsp;* Star Greedy"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.language.quantifier.sg">2.4.1.&nbsp;* Star Greedy</h3></div></div></div>
    
    <p>
      The Star Greedy quantifier matches on any amount of annotations and
      evaluates always true. Please mind that a rule element with a Star
      Greedy quantifier needs to match on different annotations as the
      next rule element.

      Examples:
      </p><pre class="programlisting">Input:    small Big Big Big small
Rule:     CW*
Matched:  Big Big Big  
Matched:  Big Big 
Matched:  Big</pre><p>
    </p>
  </div>
  <div class="section" title="2.4.2.&nbsp;*? Star Reluctant"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.language.quantifier.sr">2.4.2.&nbsp;*? Star Reluctant</h3></div></div></div>
    
    <p>
      The Star Reluctant quantifier matches on any amount of annotations
      and evaluates always true, but stops to match on new annotations,
      when the next rule element matches and evaluates true on this
      annotation.

      Examples:
      </p><pre class="programlisting">Input:    123 456 small small Big 
Rule:     W*? CW
Matched:  small small Big
Matched:  small Big
Matched:  Big</pre><p>
    </p>
    <p>
     The last match <span class="quote">&#8220;<span class="quote">Big</span>&#8221;</span> can be problematic using different types 
     if the rule starts matching with the first rule element.
    </p>
  </div>
  <div class="section" title="2.4.3.&nbsp;+ Plus Greedy"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.language.quantifier.pg">2.4.3.&nbsp;+ Plus Greedy</h3></div></div></div>
    
    <p>
      The Plus Greedy quantifier needs to match on at least one
      annotation.
      Please mind that a rule element after a rule element
      with a Plus
      Greedy quantifier matches and evaluates on different
      conditions.

      Examples:

      </p><pre class="programlisting">Input:    123 456 small small Big 
Rule:     SW+ 
Matched:  small small
Matched:  small</pre><p>
    </p>
  </div>
  <div class="section" title="2.4.4.&nbsp;+? Plus Reluctant"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.language.quantifier.pr">2.4.4.&nbsp;+? Plus Reluctant</h3></div></div></div>
    
    <p>
      The Plus Reluctant quantifier has to match on at least one
      annotation
      in order to evaluate true, but stops when the next rule
      element is
      able to match on this annotation.

      Examples:
      </p><pre class="programlisting">Input:    123 456 small small Big 
Rule:     W+? CW
Matched:  small small Big
Matched:  small Big</pre><p>
    </p>
  </div>
  <div class="section" title="2.4.5.&nbsp;? Question Greedy"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.language.quantifier.qg">2.4.5.&nbsp;? Question Greedy</h3></div></div></div>
    
    <p>
      The Question Greedy quantifier matches optionally on an annotation
      and therefore always evaluates true.

      Examples:
      </p><pre class="programlisting">Input:    123 456 small Big small Big 
Rule:     SW CW? SW
Matched:  small Big small</pre><p>
    </p>
  </div>
  <div class="section" title="2.4.6.&nbsp;?? Question Reluctant"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.language.quantifier.qr">2.4.6.&nbsp;?? Question Reluctant</h3></div></div></div>
    
    <p>
      The Question Reluctant quantifier matches optionally on an
      annotation,
      if the next rule element does not match on the same
      annotation and
      therefore always evaluates true.

      Examples:
      </p><pre class="programlisting">Input:    123 456 small Big small Big 
Rule:     SW CW?? SW
Matched:  small Big small</pre><p>
    </p>
  </div>
  <div class="section" title="2.4.7.&nbsp;[x,y] Min Max Greedy"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.language.quantifier.mmg">2.4.7.&nbsp;[x,y] Min Max Greedy</h3></div></div></div>
    
    <p>
      The Min Max Greedy quantifier has to match at least x and at most y
      annotations of its rule element to evaluate true.

      Examples:
      </p><pre class="programlisting">Input:    123 456 small Big small Big 
Rule:     SW CW[1,2] SW
Matched:  small Big small</pre><p>
    </p>
  </div>
  <div class="section" title="2.4.8.&nbsp;[x,y]? Min Max Reluctant"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.language.quantifier.mmr">2.4.8.&nbsp;[x,y]? Min Max Reluctant</h3></div></div></div>
    
    <p>
      The Min Max Greedy quantifier has to match at least x and at most y
      annotations of its rule element to evaluate true, but stops to
      match on additional annotations, if the next rule element is able to
      match on this annotation.

      Examples:
      </p><pre class="programlisting">Input:    123 456 small Big Big Big small Big 
Rule:     SW CW[2,100]? SW
Matched:  small Big Big Big small</pre><p>
    </p>
  </div>
</div>
  <div class="section" title="2.5.&nbsp;Declarations"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.tools.ruta.language.declarations">2.5.&nbsp;Declarations</h2></div></div></div>
  
  <p>
    There are three different kinds of declarations in the UIMA Ruta system:
    Declarations of types with optional feature definitions,
    declarations of variables and declarations for importing
    external resources, further UIMA Ruta scripts and UIMA components
    such as type systems and analysis engines.
  </p>
  <div class="section" title="2.5.1.&nbsp;Types"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.language.declarations.type">2.5.1.&nbsp;Types</h3></div></div></div>
    
    <p>
      Type declarations define new kinds of annotation types and
      optionally their features.
    </p>
      <div class="section" title="2.5.1.1.&nbsp; Example:"><div class="titlepage"><div><div><h4 class="title" id="d5e1013">2.5.1.1.&nbsp;
          <span class="bold"><strong>Example:</strong></span>
        </h4></div></div></div>
        
        <p>
          </p><pre class="programlisting">DECLARE SimpleType1, SimpleType2; // &lt;- two new types with the parent 
                                  // type "Annotation"
DECLARE ParentType NewType (SomeType feature1, INT feature2); 
  // a new type "NewType" with parent type "ParentType" and two features</pre><p>
        </p>
        <p>
          Attention: Types with features need a parent type in their
          declarations. If no special parent type is
          requested, just use type Annotation as
          default parent type.
        </p>
      </div>
  </div>
  <div class="section" title="2.5.2.&nbsp;Variables"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.language.declarations.variable">2.5.2.&nbsp;Variables</h3></div></div></div>
    
    <p>
      Variable declarations define new variables. There are 12 kinds of
      variables:
      </p><div class="itemizedlist"><ul class="itemizedlist" type="opencircle"><li class="listitem" style="list-style-type: circle">
          <p>
            Type variable: A variable that represents an annotation
            type.
          </p>
        </li><li class="listitem" style="list-style-type: circle">
          <p>
            Type list variable: A variable that represents a list of
            annotation
            types.
          </p>
        </li><li class="listitem" style="list-style-type: circle">
          <p>
            Integer variable: A variable that represents an integer.
          </p>
        </li><li class="listitem" style="list-style-type: circle">
          <p>
            Integer list variable: A variable that represents a list of
            integers.
          </p>
        </li><li class="listitem" style="list-style-type: circle">
          <p>
            Float variable: A variable that represents a
            floating-point
            number.
          </p>
        </li><li class="listitem" style="list-style-type: circle">
          <p>
            Float list variable: A variable that represents a list of
            floating-point numbers in single precision.
          </p>
        </li><li class="listitem" style="list-style-type: circle">
          <p>
            Double variable: A variable that represents a
            floating-point
            number.
          </p>
        </li><li class="listitem" style="list-style-type: circle">
          <p>
            Double list variable: A variable that represents a list
            of
            floating-point numbers in double precision.
          </p>
        </li><li class="listitem" style="list-style-type: circle">
          <p>
            String variable: A variable that represents a string.
          </p>
        </li><li class="listitem" style="list-style-type: circle">
          <p>
            String list: A variable that represents a list of strings.
          </p>
        </li><li class="listitem" style="list-style-type: circle">
          <p>
            Boolean
            variable: A variable that represents a boolean.
          </p>
        </li><li class="listitem" style="list-style-type: circle">
          <p>
            Boolean list variable: A variable that represents a list of
            booleans.
          </p>
        </li></ul></div><p>
    </p>
      <div class="section" title="2.5.2.1.&nbsp; Example:"><div class="titlepage"><div><div><h4 class="title" id="d5e1047">2.5.2.1.&nbsp;
          <span class="bold"><strong>Example:</strong></span>
        </h4></div></div></div>
        
        <p>
          </p><pre class="programlisting">TYPE newTypeVariable;
TYPELIST newTypeList;
INT newIntegerVariable;
INTLIST newIntList;
FLOAT newFloatVariable;
FLOATLIST newFloatList;
DOUBLE newDoubleVariable;
DOUBLELIST newDoubleList;
STRING newStringVariable;
STRINGLIST newStringList;
BOOLEAN newBooleanVariable;
BOOLEANLIST newBooleanList;</pre><p>
        </p>
      </div>
  </div>
  <div class="section" title="2.5.3.&nbsp;Resources"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.language.declarations.ressource">2.5.3.&nbsp;Resources</h3></div></div></div>
    
    <p>
      There are two kinds of resource declarations that make external
      resources available in the UIMA Ruta system:
      </p><div class="itemizedlist"><ul class="itemizedlist" type="opencircle"><li class="listitem" style="list-style-type: circle">
          <p>
            List: A list
            represents a normal text file with an entry per
            line
            or a compiled
            tree of a word list.
          </p>
        </li><li class="listitem" style="list-style-type: circle">
          <p>
            Table: A table represents a comma separated
            file.
          </p>
        </li></ul></div><p>
    </p>
      <div class="section" title="2.5.3.1.&nbsp; Example:"><div class="titlepage"><div><div><h4 class="title" id="d5e1060">2.5.3.1.&nbsp;
          <span class="bold"><strong>Example:</strong></span>
        </h4></div></div></div>
        
        <p>
          </p><pre class="programlisting">WORDLIST listName = 'someWordList.txt';
WORDTABLE tableName = 'someTable.csv';</pre><p>
        </p>
      </div>
  </div>
  <div class="section" title="2.5.4.&nbsp;Scripts"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.language.declarations.scripts">2.5.4.&nbsp;Scripts</h3></div></div></div>
    
    <p>
      Additional scripts can be imported and reused with the CALL action.
      The types of the imported rules are also available so that it
      is not necessary to import the Type System of the additional rule
      script.
    </p>
      <div class="section" title="2.5.4.1.&nbsp; Example:"><div class="titlepage"><div><div><h4 class="title" id="d5e1068">2.5.4.1.&nbsp;
          <span class="bold"><strong>Example:</strong></span>
        </h4></div></div></div>
        
        <p>
          </p><pre class="programlisting">SCRIPT my.package.AnotherScript; // "AnotherScript.ruta" in the  
                     //package "my.package"
Document{-&gt;CALL(AnotherScript)}; // &lt;- rule executes "AnotherScript.ruta"</pre><p>
        </p>
      </div>
  </div>
  <div class="section" title="2.5.5.&nbsp;Components"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.language.declarations.components">2.5.5.&nbsp;Components</h3></div></div></div>
    
    <p>
      There are three kinds of UIMA components that can be imported in a
      UIMA Ruta script:
      </p><div class="itemizedlist"><ul class="itemizedlist" type="opencircle"><li class="listitem" style="list-style-type: circle">
          <p>
            Type System (IMPORT or TYPESYSTEM): includes the types
            defined in an external type system. You can select which
            types or packages to import from a type system and how to
            alias them. If use IMPORT statements, consider enabling
            <a class="link" href="#ugr.tools.ruta.ae.basic.parameter.strictImports" title="strictImports">strictImports</a>.
          </p>
        </li><li class="listitem" style="list-style-type: circle">
          <p>
            Analysis Engine (ENGINE): loads the given descriptor and creates an external analysis
            engine. The descriptor  must be located in the descriptor paths.
            The type system needed for the analysis engine has
            to be imported separately. Please mind the filtering setting when
            calling an external analysis engine.
          </p>
        </li><li class="listitem" style="list-style-type: circle">
          <p>
            Analysis Engine (UIMAFIT): loads the given class and creates an external analysis
            engine. Please mind that the implementation of the analysis engine needs to be available. 
            The type system needed for the analysis engine has
            to be imported separately. Please mind the filtering setting when
            calling an external analysis engine.
          </p>
        </li></ul></div><p>
    </p>
      <div class="section" title="2.5.5.1.&nbsp; Type System Example:"><div class="titlepage"><div><div><h4 class="title" id="d5e1084">2.5.5.1.&nbsp;
          <span class="bold"><strong>Type System Example:</strong></span>
        </h4></div></div></div>
        
        <p>
          </p><pre class="programlisting">// Imports all the types from "ExternalTypeSystem.xml"
TYPESYSTEM my.package.ExternalTypeSystem;
IMPORT * FROM my.package.ExternalTypeSystem;

// Import my.package.SomeType from "ExternalTypeSystem.xml"
IMPORT my.package.SomeType FROM my.package.ExternalTypeSystem;

// Import my.package.SomeType from the typesystem available to
// the CAS at runtime. This can be useful when typesystems are
// loaded by uimaFIT
IMPORT my.package.SomeType;

// Import my.package.SomeType from "ExternalTypeSystem.xml" 
// and alias it to T1
IMPORT my.package.SomeType FROM my.package.ExternalTypeSystem AS T1;

// Import all types in my.package from "ExternalTypeSystem.xml"
IMPORT PACKAGE my.package FROM my.package.ExternalTypeSystem;

// Import package my.package from "ExternalTypeSystem.xml" 
// and alias it to p1 (p1.SomeType can now be used)
IMPORT PACKAGE my.package FROM my.package.ExternalTypeSystem AS p1; 

// Import all packages from "ExternalTypeSystem.xml" and alias them to p2
IMPORT PACKAGE * FROM my.package.ExternalTypeSystem AS p2;</pre><p>
        </p>
      </div>

      <div class="section" title="2.5.5.2.&nbsp; Analysis Engine Example:"><div class="titlepage"><div><div><h4 class="title" id="d5e1089">2.5.5.2.&nbsp;
          <span class="bold"><strong>Analysis Engine Example:</strong></span>
        </h4></div></div></div>
        
        <p>
          </p><pre class="programlisting">ENGINE my.package.ExternalEngine; // &lt;- "ExternalEngine.xml" in the 
// "my.package" package (in the descriptor folder)
UIMAFIT my.implementation.AnotherEngine;

Document{-&gt;RETAINTYPE(SPACE,BREAK),CALL(ExternalEngine)}; 
// calls ExternalEngine, but retains white spaces
Document{-&gt; EXEC(AnotherEngine, {SomeType})};</pre><p>
        </p>
      </div>
  </div>
</div>
  <div class="section" title="2.6.&nbsp;Expressions"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.tools.ruta.language.expressions">2.6.&nbsp;Expressions</h2></div></div></div>
  
  <p>
    UIMA Ruta provides five different kinds of expressions. These are
    type expressions, number expressions, string expressions,
    boolean expressions and list expressions.
  </p>
  <p>
  <span class="bold"><strong>Definition:</strong></span>
</p><pre class="programlisting">RutaExpression  -&gt;   TypeExpression | NumberExpression | 
                           StringExpression | BooleanExpression
                           | ListExpression</pre><p>
  </p>
  <div class="section" title="2.6.1.&nbsp;Type Expressions"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.language.expressions.type">2.6.1.&nbsp;Type Expressions</h3></div></div></div>
    
    <p>
      UIMA Ruta provides two kinds of type expressions.
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
          Declared annotation types (see
          <a class="xref" href="#ugr.tools.ruta.language.declarations.type" title="2.5.1.&nbsp;Types">Section&nbsp;2.5.1, &#8220;Types&#8221;</a>
          ).
        </li><li class="listitem">
          Type variables
          (see
          <a class="xref" href="#ugr.tools.ruta.language.declarations.variable" title="2.5.2.&nbsp;Variables">Section&nbsp;2.5.2, &#8220;Variables&#8221;</a>
          ).
        </li></ol></div><p>
      </p><div class="section" title="Definition:"><div class="titlepage"><div><div><h5 class="title" id="d5e1108">
          <span class="bold"><strong>Definition:</strong></span>
        </h5></div></div></div>
        
        <p>
</p><pre class="programlisting">TypeExpression  -&gt;  AnnotationType | TypeVariable</pre><p>
        </p>
      </div><p>
      </p><div class="section" title="Example:"><div class="titlepage"><div><div><h5 class="title" id="d5e1113">
          <span class="bold"><strong>Example:</strong></span>
        </h5></div></div></div>
        
        <p>
          </p><pre class="programlisting">DECLARE Author;  // Author defines a type, therefore it is 
                 // a type expression
TYPE typeVar;    // type variable typeVar is a type expression 
Document{-&gt;ASSIGN(typeVar, Author)};</pre><p>
        </p>
      </div><p>
    </p>
  </div>

  <div class="section" title="2.6.2.&nbsp;Number Expressions"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.language.expressions.number">2.6.2.&nbsp;Number Expressions</h3></div></div></div>
    
    <p>
      UIMA Ruta provides several possibilities to define number
      expressions. As expected, every number expression evaluates to a
      number. UIMA Ruta supports integer and floating-point numbers. A
      floating-point number can be in single or in double precision. To get
      a complete overview, have a look at the following syntax definition
      of number expressions.
      </p>
      <div class="section" title="2.6.2.1.&nbsp; Definition:"><div class="titlepage"><div><div><h4 class="title" id="d5e1121">2.6.2.1.&nbsp;
          <span class="bold"><strong>Definition:</strong></span>
        </h4></div></div></div>
        
        <p>
          </p><pre class="programlisting">NumberExpression         -&gt; AdditiveExpression
AdditiveExpression       -&gt; MultiplicativeExpression ( ( "+" | "-" ) 
                            MultiplicativeExpression )*
MultiplicativeExpression -&gt; SimpleNumberExpression ( ( "*" | "/" | "%" ) 
                            SimpleNumberExpression )*
                            | ( "EXP" | "LOGN" | "SIN" | "COS" | "TAN" ) 
                            "(" NumberExpression ")"
SimpleNumberExpression   -&gt; "-"? ( DecimalLiteral | FloatingPointLiteral 
                            | NumberVariable) | "(" NumberExpression ")"
DecimalLiteral        -&gt; ('0' | '1'..'9' Digit*) IntegerTypeSuffix?
IntegerTypeSuffix     -&gt;  ('l'|'L')
FloatingPointLiteral  -&gt; Digit+ '.' Digit* Exponent? FloatTypeSuffix?
                         |   '.' Digit+ Exponent? FloatTypeSuffix?
                         |   Digit+ Exponent FloatTypeSuffix?
                         |   Digit+ Exponent? FloatTypeSuffix
FloatTypeSuffix       -&gt;  ('f'|'F'|'d'|'D')
Exponent              -&gt; ('e'|'E') ('+'|'-')? Digit+
Digit                 -&gt; ('0'..'9') </pre><p>
        </p>
      </div>
      <p>
        For more information on number variables, see
        <a class="xref" href="#ugr.tools.ruta.language.declarations.variable" title="2.5.2.&nbsp;Variables">Section&nbsp;2.5.2, &#8220;Variables&#8221;</a>
        .
      </p>
      <div class="section" title="2.6.2.2.&nbsp; Examples:"><div class="titlepage"><div><div><h4 class="title" id="d5e1128">2.6.2.2.&nbsp;
          <span class="bold"><strong>Examples:</strong></span>
        </h4></div></div></div>
        
        <p>
          </p><pre class="programlisting">98     // a integer number literal
104   // a integer number literal
170.02   // a floating-point number literal
1.0845 // a floating-point number literal</pre><p>
        </p>
        <p>
          </p><pre class="programlisting">INT intVar1;
INT intVar2;
...
Document{-&gt;ASSIGN(intVar1, 12 * intVar1 - SIN(intVar2))};</pre><p>
        </p>
      </div>
  </div>

  <div class="section" title="2.6.3.&nbsp;String Expressions"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.language.expressions.string">2.6.3.&nbsp;String Expressions</h3></div></div></div>
    
    <p>
      There are two kinds of string expressions in UIMA Ruta.
       
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
         <p>
          String literals: String literals are defined by any sequence of
          characters within quotation marks.
           </p>
        </li><li class="listitem">
         <p>
          String variables (see
          <a class="xref" href="#ugr.tools.ruta.language.declarations.variable" title="2.5.2.&nbsp;Variables">Section&nbsp;2.5.2, &#8220;Variables&#8221;</a>
          )
         </p>
        </li></ol></div><p>
      </p>
      <div class="section" title="2.6.3.1.&nbsp; Definition:"><div class="titlepage"><div><div><h4 class="title" id="d5e1144">2.6.3.1.&nbsp;
          <span class="bold"><strong>Definition:</strong></span>
        </h4></div></div></div>
        
        <p>
          </p><pre class="programlisting">StringExpression   -&gt;   SimpleStringExpression
SimpleStringExpression  -&gt;  StringLiteral ("+" StringExpression)* 
                            | StringVariable</pre><p>
        </p>
      </div>
      <div class="section" title="2.6.3.2.&nbsp; Example:"><div class="titlepage"><div><div><h4 class="title" id="d5e1149">2.6.3.2.&nbsp;
          <span class="bold"><strong>Example:</strong></span>
        </h4></div></div></div>
        
        <p>
          </p><pre class="programlisting">STRING strVar; // define string variable
// add prefix "strLiteral" to variable strVar
Document{-&gt;ASSIGN(strVar, "strLiteral" + strVar)};</pre><p>
        </p>
      </div>
  </div>

  <div class="section" title="2.6.4.&nbsp;Boolean Expressions"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.language.expressions.boolean">2.6.4.&nbsp;Boolean Expressions</h3></div></div></div>
    
    <p>
      UIMA Ruta provides several possibilities to define boolean
      expressions. As expected, every boolean expression evaluates to
      either
      true or false. To get a complete overview, have a look at the
      following syntax definition of boolean expressions.
      </p>
      <div class="section" title="2.6.4.1.&nbsp; Definition:"><div class="titlepage"><div><div><h4 class="title" id="d5e1157">2.6.4.1.&nbsp;
          <span class="bold"><strong>Definition:</strong></span>
        </h4></div></div></div>
        
        <p>
          </p><pre class="programlisting">BooleanExpression          -&gt;  ComposedBooleanExpression 
                               | SimpleBooleanExpression
ComposedBooleanExpression  -&gt;  BooleanCompare | BooleanTypeExpression 
                               | BooleanNumberExpression | BooleanFunction
SimpleBooleanExpression     -&gt;  BooleanLiteral | BooleanVariable
BooleanCompare           -&gt;  SimpleBooleanExpression ( "==" | "!=" ) 
                               BooleanExpression
BooleanTypeExpression    -&gt;  TypeExpression ( "==" | "!=" ) TypeExpression
BooleanNumberExpression  -&gt;  "(" NumberExpression ( "&lt;" | "&lt;=" | "&gt;" 
                               | "&gt;=" | "==" | "!=" ) NumberExpression ")"
BooleanFunction   -&gt;  XOR "(" BooleanExpression "," BooleanExpression ")"
BooleanLiteral    -&gt;  "true" | "false"</pre><p>
        </p>
        <p>
          Boolean variables are defined in
          <a class="xref" href="#ugr.tools.ruta.language.declarations.variable" title="2.5.2.&nbsp;Variables">Section&nbsp;2.5.2, &#8220;Variables&#8221;</a>
          .
        </p>
      </div>
      <div class="section" title="2.6.4.2.&nbsp; Examples:"><div class="titlepage"><div><div><h4 class="title" id="d5e1164">2.6.4.2.&nbsp;
          <span class="bold"><strong>Examples:</strong></span>
        </h4></div></div></div>
        
        <p>
          </p><pre class="programlisting">Document{-&gt;ASSIGN(boolVar, false)};</pre><p>
        </p>
        <p>
          The boolean literal 'false' is assigned to boolean variable
          boolVar.
        </p>
        <p>
          </p><pre class="programlisting">Document{-&gt;ASSIGN(boolVar, typeVar == Author)};</pre><p>
        </p>
        <p>
          If the type variable typeVar represents annotation type Author,
          the
          boolean
          type expression evaluates to true, otherwise it evaluates
          to
          false. The result is assigned to boolean variable boolVar.
        </p>
        <p>
          </p><pre class="programlisting">Document{-&gt;ASSIGN(boolVar, (intVar == 10))};</pre><p>
        </p>
        <p>
          This rule shows a boolean number expression. If the value in
          variable intVar is equal to 10, the boolean number expression
          evaluates to true, otherwise it evaluates to
          false. The result is
          assigned to boolean variable boolVar. The brackets
          surrounding the number expression are necessary.
        </p>
        <p>
          </p><pre class="programlisting">Document{-&gt;ASSIGN(booleanVar1, booleanVar2 == (10 &gt; intVar))};</pre><p>
        </p>
        <p>
          This rule shows a more complex boolean expression. If the
          value
          in
          variable intVar is equal to 10, the boolean number
          expression
          evaluates to true, otherwise it evaluates to
          false. The
          result of
          this
          evaluation is compared to booleanVar2. The end result
          is
          assigned to
          boolean variable boolVar1. Realize that the syntax
          definition defines
          exactly this order. It is not possible to have
          the
          boolean number
          expression on the left side of the complex number
          expression.
        </p>
      </div>
  </div>
  

<div class="section" title="2.6.5.&nbsp;List Expressions"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.language.expressions.lists">2.6.5.&nbsp;List Expressions</h3></div></div></div>
    
    <p>
      List expression are a rather simple kind of expression.
      </p>
      <div class="section" title="2.6.5.1.&nbsp; Definition:"><div class="titlepage"><div><div><h4 class="title" id="d5e1182">2.6.5.1.&nbsp;
          <span class="bold"><strong>Definition:</strong></span>
        </h4></div></div></div>
        
        <p>
</p><pre class="programlisting">ListExpression  -&gt;   WordListExpression | WordTableExpression |
                     TypeListExpression | NumberListExpression |
                     StringListExpression | BooleanListExpression
WordListExpression     -&gt;  RessourceLiteral | WordListVariable
WordTableExpression    -&gt;  RessourceLiteral | WordTableVariable
TypeListExpression     -&gt;  TypeListVariable
                           | "{" TypeExpression ("," TypeExpression)* "}"
NumberListExpression   -&gt;  IntListVariable | FloatListVariable 
                           | DoubleListVariable
                           | "{" NumberExpression 
                              ("," NumberExpression)* "}"
StringListExpression   -&gt;  StringListVariable
                           | "{" StringExpression 
                              ("," StringExpression)* "}"
BooleanListExpression  -&gt;  BooleanListVariable
                           | "{" BooleanExpression 
                              ("," BooleanExpression)* "}"
</pre><p>
    A ResourceLiteral is something
    like 'folder/file.txt' (Attention: Use single quotes).
        </p>
        <p>
          List variables are defined in
          <a class="xref" href="#ugr.tools.ruta.language.declarations.variable" title="2.5.2.&nbsp;Variables">Section&nbsp;2.5.2, &#8220;Variables&#8221;</a>.
        </p>
      </div>
  </div>
  <div class="section" title="2.6.6.&nbsp;Feature Expressions"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.language.expressions.features">2.6.6.&nbsp;Feature Expressions</h3></div></div></div>
    
    <p>
     Feature expression can be used in different situations, e.g., for restricting the match of a rule element, 
     as an implicit condition or as an implicit action.
    </p><pre class="programlisting">FeatureExpression           -&gt; TypeExpression "." DottedIdentifier
FeatureMatchExpression      -&gt; FeatureExpression 
                               ("==" | "!=" | "&lt;=" | "&lt;" | "&gt;=" | "&gt;") 
                               Expression
FeatureAssignmentExpression -&gt; FeatureExpression "=" Expression
</pre><p>
    </p>
    <p>
      The covered text of an annoation can be referred to with "coveredText" or "ct". 
      The latter one is an abbreviation and returns the covered text of an annotation
      only if the type of the annotation does not define a feature with the name "ct". 
      The following example creates an annotation of the type TypeA for each word with the 
      covered text "A".
      </p><pre class="programlisting">W.ct == "A" {-&gt; TypeA};</pre><p>
    </p>
  </div>
</div>
  <div class="section" title="2.7.&nbsp;Conditions"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.tools.ruta.language.conditions">2.7.&nbsp;Conditions</h2></div></div></div>
  

  <div class="section" title="2.7.1.&nbsp;AFTER"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.language.conditions.after">2.7.1.&nbsp;AFTER</h3></div></div></div>
    
    <p>
      The AFTER condition evaluates true, if the matched annotation
      starts after the beginning of an arbitrary annotation of the passed
      type. If a list of types is passed, this has to be true for at least
      one of them.
    </p>
    <div class="section" title="2.7.1.1.&nbsp; Definition:"><div class="titlepage"><div><div><h4 class="title" id="d5e1200">2.7.1.1.&nbsp;
        <span class="bold"><strong>Definition:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">AFTER(Type|TypeListExpression)</pre><p>
      </p>
    </div>
    <div class="section" title="2.7.1.2.&nbsp; Example:"><div class="titlepage"><div><div><h4 class="title" id="d5e1205">2.7.1.2.&nbsp;
        <span class="bold"><strong>Example:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">CW{AFTER(SW)};</pre><p>
      </p>
      <p>
        Here, the rule matches on a capitalized word, if there is any
        small written word previously.
      </p>
    </div>
  </div>

  <div class="section" title="2.7.2.&nbsp;AND"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.language.conditions.and">2.7.2.&nbsp;AND</h3></div></div></div>
    
    <p>
      The AND condition is a composed condition and evaluates true, if
      all contained conditions evaluate true.
    </p>
    <div class="section" title="2.7.2.1.&nbsp; Definition:"><div class="titlepage"><div><div><h4 class="title" id="d5e1214">2.7.2.1.&nbsp;
        <span class="bold"><strong>Definition:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">AND(Condition1,...,ConditionN)</pre><p>
      </p>
    </div>
    <div class="section" title="2.7.2.2.&nbsp; Example:"><div class="titlepage"><div><div><h4 class="title" id="d5e1219">2.7.2.2.&nbsp;
        <span class="bold"><strong>Example:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">Paragraph{AND(PARTOF(Headline),CONTAINS(Keyword))
          -&gt;MARK(ImportantHeadline)};</pre><p>
      </p>
      <p>
        In this example, a paragraph is annotated with an
        ImportantHeadline annotation, if it is part of a Headline and
        contains a Keyword annotation.
      </p>
    </div>
  </div>

  <div class="section" title="2.7.3.&nbsp;BEFORE"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.language.conditions.before">2.7.3.&nbsp;BEFORE</h3></div></div></div>
    
    <p>
      The BEFORE condition evaluates true, if the matched annotation
      starts before the beginning of an arbitrary annotation of the passed
      type. If a list of types is passed, this has to be true for at least
      one of them.
    </p>
    <div class="section" title="2.7.3.1.&nbsp; Definition:"><div class="titlepage"><div><div><h4 class="title" id="d5e1228">2.7.3.1.&nbsp;
        <span class="bold"><strong>Definition:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">BEFORE(Type|TypeListExpression)</pre><p>
      </p>
    </div>
    <div class="section" title="2.7.3.2.&nbsp; Example:"><div class="titlepage"><div><div><h4 class="title" id="d5e1233">2.7.3.2.&nbsp;
        <span class="bold"><strong>Example:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">CW{BEFORE(SW)};</pre><p>
      </p>
      <p>
        Here, the rule matches on a capitalized word, if there is any
        small written word afterwards.
      </p>
    </div>
  </div>

  <div class="section" title="2.7.4.&nbsp;CONTAINS"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.language.conditions.contains">2.7.4.&nbsp;CONTAINS</h3></div></div></div>
    
    <p>
      The CONTAINS condition evaluates true on a matched annotation,
      if
      the frequency of the passed type lies within an optionally passed
      interval. The limits of the passed interval are per default
      interpreted as absolute numeral values. By passing a further boolean
      parameter set to true the limits are interpreted as percental
      values.
      If no interval parameters are passed at all, then the condition
      checks
      whether the matched annotation contains at least one
      occurrence of the
      passed type.
    </p>
    <div class="section" title="2.7.4.1.&nbsp; Definition:"><div class="titlepage"><div><div><h4 class="title" id="d5e1242">2.7.4.1.&nbsp;
        <span class="bold"><strong>Definition:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">CONTAINS(Type(,NumberExpression,NumberExpression(,BooleanExpression)?)?)</pre><p>
      </p>
    </div>
    <div class="section" title="2.7.4.2.&nbsp; Example:"><div class="titlepage"><div><div><h4 class="title" id="d5e1247">2.7.4.2.&nbsp;
        <span class="bold"><strong>Example:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">Paragraph{CONTAINS(Keyword)-&gt;MARK(KeywordParagraph)};</pre><p>
      </p>
      <p>
        A Paragraph is annotated with a KeywordParagraph annotation, if
        it contains a Keyword annotation.
      </p>
      <p>
        </p><pre class="programlisting">Paragraph{CONTAINS(Keyword,2,4)-&gt;MARK(KeywordParagraph)};</pre><p>
      </p>
      <p>
        A Paragraph is annotated with a KeywordParagraph annotation, if
        it contains between two and four Keyword annotations.
      </p>
      <p>
        </p><pre class="programlisting">Paragraph{CONTAINS(Keyword,50,100,true)-&gt;MARK(KeywordParagraph)};</pre><p>
      </p>
      <p>
        A Paragraph is annotated with a KeywordParagraph annotation, if it
        contains between 50% and 100% Keyword annotations. This is
        calculated based on the tokens of the Paragraph. If the Paragraph
        contains six basic annotations (see
        <a class="xref" href="#ugr.tools.ruta.language.seeding" title="2.3.&nbsp;Basic annotations and tokens">Section&nbsp;2.3, &#8220;Basic annotations and tokens&#8221;</a>), two of them are part of one Keyword annotation, and if one basic
        annotation is also annotated with a Keyword annotation, then the
        percentage of the contained Keywords is 50%.
      </p>
    </div>
  </div>

  <div class="section" title="2.7.5.&nbsp;CONTEXTCOUNT"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.language.conditions.contextcount">2.7.5.&nbsp;CONTEXTCOUNT</h3></div></div></div>
    
    <p>
      The CONTEXTCOUNT condition numbers all occurrences of the
      matched type within the context of a passed type's annotation
      consecutively, thus assigning an index to each occurrence.
      Additionally it stores the index of the matched annotation in a
      numerical variable if one is passed. The condition evaluates true if
      the index of the matched annotation is within a passed interval. If
      no interval is passed, the condition always evaluates true.
    </p>
    <div class="section" title="2.7.5.1.&nbsp; Definition:"><div class="titlepage"><div><div><h4 class="title" id="d5e1263">2.7.5.1.&nbsp;
        <span class="bold"><strong>Definition:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">CONTEXTCOUNT(Type(,NumberExpression,NumberExpression)?(,Variable)?)</pre><p>
      </p>
    </div>
    <div class="section" title="2.7.5.2.&nbsp; Example:"><div class="titlepage"><div><div><h4 class="title" id="d5e1268">2.7.5.2.&nbsp;
        <span class="bold"><strong>Example:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">Keyword{CONTEXTCOUNT(Paragraph,2,3,var)
          -&gt;MARK(SecondOrThirdKeywordInParagraph)};</pre><p>
      </p>
      <p>
        Here, the position of the matched Keyword annotation within a
        Paragraph annotation is calculated and stored in the variable 'var'.
        If the counted value lies within the interval [2,3], then the matched
        Keyword is annotated with the SecondOrThirdKeywordInParagraph
        annotation.
      </p>
    </div>
  </div>

  <div class="section" title="2.7.6.&nbsp;COUNT"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.language.conditions.count">2.7.6.&nbsp;COUNT</h3></div></div></div>
    
    <p>
      The COUNT condition can be used in two different ways. In the
      first case (see first definition), it counts the number of
      annotations of the passed type within the window of the matched
      annotation and stores the amount in a numerical variable, if such a
      variable is passed. The condition evaluates true if the counted
      amount is within a specified interval. If no interval is passed, the
      condition always evaluates true. In the second case (see second
      definition), it counts the number of occurrences of the passed
      VariableExpression (second parameter) within the passed list (first
      parameter) and stores the amount in a numerical variable, if such a
      variable is passed. Again, the condition evaluates true if the counted
      amount is within a specified interval. If no interval is passed, the
      condition always evaluates true.
    </p>
    <div class="section" title="2.7.6.1.&nbsp; Definition:"><div class="titlepage"><div><div><h4 class="title" id="d5e1277">2.7.6.1.&nbsp;
        <span class="bold"><strong>Definition:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">COUNT(Type(,NumberExpression,NumberExpression)?(,NumberVariable)?)</pre><p>
      </p>
      <p>
        </p><pre class="programlisting">COUNT(ListExpression,VariableExpression
          (,NumberExpression,NumberExpression)?(,NumberVariable)?)</pre><p>
      </p>
    </div>
    <div class="section" title="2.7.6.2.&nbsp; Example:"><div class="titlepage"><div><div><h4 class="title" id="d5e1284">2.7.6.2.&nbsp;
        <span class="bold"><strong>Example:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">Paragraph{COUNT(Keyword,1,10,var)-&gt;MARK(KeywordParagraph)};</pre><p>
      </p>
      <p>
        Here, the amount of Keyword annotations within a Paragraph is
        calculated and stored in the variable 'var'. If one to ten Keywords
        were counted, the paragraph is marked with a KeywordParagraph
        annotation.
      </p>
      <p>
        </p><pre class="programlisting">Paragraph{COUNT(list,"author",5,7,var)};</pre><p>
      </p>
      <p>
        Here, the number of occurrences of STRING "author" within the
        STRINGLIST 'list' is counted and stored in the variable 'var'. If
        "author" occurs five to seven times within 'list', the condition
        evaluates true.
      </p>
    </div>
  </div>

  <div class="section" title="2.7.7.&nbsp;CURRENTCOUNT"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.language.conditions.currentcount">2.7.7.&nbsp;CURRENTCOUNT</h3></div></div></div>
    
    <p>
      The CURRENTCOUNT condition numbers all occurrences of the matched
      type within the whole document consecutively, thus assigning an index
      to each occurrence. Additionally, it stores the index of the matched
      annotation in a numerical variable, if one is passed. The condition
      evaluates true if the index of the matched annotation is within a
      specified interval. If no interval is passed, the condition always
      evaluates true.
    </p>
    <div class="section" title="2.7.7.1.&nbsp; Definition:"><div class="titlepage"><div><div><h4 class="title" id="d5e1296">2.7.7.1.&nbsp;
        <span class="bold"><strong>Definition:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">CURRENTCOUNT(Type(,NumberExpression,NumberExpression)?(,Variable)?)</pre><p>
      </p>
    </div>
    <div class="section" title="2.7.7.2.&nbsp; Example:"><div class="titlepage"><div><div><h4 class="title" id="d5e1301">2.7.7.2.&nbsp;
        <span class="bold"><strong>Example:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">Paragraph{CURRENTCOUNT(Keyword,3,3,var)-&gt;MARK(ParagraphWithThirdKeyword)};</pre><p>
      </p>
      <p>
        Here, the Paragraph, which contains the third Keyword of the
        whole document, is annotated with the ParagraphWithThirdKeyword
        annotation. The index is stored in the variable 'var'.
      </p>
    </div>
  </div>

  <div class="section" title="2.7.8.&nbsp;ENDSWITH"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.language.conditions.endswith">2.7.8.&nbsp;ENDSWITH</h3></div></div></div>
    
    <p>
      The ENDSWITH condition evaluates true, if an annotation of the
      given type ends exactly at the same position as the matched
      annotation. If a list of types is passed, this has to be true for at
      least one of them.
    </p>
    <div class="section" title="2.7.8.1.&nbsp; Definition:"><div class="titlepage"><div><div><h4 class="title" id="d5e1310">2.7.8.1.&nbsp;
        <span class="bold"><strong>Definition:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">ENDSWITH(Type|TypeListExpression) </pre><p>
      </p>
    </div>
    <div class="section" title="2.7.8.2.&nbsp; Example:"><div class="titlepage"><div><div><h4 class="title" id="d5e1315">2.7.8.2.&nbsp;
        <span class="bold"><strong>Example:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">Paragraph{ENDSWITH(SW)};</pre><p>
      </p>
      <p>
        Here, the rule matches on a Paragraph annotation, if it ends
        with a small written word.
      </p>
    </div>
  </div>

  <div class="section" title="2.7.9.&nbsp;FEATURE"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.language.conditions.feature">2.7.9.&nbsp;FEATURE</h3></div></div></div>
    
    <p>
      The FEATURE condition compares a feature of the matched
      annotation with the second argument.
    </p>
    <div class="section" title="2.7.9.1.&nbsp; Definition:"><div class="titlepage"><div><div><h4 class="title" id="d5e1324">2.7.9.1.&nbsp;
        <span class="bold"><strong>Definition:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">FEATURE(StringExpression,Expression) </pre><p>
      </p>
    </div>
    <div class="section" title="2.7.9.2.&nbsp; Example:"><div class="titlepage"><div><div><h4 class="title" id="d5e1329">2.7.9.2.&nbsp;
        <span class="bold"><strong>Example:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">Document{FEATURE("language",targetLanguage)}</pre><p>
      </p>
      <p>
        This rule matches, if the feature named 'language' of the
        document annotation equals the value of the variable
        'targetLanguage'.
      </p>
    </div>
  </div>

  <div class="section" title="2.7.10.&nbsp;IF"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.language.conditions.if">2.7.10.&nbsp;IF</h3></div></div></div>
    
    <p>
      The IF condition evaluates true, if the contained boolean
      expression evaluates true.
    </p>
    <div class="section" title="2.7.10.1.&nbsp; Definition:"><div class="titlepage"><div><div><h4 class="title" id="d5e1338">2.7.10.1.&nbsp;
        <span class="bold"><strong>Definition:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">IF(BooleanExpression) </pre><p>
      </p>
    </div>
    <div class="section" title="2.7.10.2.&nbsp; Example:"><div class="titlepage"><div><div><h4 class="title" id="d5e1343">2.7.10.2.&nbsp;
        <span class="bold"><strong>Example:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">Paragraph{IF(keywordAmount &gt; 5)-&gt;MARK(KeywordParagraph)};</pre><p>
      </p>
      <p>
        A Paragraph annotation is annotated with a KeywordParagraph
        annotation, if the value of the variable 'keywordAmount' is greater
        than five.
      </p>
    </div>
  </div>

  <div class="section" title="2.7.11.&nbsp;INLIST"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.language.conditions.inlist">2.7.11.&nbsp;INLIST</h3></div></div></div>
    
    <p>
      The INLIST condition is fulfilled, if the matched annotation is listed
      in a given word or string list. If an optional agrument is given, then 
      the value of the argument is used instead of the covered text of the matched annotation
    </p>
    <div class="section" title="2.7.11.1.&nbsp; Definition:"><div class="titlepage"><div><div><h4 class="title" id="d5e1352">2.7.11.1.&nbsp;
        <span class="bold"><strong>Definition:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">INLIST(WordList(,StringExpression)?) </pre><p>
      </p>
      <p>
        </p><pre class="programlisting">INLIST(StringList(,StringExpression)?) </pre><p>
      </p>
    </div>
    <div class="section" title="2.7.11.2.&nbsp; Example:"><div class="titlepage"><div><div><h4 class="title" id="d5e1359">2.7.11.2.&nbsp;
        <span class="bold"><strong>Example:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">Keyword{INLIST(SpecialKeywordList)-&gt;MARK(SpecialKeyword)};</pre><p>
      </p>
      <p>
        A Keyword is annotated with the type SpecialKeyword, if the text
        of the Keyword annotation is listed in the word list or string list
        SpecialKeywordList.
      </p>
      <p>
        </p><pre class="programlisting">Token{INLIST(MyLemmaList, Token.lemma)-&gt;MARK(SpecialLemma)};</pre><p>
      </p>
      <p>
        This rule creates an annotation of the type SpecialLemma for each token that provides a feature value 
        of the feature "lemma" that is present in the string list or word list MyLemmaList.
      </p>
    </div>
  </div>

  <div class="section" title="2.7.12.&nbsp;IS"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.language.conditions.is">2.7.12.&nbsp;IS</h3></div></div></div>
    
    <p>
      The IS condition evaluates true, if there is an annotation of the
      given type with the same beginning and ending offsets as the
      matched
      annotation. If a list of types is given, the condition
      evaluates true,
      if at least one of them fulfills the former condition.
    </p>
    <div class="section" title="2.7.12.1.&nbsp; Definition:"><div class="titlepage"><div><div><h4 class="title" id="d5e1371">2.7.12.1.&nbsp;
        <span class="bold"><strong>Definition:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">IS(Type|TypeListExpression) </pre><p>
      </p>
    </div>
    <div class="section" title="2.7.12.2.&nbsp; Example:"><div class="titlepage"><div><div><h4 class="title" id="d5e1376">2.7.12.2.&nbsp;
        <span class="bold"><strong>Example:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">Author{IS(Englishman)-&gt;MARK(EnglishAuthor)};</pre><p>
      </p>
      <p>
        If an Author annotation is also annotated with an Englishman
        annotation, it is annotated with an EnglishAuthor annotation.
      </p>
    </div>
  </div>

  <div class="section" title="2.7.13.&nbsp;LAST"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.language.conditions.last">2.7.13.&nbsp;LAST</h3></div></div></div>
    
    <p>
      The LAST condition evaluates true, if the type of the last token
      within the window of the matched annotation is of the given type.
    </p>
    <div class="section" title="2.7.13.1.&nbsp; Definition:"><div class="titlepage"><div><div><h4 class="title" id="d5e1385">2.7.13.1.&nbsp;
        <span class="bold"><strong>Definition:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">LAST(TypeExpression) </pre><p>
      </p>
    </div>
    <div class="section" title="2.7.13.2.&nbsp; Example:"><div class="titlepage"><div><div><h4 class="title" id="d5e1390">2.7.13.2.&nbsp;
        <span class="bold"><strong>Example:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">Document{LAST(CW)};</pre><p>
      </p>
      <p>
        This rule fires, if the last token of the document is a
        capitalized word.
      </p>
    </div>
  </div>

  <div class="section" title="2.7.14.&nbsp;MOFN"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.language.conditions.mofn">2.7.14.&nbsp;MOFN</h3></div></div></div>
    
    <p>
      The MOFN condition is a composed condition. It evaluates true if
      the number of containing conditions evaluating true is within a given
      interval.
    </p>
    <div class="section" title="2.7.14.1.&nbsp; Definition:"><div class="titlepage"><div><div><h4 class="title" id="d5e1399">2.7.14.1.&nbsp;
        <span class="bold"><strong>Definition:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">MOFN(NumberExpression,NumberExpression,Condition1,...,ConditionN) </pre><p>
      </p>
    </div>
    <div class="section" title="2.7.14.2.&nbsp; Example:"><div class="titlepage"><div><div><h4 class="title" id="d5e1404">2.7.14.2.&nbsp;
        <span class="bold"><strong>Example:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">Paragraph{MOFN(1,1,PARTOF(Headline),CONTAINS(Keyword))
          -&gt;MARK(HeadlineXORKeywords)};</pre><p>
      </p>
      <p>
        A Paragraph is marked as a HeadlineXORKeywords, if the matched
        text is either part of a Headline annotation or contains Keyword
        annotations.
      </p>
    </div>
  </div>

  <div class="section" title="2.7.15.&nbsp;NEAR"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.language.conditions.near">2.7.15.&nbsp;NEAR</h3></div></div></div>
    
    <p>
      The NEAR condition is fulfilled, if the distance of the matched
      annotation to an annotation of the given type is within a given
      interval. The direction is defined by a boolean parameter, whose
      default value is set to true, therefore searching forward. By default this
      condition works on an unfiltered index. An optional fifth boolean
      parameter can be set to true to get the condition being evaluated on
      a filtered index.
    </p>
    <div class="section" title="2.7.15.1.&nbsp; Definition:"><div class="titlepage"><div><div><h4 class="title" id="d5e1413">2.7.15.1.&nbsp;
        <span class="bold"><strong>Definition:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">NEAR(TypeExpression,NumberExpression,NumberExpression
          (,BooleanExpression(,BooleanExpression)?)?) </pre><p>
      </p>
    </div>
    <div class="section" title="2.7.15.2.&nbsp; Example:"><div class="titlepage"><div><div><h4 class="title" id="d5e1418">2.7.15.2.&nbsp;
        <span class="bold"><strong>Example:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">Paragraph{NEAR(Headline,0,10,false)-&gt;MARK(NoHeadline)};</pre><p>
      </p>
      <p>
        A Paragraph that starts at most ten tokens after a Headline
        annotation is annotated with the NoHeadline annotation.
      </p>
    </div>
  </div>

  <div class="section" title="2.7.16.&nbsp;NOT"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.language.conditions.not">2.7.16.&nbsp;NOT</h3></div></div></div>
    
    <p>
      The NOT condition negates the result of its contained
      condition.
    </p>
    <div class="section" title="2.7.16.1.&nbsp; Definition:"><div class="titlepage"><div><div><h4 class="title" id="d5e1427">2.7.16.1.&nbsp;
        <span class="bold"><strong>Definition:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">"-"Condition</pre><p>
      </p>
    </div>
    <div class="section" title="2.7.16.2.&nbsp; Example:"><div class="titlepage"><div><div><h4 class="title" id="d5e1432">2.7.16.2.&nbsp;
        <span class="bold"><strong>Example:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">Paragraph{-PARTOF(Headline)-&gt;MARK(Headline)};</pre><p>
      </p>
      <p>
        A Paragraph that is not part of a Headline annotation so far is
        annotated with a Headline annotation.
      </p>
    </div>
  </div>

  <div class="section" title="2.7.17.&nbsp;OR"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.language.conditions.or">2.7.17.&nbsp;OR</h3></div></div></div>
    
    <p>
      The OR Condition is a composed condition and evaluates true, if
      at least one contained condition is evaluated true.
    </p>
    <div class="section" title="2.7.17.1.&nbsp; Definition:"><div class="titlepage"><div><div><h4 class="title" id="d5e1441">2.7.17.1.&nbsp;
        <span class="bold"><strong>Definition:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">OR(Condition1,...,ConditionN)</pre><p>
      </p>
    </div>
    <div class="section" title="2.7.17.2.&nbsp; Example:"><div class="titlepage"><div><div><h4 class="title" id="d5e1446">2.7.17.2.&nbsp;
        <span class="bold"><strong>Example:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">Paragraph{OR(PARTOF(Headline),CONTAINS(Keyword))
                                           -&gt;MARK(ImportantParagraph)};</pre><p>
      </p>
      <p>
        In this example a Paragraph is annotated with the
        ImportantParagraph annotation, if it is a Headline or contains
        Keyword annotations.
      </p>
    </div>
  </div>

  <div class="section" title="2.7.18.&nbsp;PARSE"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.language.conditions.parse">2.7.18.&nbsp;PARSE</h3></div></div></div>
    
    <p>
      The PARSE condition is fulfilled, if the text covered by the
      matched annotation can be transformed into a value of the given
      variable's type. If this is possible, the parsed value is
      additionally assigned to the passed variable.
    </p>
    <div class="section" title="2.7.18.1.&nbsp; Definition:"><div class="titlepage"><div><div><h4 class="title" id="d5e1455">2.7.18.1.&nbsp;
        <span class="bold"><strong>Definition:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">PARSE(variable(, stringExpression)?)</pre><p>
      </p>
    </div>
    <div class="section" title="2.7.18.2.&nbsp; Example:"><div class="titlepage"><div><div><h4 class="title" id="d5e1460">2.7.18.2.&nbsp;
        <span class="bold"><strong>Example:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">NUM{PARSE(var,"de")};</pre><p>
      </p>
      <p>
        If the variable 'var' is of an appropriate numeric type for the locale "de", the
        value of NUM is parsed and subsequently stored in 'var'.
      </p>
    </div>
  </div>

  <div class="section" title="2.7.19.&nbsp;PARTOF"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.language.conditions.partof">2.7.19.&nbsp;PARTOF</h3></div></div></div>
    
    <p>
      The PARTOF condition is fulfilled, if the matched annotation is
      part of an annotation of the given type. However, it is not necessary
      that the matched annotation is smaller than the annotation of the
      given type. Use the (much slower) PARTOFNEQ condition instead, if this
      is needed. If a type list is given, the condition evaluates true, if
      the former described condition for a single type is fulfilled for at
      least one of the types in the list.
    </p>
    <div class="section" title="2.7.19.1.&nbsp; Definition:"><div class="titlepage"><div><div><h4 class="title" id="d5e1469">2.7.19.1.&nbsp;
        <span class="bold"><strong>Definition:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">PARTOF(Type|TypeListExpression)</pre><p>
      </p>
    </div>
    <div class="section" title="2.7.19.2.&nbsp; Example:"><div class="titlepage"><div><div><h4 class="title" id="d5e1474">2.7.19.2.&nbsp;
        <span class="bold"><strong>Example:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">Paragraph{PARTOF(Headline) -&gt; MARK(ImportantParagraph)};</pre><p>
      </p>
      <p>
        A Paragraph is an ImportantParagraph, if the matched text is
        part of a Headline annotation.
      </p>
    </div>
  </div>

  <div class="section" title="2.7.20.&nbsp;PARTOFNEQ"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.language.conditions.partofneq">2.7.20.&nbsp;PARTOFNEQ</h3></div></div></div>
    
    <p>
      The PARTOFNEQ condition is fulfilled if the matched annotation
      is part of (smaller than and inside of) an annotation of the given
      type. If also annotations of the same size should be acceptable, use
      the PARTOF condition. If a type list is given, the condition
      evaluates true if the former described condition is fulfilled for at
      least one of the types in the list.
    </p>
    <div class="section" title="2.7.20.1.&nbsp; Definition:"><div class="titlepage"><div><div><h4 class="title" id="d5e1483">2.7.20.1.&nbsp;
        <span class="bold"><strong>Definition:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">PARTOFNEQ(Type|TypeListExpression)</pre><p>
      </p>
    </div>
    <div class="section" title="2.7.20.2.&nbsp; Example:"><div class="titlepage"><div><div><h4 class="title" id="d5e1488">2.7.20.2.&nbsp;
        <span class="bold"><strong>Example:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">W{PARTOFNEQ(Headline) -&gt; MARK(ImportantWord)};</pre><p>
      </p>
      <p>
        A word is an <span class="quote">&#8220;<span class="quote">ImportantWord</span>&#8221;</span>, if it is part of a headline.
      </p>
    </div>
  </div>

  <div class="section" title="2.7.21.&nbsp;POSITION"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.language.conditions.position">2.7.21.&nbsp;POSITION</h3></div></div></div>
    
    <p>
      The POSITION condition is fulfilled, if the matched type is the
      k-th occurrence of this type within the window of an annotation of the
      passed type, whereby k is defined by the value of the passed
      NumberExpression. If the additional boolean paramter is set to false,
      then k counts the occurrences of of the minimal annotations.
    </p>
    <div class="section" title="2.7.21.1.&nbsp; Definition:"><div class="titlepage"><div><div><h4 class="title" id="d5e1498">2.7.21.1.&nbsp;
        <span class="bold"><strong>Definition:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">POSITION(Type,NumberExpression(,BooleanExpression)?)</pre><p>
      </p>
    </div>
    <div class="section" title="2.7.21.2.&nbsp; Example:"><div class="titlepage"><div><div><h4 class="title" id="d5e1503">2.7.21.2.&nbsp;
        <span class="bold"><strong>Example:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">Keyword{POSITION(Paragraph,2)-&gt;MARK(SecondKeyword)};</pre><p>
      </p>
      <p>
        The second Keyword in a Paragraph is annotated with the type
        SecondKeyword.
      </p>
      <p>
        </p><pre class="programlisting">Keyword{POSITION(Paragraph,2,false)-&gt;MARK(SecondKeyword)};</pre><p>
      </p>
      <p>
        A Keyword in a Paragraph is annotated with the type
        SecondKeyword, if it starts at the same offset as the second
        (visible) RutaBasic annotation, which normally corresponds to
        the tokens.
      </p>
    </div>
  </div>

  <div class="section" title="2.7.22.&nbsp;REGEXP"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.language.conditions.regexp">2.7.22.&nbsp;REGEXP</h3></div></div></div>
    
    <p>
      The REGEXP condition is fulfilled, if the given pattern matches on the
      matched annotation. However, if a string variable is given as the
      first
      argument, then the pattern is evaluated on the value of the
      variable.
      For more details on the syntax of regular
      expressions, take a
      look at
      the
      <a class="ulink" href="http://docs.oracle.com/javase/1.4.2/docs/api/java/util/regex/Pattern.html" target="_top">Java API</a>
      . By default the REGEXP condition is case-sensitive. To change this,
      add an optional boolean parameter, which is set to true. The regular expression is 
      initialized with the flags DOTALL and MULTILINE, and if the optional parameter is set to true, 
      then additionally with the flags CASE_INSENSITIVE and UNICODE_CASE.
    </p>
    <div class="section" title="2.7.22.1.&nbsp; Definition:"><div class="titlepage"><div><div><h4 class="title" id="d5e1516">2.7.22.1.&nbsp;
        <span class="bold"><strong>Definition:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">REGEXP((StringVariable,)? StringExpression(,BooleanExpression)?)</pre><p>
      </p>
    </div>
    <div class="section" title="2.7.22.2.&nbsp; Example:"><div class="titlepage"><div><div><h4 class="title" id="d5e1521">2.7.22.2.&nbsp;
        <span class="bold"><strong>Example:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">Keyword{REGEXP("..")-&gt;MARK(SmallKeyword)};</pre><p>
      </p>
      <p>
        A Keyword that only consists of two chars is annotated with a
        SmallKeyword annotation.
      </p>
    </div>
  </div>

  <div class="section" title="2.7.23.&nbsp;SCORE"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.language.conditions.score">2.7.23.&nbsp;SCORE</h3></div></div></div>
    
    <p>
      The SCORE condition evaluates the heuristic score of the matched
      annotation. This score is set or changed by the MARK action.
      The
      condition is fulfilled, if the score of the matched annotation is
      in a
      given interval. Optionally, the score can be stored in a
      variable.
    </p>
    <div class="section" title="2.7.23.1.&nbsp; Definition:"><div class="titlepage"><div><div><h4 class="title" id="d5e1530">2.7.23.1.&nbsp;
        <span class="bold"><strong>Definition:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">SCORE(NumberExpression,NumberExpression(,Variable)?)</pre><p>
      </p>
    </div>
    <div class="section" title="2.7.23.2.&nbsp; Example:"><div class="titlepage"><div><div><h4 class="title" id="d5e1535">2.7.23.2.&nbsp;
        <span class="bold"><strong>Example:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">MaybeHeadline{SCORE(40,100)-&gt;MARK(Headline)};</pre><p>
      </p>
      <p>
        An annotation of the type MaybeHeadline is annotated with
        Headline, if its score is between 40 and 100.
      </p>
    </div>
  </div>

  <div class="section" title="2.7.24.&nbsp;SIZE"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.language.conditions.size">2.7.24.&nbsp;SIZE</h3></div></div></div>
    
    <p>
      The SIZE contition counts the number of elements in the given
      list. By default, this condition always evaluates true. When an interval
      is passed, it evaluates true, if the counted number of list elements
      is within the interval. The counted number can be stored in an
      optionally passed numeral variable.
    </p>
    <div class="section" title="2.7.24.1.&nbsp; Definition:"><div class="titlepage"><div><div><h4 class="title" id="d5e1544">2.7.24.1.&nbsp;
        <span class="bold"><strong>Definition:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">SIZE(ListExpression(,NumberExpression,NumberExpression)?(,Variable)?)</pre><p>
      </p>
    </div>
    <div class="section" title="2.7.24.2.&nbsp; Example:"><div class="titlepage"><div><div><h4 class="title" id="d5e1549">2.7.24.2.&nbsp;
        <span class="bold"><strong>Example:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">Document{SIZE(list,4,10,var)};</pre><p>
      </p>
      <p>
        This rule fires, if the given list contains between 4 and 10
        elements. Additionally, the exact amount is stored in the variable
        <span class="quote">&#8220;<span class="quote">var</span>&#8221;</span>.
      </p>
    </div>
  </div>

  <div class="section" title="2.7.25.&nbsp;STARTSWITH"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.language.conditions.startswith">2.7.25.&nbsp;STARTSWITH</h3></div></div></div>
    
    <p>
      The STARTSWITH condition evaluates true, if an annotation of the
      given type starts exactly at the same position as the matched
      annotation. If a type list is given, the condition evaluates true, if
      the former is true for at least one of the given types in the list.
    </p>
    <div class="section" title="2.7.25.1.&nbsp; Definition:"><div class="titlepage"><div><div><h4 class="title" id="d5e1559">2.7.25.1.&nbsp;
        <span class="bold"><strong>Definition:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">STARTSWITH(Type|TypeListExpression)</pre><p>
      </p>
    </div>
    <div class="section" title="2.7.25.2.&nbsp; Example:"><div class="titlepage"><div><div><h4 class="title" id="d5e1564">2.7.25.2.&nbsp;
        <span class="bold"><strong>Example:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">Paragraph{STARTSWITH(SW)};</pre><p>
      </p>
      <p>
        Here, the rule matches on a Paragraph annotation, if it starts
        with small written word.
      </p>
    </div>
  </div>

  <div class="section" title="2.7.26.&nbsp;TOTALCOUNT"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.language.conditions.totalcount">2.7.26.&nbsp;TOTALCOUNT</h3></div></div></div>
    
    <p>
      The TOTALCOUNT condition counts the annotations of the passed
      type within the whole document and stores the amount in an optionally
      passed numerical variable. The condition evaluates true, if the
      amount
      is within the passed interval. If no interval is passed, the
      condition always evaluates true.
    </p>
    <div class="section" title="2.7.26.1.&nbsp; Definition:"><div class="titlepage"><div><div><h4 class="title" id="d5e1573">2.7.26.1.&nbsp;
        <span class="bold"><strong>Definition:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">TOTALCOUNT(Type(,NumberExpression,NumberExpression(,Variable)?)?)</pre><p>
      </p>
    </div>
    <div class="section" title="2.7.26.2.&nbsp; Example:"><div class="titlepage"><div><div><h4 class="title" id="d5e1578">2.7.26.2.&nbsp;
        <span class="bold"><strong>Example:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">Paragraph{TOTALCOUNT(Keyword,1,10,var)-&gt;MARK(KeywordParagraph)};</pre><p>
      </p>
      <p>
        Here, the amount of Keyword annotations within the whole
        document is calculated and stored in the variable 'var'. If one to
        ten Keywords were counted, the Paragraph is marked with a
        KeywordParagraph annotation.
      </p>
    </div>
  </div>

  <div class="section" title="2.7.27.&nbsp;VOTE"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.language.conditions.vote">2.7.27.&nbsp;VOTE</h3></div></div></div>
    
    <p>
      The VOTE condition counts the annotations of the given two types
      within the window of the matched annotation and evaluates true,
      if it
      finds more annotations of the first type.
    </p>
    <div class="section" title="2.7.27.1.&nbsp; Definition:"><div class="titlepage"><div><div><h4 class="title" id="d5e1587">2.7.27.1.&nbsp;
        <span class="bold"><strong>Definition:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">VOTE(TypeExpression,TypeExpression)</pre><p>
      </p>
    </div>
    <div class="section" title="2.7.27.2.&nbsp; Example:"><div class="titlepage"><div><div><h4 class="title" id="d5e1592">2.7.27.2.&nbsp;
        <span class="bold"><strong>Example:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">Paragraph{VOTE(FirstName,LastName)};</pre><p>
      </p>
      <p>
        Here, this rule fires, if a paragraph contains more firstnames
        than lastnames.
      </p>
    </div>
  </div>

</div>
  <div class="section" title="2.8.&nbsp;Actions"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.tools.ruta.language.actions">2.8.&nbsp;Actions</h2></div></div></div>
  

  <div class="section" title="2.8.1.&nbsp;ADD"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.language.actions.add">2.8.1.&nbsp;ADD</h3></div></div></div>
    
    <p>
      The ADD action adds all the elements of the passed
      RutaExpressions to a given list. For example, this expressions
      could be a string, an integer variable or a list. For a
      complete overview on UIMA Ruta expressions see
      <a class="xref" href="#ugr.tools.ruta.language.expressions" title="2.6.&nbsp;Expressions">Section&nbsp;2.6, &#8220;Expressions&#8221;</a>.
    </p>
    <div class="section" title="2.8.1.1.&nbsp; Definition:"><div class="titlepage"><div><div><h4 class="title" id="d5e1604">2.8.1.1.&nbsp;
        <span class="bold"><strong>Definition:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">ADD(ListVariable,(RutaExpression)+)</pre><p>
      </p>
    </div>
    <div class="section" title="2.8.1.2.&nbsp; Example:"><div class="titlepage"><div><div><h4 class="title" id="d5e1609">2.8.1.2.&nbsp;
        <span class="bold"><strong>Example:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">Document{-&gt;ADD(list, var)};</pre><p>
      </p>
      <p>
        In this example, the variable 'var' is added to the list
        'list'.
      </p>
    </div>
  </div>
  
  <div class="section" title="2.8.2.&nbsp;ADDFILTERTYPE"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.language.actions.addfiltertype">2.8.2.&nbsp;ADDFILTERTYPE</h3></div></div></div>
    
    <p>
      The ADDFILTERTYPE action adds its arguments to the list of filtered types, 
      which restrict the visibility of the rules.
    </p>
    <div class="section" title="2.8.2.1.&nbsp; Definition:"><div class="titlepage"><div><div><h4 class="title" id="d5e1618">2.8.2.1.&nbsp;
        <span class="bold"><strong>Definition:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">ADDFILTERTYPE(TypeExpression(,TypeExpression)*)</pre><p>
      </p>
    </div>
    <div class="section" title="2.8.2.2.&nbsp; Example:"><div class="titlepage"><div><div><h4 class="title" id="d5e1623">2.8.2.2.&nbsp;
        <span class="bold"><strong>Example:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">Document{-&gt;ADDFILTERTYPE(CW)};</pre><p>
      </p>
      <p>
        After applying this rule, capitalized words are invisible additionally to the previously filtered types.
      </p>
    </div>
  </div>
  
    <div class="section" title="2.8.3.&nbsp;ADDRETAINTYPE"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.language.actions.addretaintype">2.8.3.&nbsp;ADDRETAINTYPE</h3></div></div></div>
    
    <p>
      The ADDFILTERTYPE action adds its arguments to the list of retained types, 
      which extend the visibility of the rules.
    </p>
    <div class="section" title="2.8.3.1.&nbsp; Definition:"><div class="titlepage"><div><div><h4 class="title" id="d5e1632">2.8.3.1.&nbsp;
        <span class="bold"><strong>Definition:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">ADDRETAINTYPE(TypeExpression(,TypeExpression)*)</pre><p>
      </p>
    </div>
    <div class="section" title="2.8.3.2.&nbsp; Example:"><div class="titlepage"><div><div><h4 class="title" id="d5e1637">2.8.3.2.&nbsp;
        <span class="bold"><strong>Example:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">Document{-&gt;ADDRETAINTYPE(MARKUP)};</pre><p>
      </p>
      <p>
        After applying this rule, markup is visible additionally to the previously retained types.
      </p>
    </div>
  </div>
  
  
  <div class="section" title="2.8.4.&nbsp;ASSIGN"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.language.actions.assign">2.8.4.&nbsp;ASSIGN</h3></div></div></div>
    
    <p>
      The ASSIGN action assigns the value of the passed expression to
      a variable of the same type.
    </p>
    <div class="section" title="2.8.4.1.&nbsp; Definition:"><div class="titlepage"><div><div><h4 class="title" id="d5e1646">2.8.4.1.&nbsp;
        <span class="bold"><strong>Definition:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">ASSIGN(BooleanVariable,BooleanExpression)</pre><p>
      </p>
      <p>
        </p><pre class="programlisting">ASSIGN(NumberVariable,NumberExpression)</pre><p>
      </p>
      <p>
        </p><pre class="programlisting">ASSIGN(StringVariable,StringExpression)</pre><p>
      </p>
      <p>
        </p><pre class="programlisting">ASSIGN(TypeVariable,TypeExpression)</pre><p>
      </p>
    </div>
    <div class="section" title="2.8.4.2.&nbsp; Example:"><div class="titlepage"><div><div><h4 class="title" id="d5e1657">2.8.4.2.&nbsp;
        <span class="bold"><strong>Example:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">Document{-&gt;ASSIGN(amount, (amount/2))};</pre><p>
      </p>
      <p>
        In this example, the value of the variable 'amount' is divided in half.
      </p>
    </div>
  </div>

  <div class="section" title="2.8.5.&nbsp;CALL"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.language.actions.call">2.8.5.&nbsp;CALL</h3></div></div></div>
    
    <p>
      The CALL action initiates the execution of a different script
      file or script block. Currently, only complete script files are
      supported.
    </p>
    <div class="section" title="2.8.5.1.&nbsp; Definition:"><div class="titlepage"><div><div><h4 class="title" id="d5e1666">2.8.5.1.&nbsp;
        <span class="bold"><strong>Definition:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">CALL(DifferentFile)</pre><p>
      </p>
      <p>
        </p><pre class="programlisting">CALL(Block)</pre><p>
      </p>
    </div>
    <div class="section" title="2.8.5.2.&nbsp; Example:"><div class="titlepage"><div><div><h4 class="title" id="d5e1673">2.8.5.2.&nbsp;
        <span class="bold"><strong>Example:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">Document{-&gt;CALL(NamedEntities)};</pre><p>
      </p>
      <p>
        Here, a script 'NamedEntities' for named entity recognition is
        executed.
      </p>
    </div>
  </div>

  <div class="section" title="2.8.6.&nbsp;CLEAR"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.language.actions.clear">2.8.6.&nbsp;CLEAR</h3></div></div></div>
    
    <p>
      The CLEAR action removes all elements of the given list. If the list was initialized as it was declared, 
      then it is reset to its initial value.
    </p>
    <div class="section" title="2.8.6.1.&nbsp; Definition:"><div class="titlepage"><div><div><h4 class="title" id="d5e1682">2.8.6.1.&nbsp;
        <span class="bold"><strong>Definition:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">CLEAR(ListVariable)</pre><p>
      </p>
    </div>
    <div class="section" title="2.8.6.2.&nbsp; Example:"><div class="titlepage"><div><div><h4 class="title" id="d5e1687">2.8.6.2.&nbsp;
        <span class="bold"><strong>Example:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">Document{-&gt;CLEAR(SomeList)};</pre><p>
      </p>
      <p>
        This rule clears the list 'SomeList'.
      </p>
    </div>
  </div>

  <div class="section" title="2.8.7.&nbsp;COLOR"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.language.actions.color">2.8.7.&nbsp;COLOR</h3></div></div></div>
    
    <p>
      The COLOR action sets the color of an annotation type in the
      modified view, if the rule has fired. The background color is passed as
      the second parameter. The font color can be changed by passing a
      further color as a third parameter. The supported colors are: black, silver, gray,
      white, maroon, red, purple, fuchsia, green, lime, olive, yellow,
      navy, blue, aqua, lightblue, lightgreen, orange, pink, salmon, cyan,
      violet, tan, brown, white and mediumpurple.
    </p>
    <div class="section" title="2.8.7.1.&nbsp; Definition:"><div class="titlepage"><div><div><h4 class="title" id="d5e1696">2.8.7.1.&nbsp;
        <span class="bold"><strong>Definition:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">COLOR(TypeExpression,StringExpression(, StringExpression
          (, BooleanExpression)?)?)</pre><p>
      </p>
    </div>
    <div class="section" title="2.8.7.2.&nbsp; Example:"><div class="titlepage"><div><div><h4 class="title" id="d5e1701">2.8.7.2.&nbsp;
        <span class="bold"><strong>Example:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">Document{-&gt;COLOR(Headline, "red", "green", true)};</pre><p>
      </p>
      <p>
        This rule colors all Headline annotations in the modified view.
        Thereby, the background color is set to red, font color is set to green
        and all 'Headline' annotations are selected when opening the
        modified view.
      </p>
    </div>
  </div>

  <div class="section" title="2.8.8.&nbsp;CONFIGURE"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.language.actions.configure">2.8.8.&nbsp;CONFIGURE</h3></div></div></div>
    
    <p>
      The CONFIGURE action can be used to configure the analysis
      engine of the given namespace (first parameter). The parameters that
      should be configured with corresponding values are passed as
      name-value
      pairs.
    </p>
    <div class="section" title="2.8.8.1.&nbsp; Definition:"><div class="titlepage"><div><div><h4 class="title" id="d5e1710">2.8.8.1.&nbsp;
        <span class="bold"><strong>Definition:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">CONFIGURE(AnalysisEngine(,StringExpression = Expression)+)</pre><p>
      </p>
    </div>
     <div class="section" title="2.8.8.2.&nbsp; Example:"><div class="titlepage"><div><div><h4 class="title" id="d5e1715">2.8.8.2.&nbsp;
        <span class="bold"><strong>Example:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">ENGINE utils.HtmlAnnotator;
Document{-&gt;CONFIGURE(HtmlAnnotator, "onlyContent" = false)};</pre><p>
      </p>
      <p>
        The former rule changes the value of configuration parameter <span class="quote">&#8220;<span class="quote">onlyContent</span>&#8221;</span>
        to false and reconfigure the analysis engine.
      </p>
    </div>
  </div>

  <div class="section" title="2.8.9.&nbsp;CREATE"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.language.actions.create">2.8.9.&nbsp;CREATE</h3></div></div></div>
    
    <p>
      The CREATE action is similar to the MARK action. It also
      annotates the matched text fragments with a type annotation, but
      additionally assigns values to a chosen subset of the type's feature
      elements.
    </p>
    <div class="section" title="2.8.9.1.&nbsp; Definition:"><div class="titlepage"><div><div><h4 class="title" id="d5e1725">2.8.9.1.&nbsp;
        <span class="bold"><strong>Definition:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">CREATE(TypeExpression(,NumberExpression)*
                         (,StringExpression = Expression)+)</pre><p>
      </p>
    </div>
    <div class="section" title="2.8.9.2.&nbsp; Example:"><div class="titlepage"><div><div><h4 class="title" id="d5e1730">2.8.9.2.&nbsp;
        <span class="bold"><strong>Example:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">Paragraph{COUNT(ANY,0,10000,cnt)-&gt;CREATE(Headline,"size" = cnt)};</pre><p>
      </p>
      <p>
        This rule counts the number of tokens of type ANY in a
        Paragraph annotation and assigns the counted value to the int
        variable 'cnt'. If the counted number is between 0 and 10000, a
        Headline annotation is created for this Paragraph. Moreover, the
        feature named 'size' of Headline is set to the value of 'cnt'.
      </p>
    </div>
  </div>

  <div class="section" title="2.8.10.&nbsp;DEL"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.language.actions.del">2.8.10.&nbsp;DEL</h3></div></div></div>
    
    <p>
      The DEL action deletes the matched text fragments in the
      modified
      view.
    </p>
    <div class="section" title="2.8.10.1.&nbsp; Definition:"><div class="titlepage"><div><div><h4 class="title" id="d5e1739">2.8.10.1.&nbsp;
        <span class="bold"><strong>Definition:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">DEL</pre><p>
      </p>
    </div>
    <div class="section" title="2.8.10.2.&nbsp; Example:"><div class="titlepage"><div><div><h4 class="title" id="d5e1744">2.8.10.2.&nbsp;
        <span class="bold"><strong>Example:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">Name{-&gt;DEL};</pre><p>
      </p>
      <p>
        This rule deletes all text fragments that are annotated with a
        Name annotation.
      </p>
    </div>
  </div>

  <div class="section" title="2.8.11.&nbsp;DYNAMICANCHORING"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.language.actions.dynamicanchoring">2.8.11.&nbsp;DYNAMICANCHORING</h3></div></div></div>
    
    <p>
      The DYNAMICANCHORING action turns dynamic anchoring on or off
      (first parameter) and assigns the anchoring parameters penalty
      (second parameter) and factor (third parameter).
    </p>
    <div class="section" title="2.8.11.1.&nbsp; Definition:"><div class="titlepage"><div><div><h4 class="title" id="d5e1753">2.8.11.1.&nbsp;
        <span class="bold"><strong>Definition:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">DYNAMICANCHORING(BooleanExpression
              (,NumberExpression(,NumberExpression)?)?)</pre><p>
      </p>
    </div>
    <div class="section" title="2.8.11.2.&nbsp; Example:"><div class="titlepage"><div><div><h4 class="title" id="d5e1758">2.8.11.2.&nbsp;
        <span class="bold"><strong>Example:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">Document{-&gt;DYNAMICANCHORING(true)};</pre><p>
      </p>
      <p>
        The above mentioned example activates dynamic anchoring.
      </p>
    </div>
  </div>

  <div class="section" title="2.8.12.&nbsp;EXEC"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.language.actions.exec">2.8.12.&nbsp;EXEC</h3></div></div></div>
    
    <p>
      The EXEC action initiates the execution of a different script
      file or analysis engine on the complete input document, independent from
      the matched text and the current filtering settings. If the imported component (DifferentFile)
      refers to another script file, it is applied on a new representation of the document:
      the complete text of the original CAS with the default filtering
      settings of the UIMA Ruta analysis engine. If it refers to an 
      external analysis engine, then it is applied on the complete document. 
      The optional, first argument is is a string expression, which specifies the view the component should be applied on.
      The optional, third argument is a list of types, which should be reindexed by Ruta (not UIMA itself).
    </p>
    <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
    <p>
      Annotations created by the external analysis engine are not accessible for UIMA Ruta rules in the same script. 
      The types of these annotations need to be provided in the second argument in order to be visible to the Ruta rules.
    </p>
    </div>
    <div class="section" title="2.8.12.1.&nbsp; Definition:"><div class="titlepage"><div><div><h4 class="title" id="d5e1769">2.8.12.1.&nbsp;
        <span class="bold"><strong>Definition:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">EXEC((StringExpression,)? DifferentFile(, TypeListExpression)?)</pre><p>
      </p>
    </div>
    <div class="section" title="2.8.12.2.&nbsp; Example:"><div class="titlepage"><div><div><h4 class="title" id="d5e1774">2.8.12.2.&nbsp;
        <span class="bold"><strong>Example:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">ENGINE NamedEntities;
Document{-&gt;EXEC(NamedEntities, {Person, Location})};</pre><p>
      </p>
      <p>
        Here, an analysis engine for named entity recognition is
        executed once on the complete document and the annotations of the types Person and Location (and all subtypes) 
        are reindexed in UIMA Ruta. Without this list of types, the annotations are added to the CAS, but cannot be accessed by Ruta rules.
      </p>
    </div>
  </div>
  <div class="section" title="2.8.13.&nbsp;FILL"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.language.actions.fill">2.8.13.&nbsp;FILL</h3></div></div></div>
    
    <p>
      The FILL action fills a chosen subset of the given type's
      feature elements.
    </p>
    <div class="section" title="2.8.13.1.&nbsp; Definition:"><div class="titlepage"><div><div><h4 class="title" id="d5e1783">2.8.13.1.&nbsp;
        <span class="bold"><strong>Definition:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">FILL(TypeExpression(,StringExpression = Expression)+)</pre><p>
      </p>
    </div>
    <div class="section" title="2.8.13.2.&nbsp; Example:"><div class="titlepage"><div><div><h4 class="title" id="d5e1788">2.8.13.2.&nbsp;
        <span class="bold"><strong>Example:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">Headline{COUNT(ANY,0,10000,tokenCount)
          -&gt;FILL(Headline,"size" = tokenCount)};</pre><p>
      </p>
      <p>
        Here, the number of tokens within an Headline annotation is
        counted and stored in variable 'tokenCount'. If the number of tokens
        is within the interval [0;10000], the FILL action fills the
        Headline's feature 'size' with the value of 'tokenCount'.
      </p>
    </div>
  </div>

  <div class="section" title="2.8.14.&nbsp;FILTERTYPE"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.language.actions.filtertype">2.8.14.&nbsp;FILTERTYPE</h3></div></div></div>
    
    <p>
      This action filters the given types of annotations. They are now
      ignored by rules. Expressions are not yet supported. 
      This action is related to RETAINTYPE (see <a class="xref" href="#ugr.tools.ruta.language.actions.retaintype" title="2.8.35.&nbsp;RETAINTYPE">Section&nbsp;2.8.35, &#8220;RETAINTYPE&#8221;</a>).
    </p>
    <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>    
      <p>
        The visibility of types is calculated using three lists: 
        A list <span class="quote">&#8220;<span class="quote">default</span>&#8221;</span> for the initially filtered types, 
        which is specified in the configuration parameters of the analysis engine, the list <span class="quote">&#8220;<span class="quote">filtered</span>&#8221;</span>, which is 
        specified by the FILTERTYPE action, and the list <span class="quote">&#8220;<span class="quote">retained</span>&#8221;</span>, which is specified by the RETAINTYPE action.
        For determining the actual visibility of types, list <span class="quote">&#8220;<span class="quote">filtered</span>&#8221;</span> is added to list <span class="quote">&#8220;<span class="quote">default</span>&#8221;</span> 
        and then all elements of list <span class="quote">&#8220;<span class="quote">retained</span>&#8221;</span> are removed. The annotations of the types in the resulting list are not visible.
        Please note that the actions FILTERTYPE and RETAINTYPE replace all elements of the respective lists and that RETAINTYPE 
        overrides FILTERTYPE.
      </p>
    </div>
    <div class="section" title="2.8.14.1.&nbsp; Definition:"><div class="titlepage"><div><div><h4 class="title" id="d5e1806">2.8.14.1.&nbsp;
        <span class="bold"><strong>Definition:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">FILTERTYPE((TypeExpression(,TypeExpression)*))?</pre><p>
      </p>
    </div>
    <div class="section" title="2.8.14.2.&nbsp; Example:"><div class="titlepage"><div><div><h4 class="title" id="d5e1811">2.8.14.2.&nbsp;
        <span class="bold"><strong>Example:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">Document{-&gt;FILTERTYPE(SW)};</pre><p>
      </p>
      <p>
        This rule filters all small written words in the input
        document. They are further ignored by every rule.
      </p>
      <p>
        </p><pre class="programlisting">Document{-&gt;FILTERTYPE};</pre><p>
      </p>
      <p>
        Here, the the action (without parentheses) specifies that no additional types should be filtered.
      </p>
    </div>
  </div>

  <div class="section" title="2.8.15.&nbsp;GATHER"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.language.actions.gather">2.8.15.&nbsp;GATHER</h3></div></div></div>
    
    <p>
      This action creates a complex structure: an annotation with
      features. The optionally passed indexes (NumberExpressions after the
      TypeExpression) can be used to create an annotation that spans the
      matched information of several rule elements. The features are
      collected using the indexes of the rule elements of the complete
      rule.
    </p>
    <div class="section" title="2.8.15.1.&nbsp; Definition:"><div class="titlepage"><div><div><h4 class="title" id="d5e1823">2.8.15.1.&nbsp;
        <span class="bold"><strong>Definition:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">GATHER(TypeExpression(,NumberExpression)*
          (,StringExpression = NumberExpression)+)</pre><p>
      </p>
    </div>
    <div class="section" title="2.8.15.2.&nbsp; Example:"><div class="titlepage"><div><div><h4 class="title" id="d5e1828">2.8.15.2.&nbsp;
        <span class="bold"><strong>Example:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">DECLARE Annotation A;
DECLARE Annotation B;
DECLARE Annotation C(Annotation a, Annotation b);
W{REGEXP("A")-&gt;MARK(A)};
W{REGEXP("B")-&gt;MARK(B)};
A B{-&gt; GATHER(C, 1, 2, "a" = 1, "b" = 2)};</pre><p>
      </p>
      <p>
        Two annotations A and B are declared and annotated. The last
        rule creates an annotation C spanning the elements A (index 1 since
        it is the first rule element) and B (index 2) with its features 'a'
        set to annotation A (again index 1) and 'b' set to annotation B
        (again index 2).
      </p>
    </div>
  </div>

  <div class="section" title="2.8.16.&nbsp;GET"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.language.actions.get">2.8.16.&nbsp;GET</h3></div></div></div>
    
    <p>
      The GET action retrieves an element of the given list dependent on a
      given strategy.
      </p><div class="table"><a name="d5e1837"></a><p class="title"><b>Table&nbsp;2.3.&nbsp;Currently supported strategies</b></p><div class="table-contents">
        
        <table summary="Currently supported strategies" style="border-collapse: collapse;border-top: 0.5pt solid black; border-bottom: 0.5pt solid black; border-left: 0.5pt solid black; border-right: 0.5pt solid black; "><colgroup><col><col></colgroup><thead><tr><th style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; " align="left">Strategy</th><th style="border-bottom: 0.5pt solid black; " align="left">Functionality</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid black; " align="left">dominant</td><td style="" align="left">finds the most occurring element</td></tr></tbody></table>
      </div></div><p><br class="table-break">
    </p>
    <div class="section" title="2.8.16.1.&nbsp; Definition:"><div class="titlepage"><div><div><h4 class="title" id="d5e1848">2.8.16.1.&nbsp;
        <span class="bold"><strong>Definition:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">GET(ListExpression, Variable, StringExpression)</pre><p>
      </p>
    </div>
    <div class="section" title="2.8.16.2.&nbsp; Example:"><div class="titlepage"><div><div><h4 class="title" id="d5e1853">2.8.16.2.&nbsp;
        <span class="bold"><strong>Example:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">Document{-&gt;GET(list, var, "dominant")};</pre><p>
      </p>
      <p>
        In this example, the element of the list 'list' that occurs
        most is stored in the variable 'var'.
      </p>
    </div>
  </div>

  <div class="section" title="2.8.17.&nbsp;GETFEATURE"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.language.actions.getfeature">2.8.17.&nbsp;GETFEATURE</h3></div></div></div>
    
    <p>
      The GETFEATURE action stores the value of the matched
      annotation's feature (first paramter) in the given variable (second
      parameter).
    </p>
    <div class="section" title="2.8.17.1.&nbsp; Definition:"><div class="titlepage"><div><div><h4 class="title" id="d5e1862">2.8.17.1.&nbsp;
        <span class="bold"><strong>Definition:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">GETFEATURE(StringExpression, Variable)</pre><p>
      </p>
    </div>
    <div class="section" title="2.8.17.2.&nbsp; Example:"><div class="titlepage"><div><div><h4 class="title" id="d5e1867">2.8.17.2.&nbsp;
        <span class="bold"><strong>Example:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">Document{-&gt;GETFEATURE("language", stringVar)};</pre><p>
      </p>
      <p>
        In this example, variable 'stringVar' will contain the value of
        the feature 'language'.
      </p>
    </div>
  </div>

  <div class="section" title="2.8.18.&nbsp;GETLIST"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.language.actions.getlist">2.8.18.&nbsp;GETLIST</h3></div></div></div>
    
    <p>
      This action retrieves a list of types dependent on a given strategy.
      </p><div class="table"><a name="d5e1876"></a><p class="title"><b>Table&nbsp;2.4.&nbsp;Currently supported strategies</b></p><div class="table-contents">
        
        <table summary="Currently supported strategies" style="border-collapse: collapse;border-top: 0.5pt solid black; border-bottom: 0.5pt solid black; border-left: 0.5pt solid black; border-right: 0.5pt solid black; "><colgroup><col><col></colgroup><thead><tr><th style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; " align="left">Strategy</th><th style="border-bottom: 0.5pt solid black; " align="left">Functionality</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; " align="left">Types</td><td style="border-bottom: 0.5pt solid black; " align="left">get all types within the matched annotation</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; " align="left">Types:End</td><td style="border-bottom: 0.5pt solid black; " align="left">get all types that end at the same offset as the matched
                annotation
              </td></tr><tr><td style="border-right: 0.5pt solid black; " align="left">Types:Begin</td><td style="" align="left">get all types that start at the same offset as the
                matched
                annotation
              </td></tr></tbody></table>
      </div></div><p><br class="table-break">
    </p>
    <div class="section" title="2.8.18.1.&nbsp; Definition:"><div class="titlepage"><div><div><h4 class="title" id="d5e1893">2.8.18.1.&nbsp;
        <span class="bold"><strong>Definition:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">GETLIST(ListVariable, StringExpression)</pre><p>
      </p>
    </div>
    <div class="section" title="2.8.18.2.&nbsp; Example:"><div class="titlepage"><div><div><h4 class="title" id="d5e1898">2.8.18.2.&nbsp;
        <span class="bold"><strong>Example:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">Document{-&gt;GETLIST(list, "Types")};</pre><p>
      </p>
      <p>
        Here, a list of all types within the document is created and
        assigned to list variable 'list'.
      </p>
    </div>
  </div>

  <div class="section" title="2.8.19.&nbsp;GREEDYANCHORING"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.language.actions.greedyanchoring">2.8.19.&nbsp;GREEDYANCHORING</h3></div></div></div>
    
    <p>
      The GREEDYANCHORING action turns greedy anchoring on or off. 
      If the first parameter is set to true, then start positions already matched by the same rule element will be ignored. This situation 
      occurs mostly for rules that start with a quantifier. The second optional parameter activates greedy acnhoring for the complete rule.
      Later rule matches are only possible after previous matches.
    </p>
    <div class="section" title="2.8.19.1.&nbsp; Definition:"><div class="titlepage"><div><div><h4 class="title" id="d5e1907">2.8.19.1.&nbsp;
        <span class="bold"><strong>Definition:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">GREEDYANCHORING(BooleanExpression(,BooleanExpression)?)</pre><p>
      </p>
    </div>
    <div class="section" title="2.8.19.2.&nbsp; Example:"><div class="titlepage"><div><div><h4 class="title" id="d5e1912">2.8.19.2.&nbsp;
        <span class="bold"><strong>Example:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">Document{-&gt;GREEDYANCHORING(true, true)};
        ANY+;
        CW CW;</pre><p>
      </p>
      <p>
        The above mentioned example activates dynamic anchoring and the second rule will then only match once 
        since the next positions, e.g., the second token, are already covered by the first attempt.
        The third rule will not match on capitalized word that have benn already considered by previous matches of the rule.
      </p>
    </div>
  </div>

  <div class="section" title="2.8.20.&nbsp;LOG"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.language.actions.log">2.8.20.&nbsp;LOG</h3></div></div></div>
    
    <p>
      The LOG action writes a log message.
    </p>
    <div class="section" title="2.8.20.1.&nbsp; Definition:"><div class="titlepage"><div><div><h4 class="title" id="d5e1921">2.8.20.1.&nbsp;
        <span class="bold"><strong>Definition:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">LOG(StringExpression)</pre><p>
      </p>
    </div>
    <div class="section" title="2.8.20.2.&nbsp; Example:"><div class="titlepage"><div><div><h4 class="title" id="d5e1926">2.8.20.2.&nbsp;
        <span class="bold"><strong>Example:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">Document{-&gt;LOG("processed")};</pre><p>
      </p>
      <p>
        This rule writes a log message with the string "processed".
      </p>
    </div>
  </div>

  <div class="section" title="2.8.21.&nbsp;MARK"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.language.actions.mark">2.8.21.&nbsp;MARK</h3></div></div></div>
    
    <p>
      The MARK action is the most important action in the UIMA Ruta
      system. It creates a new annotation of the given type. The optionally
      passed indexes (NumberExpressions after the TypeExpression) can be
      used to create an annotation that spanns the matched information of
      several rule elements.
    </p>
    <div class="section" title="2.8.21.1.&nbsp; Definition:"><div class="titlepage"><div><div><h4 class="title" id="d5e1935">2.8.21.1.&nbsp;
        <span class="bold"><strong>Definition:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">MARK(TypeExpression(,NumberExpression)*)</pre><p>
      </p>
    </div>
    <div class="section" title="2.8.21.2.&nbsp; Example:"><div class="titlepage"><div><div><h4 class="title" id="d5e1940">2.8.21.2.&nbsp;
        <span class="bold"><strong>Example:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">Freeline Paragraph{-&gt;MARK(ParagraphAfterFreeline,1,2)};</pre><p>
      </p>
      <p>
        This rule matches on a free line followed by a Paragraph
        annotation and annotates both in a single ParagraphAfterFreeline
        annotation. The two numerical expressions at the end of the mark
        action state that the matched text of the first and the second rule
        elements are joined to create the boundaries of the new annotation.
      </p>
    </div>
  </div>

  <div class="section" title="2.8.22.&nbsp;MARKFAST"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.language.actions.markfast">2.8.22.&nbsp;MARKFAST</h3></div></div></div>
    
    <p>
      The MARKFAST action creates annotations of the given type (first
      parameter), if an element of the passed list (second parameter) occurs
      within the window of the matched annotation. Thereby, the created
      annotation does not cover the whole matched annotation. Instead, it
      only covers the text of the found occurrence. The third parameter is
      optional. It defines, whether the MARKFAST action should ignore the case,
      whereby its default value is false. The optional fourth parameter
      specifies a character threshold for the ignorence of the case. It is
      only relevant, if the ignore-case value is set to true. The last
      parameter is set to true by default and specifies whether whitespaces
      in the entries of the dictionary should be ignored. For more
      information on lists see
      <a class="xref" href="#ugr.tools.ruta.language.declarations.ressource" title="2.5.3.&nbsp;Resources">Section&nbsp;2.5.3, &#8220;Resources&#8221;</a>. 
      Additionally to external word lists, string lists variables can be
      used.
    </p>
    <div class="section" title="2.8.22.1.&nbsp; Definition:"><div class="titlepage"><div><div><h4 class="title" id="d5e1950">2.8.22.1.&nbsp;
        <span class="bold"><strong>Definition:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">MARKFAST(TypeExpression,ListExpression(,BooleanExpression
          (,NumberExpression,(BooleanExpression)?)?)?)</pre><p>
        </p><pre class="programlisting">MARKFAST(TypeExpression,StringListExpression(,BooleanExpression
          (,NumberExpression,(BooleanExpression)?)?)?)</pre><p>
      </p>
    </div>
    <div class="section" title="2.8.22.2.&nbsp; Example:"><div class="titlepage"><div><div><h4 class="title" id="d5e1956">2.8.22.2.&nbsp;
        <span class="bold"><strong>Example:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">WORDLIST FirstNameList = 'FirstNames.txt';
DECLARE FirstName;
Document{-&gt; MARKFAST(FirstName, FirstNameList, true, 2)};</pre><p>
      </p>
      <p>
        This rule annotates all first names listed in the list
        'FirstNameList' within the document and ignores the case, if the
        length of the word
        is greater than 2.
      </p>
    </div>
  </div>

  <div class="section" title="2.8.23.&nbsp;MARKFIRST"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.language.actions.markfirst">2.8.23.&nbsp;MARKFIRST</h3></div></div></div>
    
    <p>
      The MARKFIRST action annotates the first token (basic annotation) of the matched
      annotation with the given type.
    </p>
    <div class="section" title="2.8.23.1.&nbsp; Definition:"><div class="titlepage"><div><div><h4 class="title" id="d5e1965">2.8.23.1.&nbsp;
        <span class="bold"><strong>Definition:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">MARKFIRST(TypeExpression)</pre><p>
      </p>
    </div>
    <div class="section" title="2.8.23.2.&nbsp; Example:"><div class="titlepage"><div><div><h4 class="title" id="d5e1970">2.8.23.2.&nbsp;
        <span class="bold"><strong>Example:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">Document{-&gt;MARKFIRST(First)};</pre><p>
      </p>
      <p>
        This rule annotates the first token of the document with the
        annotation First.
      </p>
    </div>
  </div>

  <div class="section" title="2.8.24.&nbsp;MARKLAST"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.language.actions.marklast">2.8.24.&nbsp;MARKLAST</h3></div></div></div>
    
    <p>
      The MARKLAST action annotates the last token of the matched
      annotation with the given type.
    </p>
    <div class="section" title="2.8.24.1.&nbsp; Definition:"><div class="titlepage"><div><div><h4 class="title" id="d5e1979">2.8.24.1.&nbsp;
        <span class="bold"><strong>Definition:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">MARKLAST(TypeExpression)</pre><p>
      </p>
    </div>
    <div class="section" title="2.8.24.2.&nbsp; Example:"><div class="titlepage"><div><div><h4 class="title" id="d5e1984">2.8.24.2.&nbsp;
        <span class="bold"><strong>Example:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">Document{-&gt;MARKLAST(Last)};</pre><p>
      </p>
      <p>
        This rule annotates the last token of the document with the
        annotation Last.
      </p>
    </div>
  </div>

  <div class="section" title="2.8.25.&nbsp;MARKONCE"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.language.actions.markonce">2.8.25.&nbsp;MARKONCE</h3></div></div></div>
    
    <p>
      The MARKONCE action has the same functionality as the MARK
      action, but creates a new annotation only, 
      if each part of the matched annotation is not yet part of the given type.
    </p>
    <div class="section" title="2.8.25.1.&nbsp; Definition:"><div class="titlepage"><div><div><h4 class="title" id="d5e1993">2.8.25.1.&nbsp;
        <span class="bold"><strong>Definition:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">MARKONCE(NumberExpression,TypeExpression(,NumberExpression)*)</pre><p>
      </p>
    </div>
    <div class="section" title="2.8.25.2.&nbsp; Example:"><div class="titlepage"><div><div><h4 class="title" id="d5e1998">2.8.25.2.&nbsp;
        <span class="bold"><strong>Example:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">Freeline Paragraph{-&gt;MARKONCE(ParagraphAfterFreeline,1,2)};</pre><p>
      </p>
      <p>
        This rule matches on a free line followed by a Paragraph and
        annotates both in a single ParagraphAfterFreeline annotation, if no part 
        is not already annotated with ParagraphAfterFreeline annotation. The
        two numerical expressions at the end of the MARKONCE action state
        that the matched text of the first and the second rule elements are
        joined to create the boundaries of the new annotation.
      </p>
    </div>
  </div>

  <div class="section" title="2.8.26.&nbsp;MARKSCORE"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.language.actions.markscore">2.8.26.&nbsp;MARKSCORE</h3></div></div></div>
    
    <p>
      The MARKSCORE action is similar to the MARK action. It also creates a
      new annotation of the given type, but only if it is not yet existing.
      The optionally passed indexes (parameters after the TypeExpression)
      can be used to create an annotation that spanns the matched
      information of several rule elements. Additionally, a score value
      (first parameter) is added to the heuristic score value of the
      annotation. For more information on heuristic scores see
      <a class="xref" href="#ugr.tools.ruta.language.score" title="2.12.&nbsp;Heuristic extraction using scoring rules">Section&nbsp;2.12, &#8220;Heuristic extraction using scoring rules&#8221;</a>
      .
    </p>
    <div class="section" title="2.8.26.1.&nbsp; Definition:"><div class="titlepage"><div><div><h4 class="title" id="d5e2008">2.8.26.1.&nbsp;
        <span class="bold"><strong>Definition:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">MARKSCORE(NumberExpression,TypeExpression(,NumberExpression)*)</pre><p>
      </p>
    </div>
    <div class="section" title="2.8.26.2.&nbsp; Example:"><div class="titlepage"><div><div><h4 class="title" id="d5e2013">2.8.26.2.&nbsp;
        <span class="bold"><strong>Example:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">Freeline Paragraph{-&gt;MARKSCORE(10,ParagraphAfterFreeline,1,2)};</pre><p>
      </p>
      <p>
        This rule matches on a free line followed by a paragraph and
        annotates both in a single ParagraphAfterFreeline annotation. The
        two number expressions at the end of the mark action indicate that
        the matched text of the first and the second rule elements are
        joined to create the boundaries of the new annotation. Additionally,
        the score '10' is added to the heuristic threshold of this
        annotation.
      </p>
    </div>
  </div>

  <div class="section" title="2.8.27.&nbsp;MARKTABLE"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.language.actions.marktable">2.8.27.&nbsp;MARKTABLE</h3></div></div></div>
    
    <p>
      The MARKTABLE action creates annotations of the given type (first
      parameter), if an element of the given column (second parameter) of a
      passed table (third parameter) occures within the window of the
      matched annotation. Thereby, the created annotation does not cover the
      whole matched annotation. Instead, it only covers the text of the
      found occurrence. Optionally the MARKTABLE action is able to assign
      entries of the given table to features of the created annotation.
      For
      more information on tables see
      <a class="xref" href="#ugr.tools.ruta.language.declarations.ressource" title="2.5.3.&nbsp;Resources">Section&nbsp;2.5.3, &#8220;Resources&#8221;</a>. Additionally, several configuration parameters are possible. (See example.)
    </p>
    <div class="section" title="2.8.27.1.&nbsp; Definition:"><div class="titlepage"><div><div><h4 class="title" id="d5e2023">2.8.27.1.&nbsp;
        <span class="bold"><strong>Definition:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">MARKTABLE(TypeExpression, NumberExpression, TableExpression 
          (,BooleanExpression, NumberExpression, 
          StringExpression, NumberExpression)? 
          (,StringExpression = NumberExpression)+)</pre><p>
      </p>
    </div>
    <div class="section" title="2.8.27.2.&nbsp; Example:"><div class="titlepage"><div><div><h4 class="title" id="d5e2028">2.8.27.2.&nbsp;
        <span class="bold"><strong>Example:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">WORDTABLE TestTable = 'TestTable.csv';
DECLARE Annotation Struct(STRING first);
Document{-&gt; MARKTABLE(Struct, 1, TestTable, 
    true, 4, ".,-", 2, "first" = 2)};</pre><p>
      </p>
      <p>
        In this example, the whole document is searched for all
        occurrences of the entries of the first column of the given table
        'TestTable'. For each occurrence, an annotation of the type Struct is
        created and its feature 'first' is filled with the entry of the
        second column. Moreover, the case of the word is ignored if the
        length of the word exceeds 4. Additionally, the chars '.', ',' and
        '-' are ignored, but maximally two of them.
      </p>
    </div>
  </div>

  <div class="section" title="2.8.28.&nbsp;MATCHEDTEXT"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.language.actions.matchedtext">2.8.28.&nbsp;MATCHEDTEXT</h3></div></div></div>
    
    <p>
      The MATCHEDTEXT action saves the text of the matched annotation
      in a passed String variable. The optionally passed indexes can be
      used to match the text of several rule elements.
    </p>
    <div class="section" title="2.8.28.1.&nbsp; Definition:"><div class="titlepage"><div><div><h4 class="title" id="d5e2037">2.8.28.1.&nbsp;
        <span class="bold"><strong>Definition:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">MATCHEDTEXT(StringVariable(,NumberExpression)*)</pre><p>
      </p>
    </div>
    <div class="section" title="2.8.28.2.&nbsp; Example:"><div class="titlepage"><div><div><h4 class="title" id="d5e2042">2.8.28.2.&nbsp;
        <span class="bold"><strong>Example:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">Headline Paragraph{-&gt;MATCHEDTEXT(stringVariable,1,2)};</pre><p>
      </p>
      <p>
        The text covered by the Headline (rule element 1) and the
        Paragraph (rule element 2) annotation is saved in variable
        'stringVariable'.
      </p>
    </div>
  </div>

  <div class="section" title="2.8.29.&nbsp;MERGE"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.language.actions.merge">2.8.29.&nbsp;MERGE</h3></div></div></div>
    
    <p>
      The MERGE action merges a number of given lists. The first
      parameter defines, if the merge is done as intersection (false) or as
      union (true). The second parameter is the list variable that will
      contain the result.
    </p>
    <div class="section" title="2.8.29.1.&nbsp; Definition:"><div class="titlepage"><div><div><h4 class="title" id="d5e2051">2.8.29.1.&nbsp;
        <span class="bold"><strong>Definition:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">MERGE(BooleanExpression, ListVariable, ListExpression, (ListExpression)+)</pre><p>
      </p>
    </div>
    <div class="section" title="2.8.29.2.&nbsp; Example:"><div class="titlepage"><div><div><h4 class="title" id="d5e2056">2.8.29.2.&nbsp;
        <span class="bold"><strong>Example:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">Document{-&gt;MERGE(false, listVar, list1, list2, list3)};</pre><p>
      </p>
      <p>
        The elements that occur in all three lists will be placed in
        the list 'listVar'.
      </p>
    </div>
  </div>

  <div class="section" title="2.8.30.&nbsp;REMOVE"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.language.actions.remove">2.8.30.&nbsp;REMOVE</h3></div></div></div>
    
    <p>
      The REMOVE action removes lists or single values from a given
      list.
    </p>
    <div class="section" title="2.8.30.1.&nbsp; Definition:"><div class="titlepage"><div><div><h4 class="title" id="d5e2065">2.8.30.1.&nbsp;
        <span class="bold"><strong>Definition:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">REMOVE(ListVariable,(Argument)+)</pre><p>
      </p>
    </div>
    <div class="section" title="2.8.30.2.&nbsp; Example:"><div class="titlepage"><div><div><h4 class="title" id="d5e2070">2.8.30.2.&nbsp;
        <span class="bold"><strong>Example:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">Document{-&gt;REMOVE(list, var)};</pre><p>
      </p>
      <p>
        In this example, the variable 'var' is removed from the list
        'list'.
      </p>
    </div>
  </div>

  <div class="section" title="2.8.31.&nbsp;REMOVEDUPLICATE"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.language.actions.removeduplicate">2.8.31.&nbsp;REMOVEDUPLICATE</h3></div></div></div>
    
    <p>
      This action removes all duplicates within a given list.
    </p>
    <div class="section" title="2.8.31.1.&nbsp; Definition:"><div class="titlepage"><div><div><h4 class="title" id="d5e2079">2.8.31.1.&nbsp;
        <span class="bold"><strong>Definition:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">REMOVEDUPLICATE(ListVariable)</pre><p>
      </p>
    </div>
    <div class="section" title="2.8.31.2.&nbsp; Example:"><div class="titlepage"><div><div><h4 class="title" id="d5e2084">2.8.31.2.&nbsp;
        <span class="bold"><strong>Example:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">Document{-&gt;REMOVEDUPLICATE(list)};</pre><p>
      </p>
      <p>
        Here, all duplicates within the list 'list' are removed.
      </p>
    </div>
  </div>

  <div class="section" title="2.8.32.&nbsp;REMOVEFILTERTYPE"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.language.actions.removefiltertype">2.8.32.&nbsp;REMOVEFILTERTYPE</h3></div></div></div>
    
    <p>
      The REMOVEFILTERTYPE action removes its arguments from the list of filtered types, 
      which restrict the visibility of the rules.
    </p>
    <div class="section" title="2.8.32.1.&nbsp; Definition:"><div class="titlepage"><div><div><h4 class="title" id="d5e2093">2.8.32.1.&nbsp;
        <span class="bold"><strong>Definition:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">REMOVEFILTERTYPE(TypeExpression(,TypeExpression)*)</pre><p>
      </p>
    </div>
    <div class="section" title="2.8.32.2.&nbsp; Example:"><div class="titlepage"><div><div><h4 class="title" id="d5e2098">2.8.32.2.&nbsp;
        <span class="bold"><strong>Example:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">Document{-&gt;REMOVEFILTERTYPE(W)};</pre><p>
      </p>
      <p>
        After applying this rule, words are possibly visible again depending on the current filtering settings.
      </p>
    </div>
  </div>
  
    <div class="section" title="2.8.33.&nbsp;REMOVERETAINTYPE"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.language.actions.removeretaintype">2.8.33.&nbsp;REMOVERETAINTYPE</h3></div></div></div>
    
    <p>
      The REMOVEFILTERTYPE action removes its arguments from the list of retained types, 
      which extend the visibility of the rules.
    </p>
    <div class="section" title="2.8.33.1.&nbsp; Definition:"><div class="titlepage"><div><div><h4 class="title" id="d5e2107">2.8.33.1.&nbsp;
        <span class="bold"><strong>Definition:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">REMOVERETAINTYPE(TypeExpression(,TypeExpression)*)</pre><p>
      </p>
    </div>
    <div class="section" title="2.8.33.2.&nbsp; Example:"><div class="titlepage"><div><div><h4 class="title" id="d5e2112">2.8.33.2.&nbsp;
        <span class="bold"><strong>Example:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">Document{-&gt;REMOVERETAINTYPE(W)};</pre><p>
      </p>
      <p>
        After applying this rule, words are possibly not visible anymore depending on the current filtering settings.
      </p>
    </div>
  </div>


  <div class="section" title="2.8.34.&nbsp;REPLACE"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.language.actions.replace">2.8.34.&nbsp;REPLACE</h3></div></div></div>
    
    <p>
      The REPLACE action replaces the text of all matched annotations with
      the given StringExpression. It remembers the modification for the
      matched annotations and shows them in the modified view (see
      <a class="xref" href="#ugr.tools.ruta.language.modification" title="2.13.&nbsp;Modification">Section&nbsp;2.13, &#8220;Modification&#8221;</a>).
    </p>
    <div class="section" title="2.8.34.1.&nbsp; Definition:"><div class="titlepage"><div><div><h4 class="title" id="d5e2122">2.8.34.1.&nbsp;
        <span class="bold"><strong>Definition:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">REPLACE(StringExpression)</pre><p>
      </p>
    </div>
    <div class="section" title="2.8.34.2.&nbsp; Example:"><div class="titlepage"><div><div><h4 class="title" id="d5e2127">2.8.34.2.&nbsp;
        <span class="bold"><strong>Example:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">FirstName{-&gt;REPLACE("first name")};</pre><p>
      </p>
      <p>
        This rule replaces all first names with the string 'first
        name'.
      </p>
    </div>
  </div>

  <div class="section" title="2.8.35.&nbsp;RETAINTYPE"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.language.actions.retaintype">2.8.35.&nbsp;RETAINTYPE</h3></div></div></div>
    
    <p>
      The RETAINTYPE action retains the given types. This means that they
      are now not ignored by rules. This action is related to
      FILTERTYPE (see <a class="xref" href="#ugr.tools.ruta.language.actions.filtertype" title="2.8.14.&nbsp;FILTERTYPE">Section&nbsp;2.8.14, &#8220;FILTERTYPE&#8221;</a>).
    </p>
    <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>    
      <p>
        The visibility of types is calculated using three lists: 
        A list <span class="quote">&#8220;<span class="quote">default</span>&#8221;</span> for the initially filtered types, 
        which is specified in the configuration parameters of the analysis engine, the list <span class="quote">&#8220;<span class="quote">filtered</span>&#8221;</span>, which is 
        specified by the FILTERTYPE action, and the list <span class="quote">&#8220;<span class="quote">retained</span>&#8221;</span>, which is specified by the RETAINTYPE action.
        For determining the actual visibility of types, list <span class="quote">&#8220;<span class="quote">filtered</span>&#8221;</span> is added to list <span class="quote">&#8220;<span class="quote">default</span>&#8221;</span> 
        and then all elements of list <span class="quote">&#8220;<span class="quote">retained</span>&#8221;</span> are removed. The annotations of the types in the resulting list are not visible.
        Please note that the actions FILTERTYPE and RETAINTYPE replace all elements of the respective lists and that RETAINTYPE 
        overrides FILTERTYPE.
      </p>
    </div>
    <div class="section" title="2.8.35.1.&nbsp; Definition:"><div class="titlepage"><div><div><h4 class="title" id="d5e2145">2.8.35.1.&nbsp;
        <span class="bold"><strong>Definition:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">RETAINTYPE((TypeExpression(,TypeExpression)*))?</pre><p>
      </p>
    </div>
    <div class="section" title="2.8.35.2.&nbsp; Example:"><div class="titlepage"><div><div><h4 class="title" id="d5e2150">2.8.35.2.&nbsp;
        <span class="bold"><strong>Example:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">Document{-&gt;RETAINTYPE(SPACE)};</pre><p>
      </p>
      <p>
        Here, all spaces are retained and can be matched by rules.
      </p>
      <p>
        </p><pre class="programlisting">Document{-&gt;RETAINTYPE};</pre><p>
      </p>
      <p>
        Here, the the action (without parentheses) specifies that no types should be retained.
      </p>
    </div>
  </div>

  <div class="section" title="2.8.36.&nbsp;SETFEATURE"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.language.actions.setfeature">2.8.36.&nbsp;SETFEATURE</h3></div></div></div>
    
    <p>
      The SETFEATURE action sets the value of a feature of the
      matched
      complex structure.
    </p>
    <div class="section" title="2.8.36.1.&nbsp; Definition:"><div class="titlepage"><div><div><h4 class="title" id="d5e2162">2.8.36.1.&nbsp;
        <span class="bold"><strong>Definition:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">SETFEATURE(StringExpression,Expression)</pre><p>
      </p>
    </div>
    <div class="section" title="2.8.36.2.&nbsp; Example:"><div class="titlepage"><div><div><h4 class="title" id="d5e2167">2.8.36.2.&nbsp;
        <span class="bold"><strong>Example:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">Document{-&gt;SETFEATURE("language","en")};</pre><p>
      </p>
      <p>
        Here, the feature 'language' of the input document is set to
        English.
      </p>
    </div>
  </div>

    <div class="section" title="2.8.37.&nbsp;SHIFT"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.language.actions.shift">2.8.37.&nbsp;SHIFT</h3></div></div></div>
      
      <p>
        The SHIFT action can be used to change the offsets of an annotation. The optional number expressions,
        which point the rule elements of the rule, specify the new offsets of the annotation. The annotations that
        will be modified have to start or end at the match of the rule element of the action. This means that the action 
        has to be placed at a matching condition, which will be used to specify the annotations to be changed.
      </p>
      <div class="section" title="2.8.37.1.&nbsp; Definition:"><div class="titlepage"><div><div><h4 class="title" id="d5e2176">2.8.37.1.&nbsp;
          <span class="bold"><strong>Definition:</strong></span>
        </h4></div></div></div>
        
        <p>
          </p><pre class="programlisting">SHIFT(TypeExpression(,NumberExpression)*)</pre><p>
        </p>
      </div>
      <div class="section" title="2.8.37.2.&nbsp; Example:"><div class="titlepage"><div><div><h4 class="title" id="d5e2181">2.8.37.2.&nbsp;
          <span class="bold"><strong>Example:</strong></span>
        </h4></div></div></div>
        
        <p>
          </p><pre class="programlisting">Author{-&gt; SHIFT(Author,1,2)} PM;</pre><p>
        </p>
        <p>
          In this example, an annotation of the type <span class="quote">&#8220;<span class="quote">Author</span>&#8221;</span> is expanded 
          in order to cover the following punctation mark.
        </p>
        <p>
          </p><pre class="programlisting">W{STARTSWITH(FS) -&gt; SHIFT(FS, 1, 2)} W+ MARKUP;</pre><p>
        </p>
        <p>
          In this example, an annotation of the type <span class="quote">&#8220;<span class="quote">FS</span>&#8221;</span> that consists mostly of words 
          is shrinked by removing the last MARKUP annotation. 
        </p>
      </div>
    </div>

    <div class="section" title="2.8.38.&nbsp;SHIFT"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.language.actions.split">2.8.38.&nbsp;SHIFT</h3></div></div></div>
      
      <p>
        The SPLIT action is able to split the matched annotation for each occurence of annotation 
        of the given type. There are three additional parameters: The first one specifies if complete annotations of the given type 
        should be used to split the matched annotations. If set to false, then even the boundary of an annotation will cause splitting.
        The third (addToBegin) and fourth (addToEnd) argument specify if the complete annotation (for splitting) 
        will be added to the begin or end of the splitted annotation. 
        The latter two are only utilized if the first one is set to true..
        If omitted, the first argument is true and the other two arguments are false by default.
      </p>
      <div class="section" title="2.8.38.1.&nbsp; Definition:"><div class="titlepage"><div><div><h4 class="title" id="d5e2195">2.8.38.1.&nbsp;
          <span class="bold"><strong>Definition:</strong></span>
        </h4></div></div></div>
        
        <p>
          </p><pre class="programlisting">SPLIT(TypeExpression(,BooleanExpression, 
          (BooleanExpression, BooleanExpression)? )?</pre><p>
        </p>
      </div>
      <div class="section" title="2.8.38.2.&nbsp; Example:"><div class="titlepage"><div><div><h4 class="title" id="d5e2200">2.8.38.2.&nbsp;
          <span class="bold"><strong>Example:</strong></span>
        </h4></div></div></div>
        
        <p>
          </p><pre class="programlisting">Sentence{-&gt; SPLIT(PERIOD, true, false, true)};</pre><p>
        </p>
        <p>
          In this example, an annotation of the type <span class="quote">&#8220;<span class="quote">Sentence</span>&#8221;</span> is 
          splitted for each occurence of a period, which is added to the end of the new sentence. 
        </p>
      </div>
    </div>

  <div class="section" title="2.8.39.&nbsp;TRANSFER"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.language.actions.transfer">2.8.39.&nbsp;TRANSFER</h3></div></div></div>
    
    <p>
      The TRANSFER action creates a new feature structure and adds all
      compatible features of the matched annotation.
    </p>
    <div class="section" title="2.8.39.1.&nbsp; Definition:"><div class="titlepage"><div><div><h4 class="title" id="d5e2210">2.8.39.1.&nbsp;
        <span class="bold"><strong>Definition:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">TRANSFER(TypeExpression)</pre><p>
      </p>
    </div>
    <div class="section" title="2.8.39.2.&nbsp; Example:"><div class="titlepage"><div><div><h4 class="title" id="d5e2215">2.8.39.2.&nbsp;
        <span class="bold"><strong>Example:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">Document{-&gt;TRANSFER(LanguageStorage)};</pre><p>
      </p>
      <p>
        Here, a new feature structure <span class="quote">&#8220;<span class="quote">LanguageStorage</span>&#8221;</span> is created and
        the compatible features of the Document annotation are copied. E.g.,
        if LanguageStorage defined a feature named 'language', then the
        feature value of the Document annotation is copied.
      </p>
    </div>
  </div>

  <div class="section" title="2.8.40.&nbsp;TRIE"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.language.actions.trie">2.8.40.&nbsp;TRIE</h3></div></div></div>
    
    <p>
      The TRIE action uses an external multi tree word list to
      annotate the matched annotation and provides several configuration
      parameters.
    </p>
    <div class="section" title="2.8.40.1.&nbsp; Definition:"><div class="titlepage"><div><div><h4 class="title" id="d5e2225">2.8.40.1.&nbsp;
        <span class="bold"><strong>Definition:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">TRIE((String = (TypeExpression|{TypeExpression,StringExpression,
          Expression}))+,ListExpression,BooleanExpression,NumberExpression,
          BooleanExpression,NumberExpression,StringExpression)</pre><p>
      </p>
    </div>
    <div class="section" title="2.8.40.2.&nbsp; Example:"><div class="titlepage"><div><div><h4 class="title" id="d5e2230">2.8.40.2.&nbsp;
        <span class="bold"><strong>Example:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">Document{-&gt;TRIE("FirstNames.txt" = FirstName, "Companies.txt" = Company, 
          'Dictionary.mtwl', true, 4, false, 0, ".,-/")};</pre><p>
      </p>
      <p>
        Here, the dictionary 'Dictionary.mtwl' that contains word lists
        for first names and companies is used to annotate the document. The
        words previously contained in the file 'FirstNames.txt' are
        annotated with the type FirstName and the words in the file
        'Companies.txt' with the type Company. The case of the word is
        ignored, if the length of the word exceeds 4. The edit distance is
        deactivated. The cost of an edit operation can currently not be
        configured by an argument. The last argument additionally defines
        several chars that will be ignored.
      </p>
      <p>
        </p><pre class="programlisting">Document{-&gt;TRIE("FirstNames.txt" = {A, "a", "first"}, "LastNames.txt" = 
          {B, "b", true}, "CompleteNames.txt" = {C, "c", 6},
          list1, true, 4, false, 0, ":")};</pre><p>
      </p>
      <p>
        Here, the dictionary 'list1' is applied on the document. Matches originated in dictionary 'FirstNames.txt'
        result in annotations of type A wheras their features 'a' are set to 'first'. The other two dictionaries 
        create annotations of type 'B' and 'C' for the corresponding dictionaries with a boolean feature value 
        and a integer feature value.
      </p>
    </div>
  </div>

<div class="section" title="2.8.41.&nbsp;TRIM"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.language.actions.trim">2.8.41.&nbsp;TRIM</h3></div></div></div>
    
    <p>
      The TRIM action changes the offsets on the matched annotations by removing annotations, whose
      types are specified by the given parameters.
    </p>
    <div class="section" title="2.8.41.1.&nbsp; Definition:"><div class="titlepage"><div><div><h4 class="title" id="d5e2242">2.8.41.1.&nbsp;
        <span class="bold"><strong>Definition:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">TRIE(TypeExpression ( , TypeExpression)*)</pre><p>
        </p><pre class="programlisting">TRIE(TypeListExpression)</pre><p>
      </p>
    </div>
    <div class="section" title="2.8.41.2.&nbsp; Example:"><div class="titlepage"><div><div><h4 class="title" id="d5e2248">2.8.41.2.&nbsp;
        <span class="bold"><strong>Example:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">Keyword{-&gt; TRIM(SPACE)};</pre><p>
      </p>
      <p>
        This rule removes all spaces at the beginning and at the end of Keyword annotations and
        thus changes the offsets of the matched annotations.
      </p>
    </div>
  </div>

  <div class="section" title="2.8.42.&nbsp;UNMARK"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.language.actions.unmark">2.8.42.&nbsp;UNMARK</h3></div></div></div>
    
    <p>
      The UNMARK action removes the annotation of the given type
      overlapping the matched annotation. There are two additional configurations: If additional
      indexes are given, then the span of the specified rule elements are applied, similar the the MARK action.
      If instead a boolean is given as an additional argument, then all annotations of the given type are removed
      that start at the matched position.
    </p>
    <div class="section" title="2.8.42.1.&nbsp; Definition:"><div class="titlepage"><div><div><h4 class="title" id="d5e2257">2.8.42.1.&nbsp;
        <span class="bold"><strong>Definition:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">UNMARK(TypeExpression)</pre><p>
        </p><pre class="programlisting">UNMARK(TypeExpression (,NumberExpression)*)</pre><p>
        </p><pre class="programlisting">UNMARK(TypeExpression, BooleanExpression)</pre><p>
      </p>
    </div>
    <div class="section" title="2.8.42.2.&nbsp; Example:"><div class="titlepage"><div><div><h4 class="title" id="d5e2264">2.8.42.2.&nbsp;
        <span class="bold"><strong>Example:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">Headline{-&gt;UNMARK(Headline)};</pre><p>
      </p>
      <p>
        Here, the Headline annotation is removed.
      </p>
      <p>
        </p><pre class="programlisting">CW ANY+? QUESTION{-&gt;UNMARK(Headline,1,3)};</pre><p>
      </p>
      <p>
        Here, all Headline annotations are removed that start with a capitalized word and end with a question mark.
      </p>
      <p>
        </p><pre class="programlisting">CW{-&gt;UNMARK(Headline,true)};</pre><p>
      </p>
      <p>
        Here, all Headline annotations are removed that start with a capitalized word.
      </p>
    </div>
  </div>

  <div class="section" title="2.8.43.&nbsp;UNMARKALL"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.language.actions.unmarkall">2.8.43.&nbsp;UNMARKALL</h3></div></div></div>
    
    <p>
      The UNMARKALL action removes all the annotations of the given
      type and all of its descendants overlapping the matched annotation,
      except the annotation is of at least one type in the passed list.
    </p>
    <div class="section" title="2.8.43.1.&nbsp; Definition:"><div class="titlepage"><div><div><h4 class="title" id="d5e2279">2.8.43.1.&nbsp;
        <span class="bold"><strong>Definition:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">UNMARKALL(TypeExpression, TypeListExpression)</pre><p>
      </p>
    </div>
    <div class="section" title="2.8.43.2.&nbsp; Example:"><div class="titlepage"><div><div><h4 class="title" id="d5e2284">2.8.43.2.&nbsp;
        <span class="bold"><strong>Example:</strong></span>
      </h4></div></div></div>
      
      <p>
        </p><pre class="programlisting">Annotation{-&gt;UNMARKALL(Annotation, {Headline})};</pre><p>
      </p>
      <p>
        Here, all annotations except from headlines are removed.
      </p>
      
    </div>
  </div>

</div>


  <div class="section" title="2.9.&nbsp;Robust extraction using filtering"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.tools.ruta.language.filtering">2.9.&nbsp;Robust extraction using filtering</h2></div></div></div>
    
    <p>
      Rule based or pattern based information extraction systems often
      suffer from unimportant fill words, additional whitespace and
      unexpected markup. The UIMA Ruta System enables the knowledge
      engineer to filter and to hide all possible combinations of
      predefined and new types of annotations. The
      visibility of tokens and annotations is modified by the actions of
      rule elements and can be conditioned using the complete
      expressiveness of the language.
      Therefore the UIMA Ruta system
      supports a robust approach to
      information extraction and simplifies
      the creation of new rules since
      the knowledge engineer can focus on
      important textual features. 
    </p>
    <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>    
      <p>
        The visibility of types is calculated using three lists: 
        A list <span class="quote">&#8220;<span class="quote">default</span>&#8221;</span> for the initially filtered types, 
        which is specified in the configuration parameters of the analysis engine, the list <span class="quote">&#8220;<span class="quote">filtered</span>&#8221;</span>, which is 
        specified by the FILTERTYPE action, and the list <span class="quote">&#8220;<span class="quote">retained</span>&#8221;</span>, which is specified by the RETAINTYPE action.
        For determining the actual visibility of types, list <span class="quote">&#8220;<span class="quote">filtered</span>&#8221;</span> is added to list <span class="quote">&#8220;<span class="quote">default</span>&#8221;</span> 
        and then all elements of list <span class="quote">&#8220;<span class="quote">retained</span>&#8221;</span> are removed. The annotations of the types in the resulting list are not visible.
        Please note that the actions FILTERTYPE and RETAINTYPE replace all elements of the respective lists and that RETAINTYPE 
        overrides FILTERTYPE.
      </p>
    </div>
    <p>
      If no rule action changed the
      configuration of the filtering settings, then
      the default filtering
      configuration ignores whitespaces and markup.
      Look at the following rule:
      </p><pre class="programlisting">"Dr" PERIOD CW CW;
</pre><p>
      Using the default
      setting, this rule matches on all four lines
      of this
      input document:
      </p><pre class="programlisting">Dr. Joachim Baumeister
Dr . Joachim      Baumeister
Dr. &lt;b&gt;&lt;i&gt;Joachim&lt;/i&gt; Baumeister&lt;/b&gt;
Dr.JoachimBaumeister
</pre><p>
    </p>
    <p>
      To change the default setting, use the
      <span class="quote">&#8220;<span class="quote">FILTERTYPE</span>&#8221;</span>
      or
      <span class="quote">&#8220;<span class="quote">RETAINTYPE</span>&#8221;</span>
      action. For example if markups should no longer be ignored, try
      the following example on the above mentioned input document:
      </p><pre class="programlisting">Document{-&gt;RETAINTYPE(MARKUP)};
"Dr" PERIOD CW CW;
</pre><p>
      You will see that the third line of the previous input example
      will  no longer be matched.
    </p>
    <p>
      To filter types, try the following rules on the input document:
      </p><pre class="programlisting">Document{-&gt;FILTERTYPE(PERIOD)};
"Dr" CW CW;
</pre><p>
      Since periods are ignored here, the rule will match on all four
      lines of the example.
    </p>
    <p>
      Notice that using a filtered annotation type within a
      rule prevents this rule from being executed. Try the following:
      </p><pre class="programlisting">Document{-&gt;FILTERTYPE(PERIOD)};
"Dr" PERIOD CW CW;
</pre><p>
      You will see that this matches on no line of the input document
      since the second rule uses the filtered type PERIOD and is therefore not
      executed.
    </p>
    
  </div>
  <div class="section" title="2.10.&nbsp;Blocks"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.tools.ruta.language.blocks">2.10.&nbsp;Blocks</h2></div></div></div>
    
    <p>
      Blocks combine some more complex control structures in the
      UIMA Ruta
      language:
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
          <p>
            Conditioned statements
          </p>
        </li><li class="listitem">
          <p>
            <span class="quote">&#8220;<span class="quote">Foreach</span>&#8221;</span>
            -Loops
          </p>
        </li><li class="listitem">
          <p>
            Procedures
          </p>
        </li></ol></div><p>
    </p>
    <p>
      Declaration of a block:
      </p><pre class="programlisting">BlockDeclaration   -&gt; "BLOCK" "(" Identifier ")" RuleElementWithCA
                                            "{" Statements "}"
RuleElementWithCA      -&gt;  TypeExpression QuantifierPart?
                                            "{" Conditions?  Actions? "}"</pre><p>
      A block declaration always starts with the keyword
      <span class="quote">&#8220;<span class="quote">BLOCK</span>&#8221;</span>, followed by the identifier of the block within parentheses. The
      <span class="quote">&#8220;<span class="quote">RuleElementType</span>&#8221;</span>-element
      is a UIMA Ruta rule that consists of exactly one rule
      element. The rule element has to be a declared annotation type.
      </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
        <p>
          The rule element in the definition of a block has to define
          a condition/action part, even if that part is empty (<span class="quote">&#8220;<span class="quote">{}</span>&#8221;</span>).
        </p>
      </div><p>
    </p>
    <p>
      Through the rule element a new local document is defined, whose
      scope
      is the related block. So if you use
      <code class="literal">Document</code>
      within a block, this always refers to the locally limited
      document.
      </p><pre class="programlisting">BLOCK(ForEach) Paragraph{} {
    Document{COUNT(CW)}; // Here "Document" is limited to a Paragraph;
               // therefore the rule only counts the CW annotations
               // within the Paragraph
}
</pre><p>
    </p>
    <p>
      A block is always executed when the UIMA Ruta interpreter
      reaches its
      declaration. But a block may also be called from another
      position of
      the script. See
      <a class="xref" href="#ugr.tools.ruta.language.blocks.procedure" title="2.10.3.&nbsp;Procedures">Section&nbsp;2.10.3, &#8220;Procedures&#8221;</a>
    </p>
    <div class="section" title="2.10.1.&nbsp;Conditioned statements"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.language.blocks.condition">2.10.1.&nbsp;Conditioned statements</h3></div></div></div>
      
      <p>
        A block can use common UIMA Ruta conditions to condition the
        execution of its containing rules.
      </p>
      <p>
        Examples:
        </p><pre class="programlisting">DECLARE Month;

BLOCK(EnglishDates) Document{FEATURE("language", "en")} {
    Document{-&gt;MARKFAST(Month,'englishMonthNames.txt')};
    //...
}

BLOCK(GermanDates) Document{FEATURE("language", "de")} {
    Document{-&gt;MARKFAST(Month,'germanMonthNames.txt')};
    //...
}
</pre><p>
        The example is explained in detail in
        <a class="xref" href="#ugr.tools.ruta.overview.examples" title="1.4.&nbsp;Learning by Example">Section&nbsp;1.4, &#8220;Learning by Example&#8221;</a>
        .
      </p>
    </div>
    <div class="section" title="2.10.2.&nbsp; &#8220;Foreach&#8221; -Loops"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.language.blocks.foreach">2.10.2.&nbsp;
        <span class="quote">&#8220;<span class="quote">Foreach</span>&#8221;</span>
        -Loops
      </h3></div></div></div>
      
      <p>
        A block can be used to execute the containing rules on a
        sequence of
        similar text passages, therefore representing a
        <span class="quote">&#8220;<span class="quote">foreach</span>&#8221;</span>
        like loop.
      </p>
      <p>
        Examples:
        </p><pre class="programlisting">DECLARE SentenceWithNoLeadingNP;
BLOCK(ForEach) Sentence{} {
    Document{-STARTSWITH(NP) -&gt; MARK(SentenceWithNoLeadingNP)};
}
</pre><p>
        The example is explained in detail in
        <a class="xref" href="#ugr.tools.ruta.overview.examples" title="1.4.&nbsp;Learning by Example">Section&nbsp;1.4, &#8220;Learning by Example&#8221;</a>
        .
      </p>
      <p>
        This construction is especially useful, if you have a set of
        rules,
        which has to be executed continously on the same part of an input
        document. Let us assume that you have already annotated your document
        with
        Paragraph annotations. Now you want to count the number of words
        within each paragraph and, if the number of words exceeds 500,
        annotate it as BigParagraph. Therefore, you wrote the following
        rules:
        </p><pre class="programlisting">DECLARE BigParagraph;
INT numberOfWords;
Paragraph{COUNT(W,numberOfWords)};
Paragraph{IF(numberOfWords &gt; 500) -&gt; MARK(BigParagraph)};
</pre><p>
        This will not work. The reason for this is that the rule, which counts the
        number of words within a Paragraph is executed on all Paragraphs
        before the last rule which marks the Paragraph as BigParagraph
        is
        even executed once. When reaching the last rule in this
        example, the variable
        <code class="literal">numberOfWords</code>
        holds the
        number of words of the last Paragraph in the input
        document,
        thus, annotating all Paragraphs either as BigParagraph or
        not.
      </p>
      <p>
        To solve this problem, use a block to tie the
        execution of this rules
        together for each Paragraph:
        </p><pre class="programlisting">DECLARE BigParagraph;
INT numberOfWords;
BLOCK(IsBig) Paragraph{} {
  Document{COUNT(W,numberOfWords)};
  Document{IF(numberOfWords &gt; 500) -&gt; MARK(BigParagraph)};
}
</pre><p>
        Since the scope of the Document is limited to a Paragraph within
        the
        block, the rule, which counts the words is only executed once
        before
        the second rule decides, if the Paragraph is a BigParagraph.
        Of course,
        this is done for every Paragraph in the whole document.
      </p>
    </div>
    <div class="section" title="2.10.3.&nbsp;Procedures"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.language.blocks.procedure">2.10.3.&nbsp;Procedures</h3></div></div></div>
      
      <p>
        Blocks can be used to introduce procedures to the UIMA Ruta
        scripts.
        To do this, declare a block as before. Let us assume, you want to
        simulate a procedure
        </p><pre class="programlisting">public int countAmountOfTypesInDocument(Type type){
    int amount = 0;
    for(Token token : Document) {
      if(token.isType(type)){
        amount++;
      }
    }
    return amount;
} 

public static void main() {
  int amount = countAmountOfTypesInDocument(Paragraph));
}            
</pre><p>
        which counts the number of the passed type within the document
        and
        returns the counted number. This can be done in the following
        way:
        </p><pre class="programlisting">BOOLEAN executeProcedure = false;
TYPE type;
INT amount;

BLOCK(countNumberOfTypesInDocument) Document{IF(executeProcedure)} {
    Document{COUNT(type, amount)};
}

Document{-&gt;ASSIGN(executeProcedure, true)};
Document{-&gt;ASSIGN(type, Paragraph)};
Document{-&gt;CALL(MyScript.countNumberOfTypesInDocument)};
</pre><p>
        The boolean variable
        <code class="literal">executeProcedure</code>
        is used to prohibit the execution of the block when the
        interpreter
        first reaches the block since this is no procedure call. The block
        can be called
        by referring to it with its name, preceded by the name
        of the script
        the
        block is defined in. In this example, the script is
        called MyScript.ruta.
      </p>
    </div>

  </div>
  
  <div class="section" title="2.11.&nbsp;Inlined rules"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.tools.ruta.language.inlined">2.11.&nbsp;Inlined rules</h2></div></div></div>
    
    <p>
      A rule element can have a few optional parts, e.g., the quantifier or the curly brackets with conditions and actions.
      After the part with the conditions and actions, the rule element can also contain an optional part with inlined rules.
      These rules are applied in the context of the rule element similar to the rules within a block construct: The rules 
      will try to match within the window specified by the current match of the rule element. There are two types of inlined rules.
      If the curly brackets start with the symbol <span class="quote">&#8220;<span class="quote">-&gt;</span>&#8221;</span>, the inlined rules will only be applied for successful matches of the surrounding rule.
      This behavior is very similar to the block construct. However, there are also some differences, e.g., inlined rules do not specify a 
      namespace, may not contain declarations and cannot be called by other rules.
      If the curly brackets start with the symbol <span class="quote">&#8220;<span class="quote">&lt;-</span>&#8221;</span>,
      then the inlined rules are interpreted as some sort of condition. The surrounding rules will only match, if one of the inlined rules was successfully applied.
      The functionality introduced by inlined rules is illustrated with a few examples:
    </p>
    <pre class="programlisting">Sentence{} -&gt; {NUM{-&gt; NumBeforeWord} W;};
Sentence{-&gt; SentenceWithNumBeforeWord} &lt;- {NUM W;};
</pre>
    <p>
      The first rule in this example matches on each <span class="quote">&#8220;<span class="quote">Sentence</span>&#8221;</span> annotation and applies the inlined rule within each matched sentence. The inlined rule 
      matches on numbers followed by a word and annotates the number with an annotation of the type <span class="quote">&#8220;<span class="quote">NumBeforeWord</span>&#8221;</span>. The second rule matches on each sentence 
      and applies the inlined rule within each sentence. Note that the inlined rule contains no actions. The rule matches only successfully on a sentence if one of the inlined rules was
      successfully applied. In this case, the sentence is only annotated with an annotation of the type <span class="quote">&#8220;<span class="quote">SentenceWithNumBeforeWord</span>&#8221;</span>, if the 
      sentence contains a number followed by a word.
    </p>

    <pre class="programlisting">Document.language == "en"{} -&gt; {
  PERIOD #{} &lt;- {
      COLON COLON % COMMA COMMA;
    }
    PERIOD{-&gt; SpecialPeriod};
}    
</pre>
    <p>
      This examples combines both types of inlined rules. First, the rule matches on document annotations with the language feature set to <span class="quote">&#8220;<span class="quote">en</span>&#8221;</span>. Only for those documents,
      the first inner rule is applied. The inner rule matches on everything between two period, but only if the text span between the period fulfills two conditions: There must be two 
      successive colons and two successive commas within the window of the matched part of the wildcard. Only if these constraints are fulfilled, then the last period is annotated with the type 
      <span class="quote">&#8220;<span class="quote">SpecialPeriod</span>&#8221;</span>.
    </p>  
  </div>
  
  <div class="section" title="2.12.&nbsp;Heuristic extraction using scoring rules"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.tools.ruta.language.score">2.12.&nbsp;Heuristic extraction using scoring rules</h2></div></div></div>
    
    <p>
      Diagnostic scores are a well known and successfully applied
      knowledge
      formalization pattern for diagnostic problems. Single known
      findings
      valuate a possible solution by adding or subtracting points
      on an
      account of that solution. If the sum exceeds a given threshold,
      then
      the solution is derived. One of the advantages of this pattern
      is the
      robustness against missing or false findings, since a high
      number of
      findings is used to derive a solution.

      The UIMA Ruta system tries to
      transfer this diagnostic problem
      solution strategy to the
      information
      extraction problem. In addition to a
      normal creation of a new
      annotation, a MARKSCORE action can add positive
      or negative scoring
      points to the text fragments matched by the rule
      elements. The current
      value of heuristic points of an annotation can
      be evaluated by the
      SCORE condition, which can be used in an
      additional rule to create
      another annotation.
      In the following, the heuristic extraction using
      scoring rules is demonstrated by a short example:

      </p><pre class="programlisting">Paragraph{CONTAINS(W,1,5)-&gt;MARKSCORE(5,Headline)};
Paragraph{CONTAINS(W,6,10)-&gt;MARKSCORE(2,Headline)};
Paragraph{CONTAINS(Emph,80,100,true)-&gt;MARKSCORE(7,Headline)};
Paragraph{CONTAINS(Emph,30,80,true)-&gt;MARKSCORE(3,Headline)};
Paragraph{CONTAINS(CW,50,100,true)-&gt;MARKSCORE(7,Headline)};
Paragraph{CONTAINS(W,0,0)-&gt;MARKSCORE(-50,Headline)};
Headline{SCORE(10)-&gt;MARK(Realhl)};
Headline{SCORE(5,10)-&gt;LOG("Maybe a headline")};</pre><p>


      In the first part of this rule set, annotations of the type
      paragraph
      receive scoring points for a headline annotation, if they
      fulfill
      certain CONTAINS conditions. The first condition, for
      example,
      evaluates to true, if the paragraph contains one word up to
      five
      words, whereas the fourth conditions is fulfilled, if the
      paragraph
      contains thirty up to eighty percent of emph annotations.
      The last two
      rules finally execute their actions, if the score of a
      headline
      annotation exceeds ten points, or lies in the interval of
      five to ten
      points, respectively.
    </p>
  </div>
  <div class="section" title="2.13.&nbsp;Modification"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.tools.ruta.language.modification">2.13.&nbsp;Modification</h2></div></div></div>
    
    <p>
      There are different actions that can modify the input document,
      like DEL, COLOR and REPLACE. However, the input document itself can not be
      modified directly. A separate engine, the Modifier.xml, has to be
      called in order to create another CAS view with the (default) name "modified".
      In that document, all modifications are executed.
    </p>
    <p>
      The following example shows how to import and call the
      Modifier.xml engine. The example is explained in detail in
      <a class="xref" href="#ugr.tools.ruta.overview.examples" title="1.4.&nbsp;Learning by Example">Section&nbsp;1.4, &#8220;Learning by Example&#8221;</a>.
    </p>
    <pre class="programlisting">ENGINE utils.Modifier;
Date{-&gt; DEL};
MoneyAmount{-&gt; REPLACE("&lt;MoneyAmount/&gt;")};
Document{-&gt; COLOR(Headline, "green")};
Document{-&gt; EXEC(Modifier)};
</pre>

  </div>

  <div class="section" title="2.14.&nbsp;External resources"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.tools.ruta.language.external_resources">2.14.&nbsp;External resources</h2></div></div></div>
    
    <p>
      Imagine you have a set of documents containing many different
      first names. (as example we use a short list, containing the first
      names
      <span class="quote">&#8220;<span class="quote">Frank</span>&#8221;</span>
      ,
      <span class="quote">&#8220;<span class="quote">Peter</span>&#8221;</span>
      ,
      <span class="quote">&#8220;<span class="quote">Jochen</span>&#8221;</span>
      and
      <span class="quote">&#8220;<span class="quote">Martin</span>&#8221;</span>
      )
      If you like to annotate all of them with a
      <span class="quote">&#8220;<span class="quote">FirstName</span>&#8221;</span>
      annotation, then you could write a script using the rule
      <code class="literal">("Frank" | "Peter" | "Jochen" |
        "Martin"){-&gt;MARK(FirstName)};</code>.
      This does exactly what you want, but not very handy.
      If you like to add new first names to the list of recognized first
      names you have to change the rule itself every time. Moreover, writing
      rules with possibly hundreds of first names
      is not really practically realizable and definitely not efficient, if you have
      the list of first names already as a simple text file. Using this text file directly
      would reduce the effort.
    </p>
    <p>
      UIMA Ruta provides, therefore, two kinds of external resources to
      solve such tasks more easily: WORDLISTs and WORDTABLEs.
    </p>
    <div class="section" title="2.14.1.&nbsp;WORDLISTs"><div class="titlepage"><div><div><h3 class="title" id="d5e2394">2.14.1.&nbsp;WORDLISTs</h3></div></div></div>
      
      <p>
        A WORDLIST is a list of text items. There are three
        different possibilities of how to provide a WORDLIST to the UIMA Ruta system.
      </p>
      <p>
        The first possibility is the use of simple text files, which
        contain exactly one list item per line. For example, a list "FirstNames.txt"
        of first names could look like this:
        </p><pre class="programlisting">Frank
Peter
Jochen
Martin
</pre><p>
        First names within a document containing any number of these
        listed
        names, could be annotated
        by using
        <code class="literal">Document{-&gt;MARKFAST(FirstName, "FirstNames.txt")};</code>, assuming
        an already declared type FirstName. To make this rule
        recognizing more first names, add
        them to the external list.
        You could also use a WORLIST variable to do the same thing as follows:
        </p><pre class="programlisting">WORDLIST FirstNameList = 'FirstNames.txt';
DECLARE FirstName;
Document{-&gt;MARKFAST(FirstName, FirstNameList)};
</pre><p>
      </p>
      <p>
        Another possibility to provide WORDLISTs is the use of compiled
        <span class="quote">&#8220;<span class="quote">tree word list</span>&#8221;</span>
        s. The file ending for this is <span class="quote">&#8220;<span class="quote">.twl</span>&#8221;</span>
        A tree word list is similar to a trie. It is a XML-file that contains
        a tree-like structure with a node for each character. The nodes
        themselves refer to child nodes that represent all characters that
        succeed the character of the parent node. For single word entries the
        resulting complexity is O(m*log(n)) instead of O(m*n) for simple text
        files. Here m is the amount of basic annotations in the document and
        n is the amount of entries in the dictionary. To generate a tree word
        list, see <a class="xref" href="#section.ugr.tools.ruta.workbench.create_dictionaries" title="3.11.&nbsp;Creation of Tree Word Lists">Section&nbsp;3.11, &#8220;Creation of Tree Word Lists&#8221;</a>.
        A tree word list is used in the same way as simple word lists,
        for example <code class="literal">Document{-&gt;MARKFAST(FirstName, "FirstNames.twl")};</code>.
      </p>
      <p>
        A third kind of usable WORDLISTs are <span class="quote">&#8220;<span class="quote">multi tree word list</span>&#8221;</span>s.
        The file ending for this is <span class="quote">&#8220;<span class="quote">.mtwl</span>&#8221;</span>. It is generated from
        several ordinary WORDLISTs given as simple text files. It contains special
        nodes that provide additional information about the original file. These
        kind of WORDLIST is useful, if several different WORDLISTs are used within
        a UIMA Ruta script. Using five different lists results in five rules using
        the MARKFAST action. The documents to annotate are thus searched five
        times resulting in a complexity of 5*O(m*log(n)) With a multi tree
        word list this can be reduced to about O(m*log(5*n)). To
        generate a multi tree word list, see
        <a class="xref" href="#section.ugr.tools.ruta.workbench.create_dictionaries" title="3.11.&nbsp;Creation of Tree Word Lists">Section&nbsp;3.11, &#8220;Creation of Tree Word Lists&#8221;</a>
        To use a multi tree word list UIMA Ruta provides the action
        TRIE. If for example two word lists
        <span class="quote">&#8220;<span class="quote">FirstNames.txt</span>&#8221;</span>
        and
        <span class="quote">&#8220;<span class="quote">LastNames.txt</span>&#8221;</span>
        have been merged in the multi tree word list
        <span class="quote">&#8220;<span class="quote">Names.mtwl</span>&#8221;</span>, then the following rule annotates all
        first names and last names in the whole document:
        </p><pre class="programlisting">WORDLIST Names = 'Names.mtwl';
Declare FirstName, LastName;
Document{-&gt;TRIE("FirstNames.txt" = FirstName, "LastNames.txt" = LastName,
    Names, false, 0, false, 0, "")};</pre><p>
      </p>
    </div>
    <div class="section" title="2.14.2.&nbsp;WORDTABLEs"><div class="titlepage"><div><div><h3 class="title" id="d5e2414">2.14.2.&nbsp;WORDTABLEs</h3></div></div></div>
      
      <p>
        WORDLISTs have been used to annotate all occurrences of any list
        item in a document with a certain type. Imagine now that each annotation
        has features that should be filled with values dependent on the list item
        that matched. This can be achieved with WORDTABLEs. Let us, for example,
        assume we want to annotate all US presidents within a document.
        Moreover, each annotation should contain the party of the president as well as the
        year of his inauguration. Therefore we use an annotation type
        <code class="literal">DECLARE Annotation PresidentOfUSA(STRING party, INT
          yearOfInauguration)</code>. To achieve this, it is recommended to use WORDTABLEs.
      </p>
      <p>
        A WORDTABLE is simply a comma-separated file (.csv), which actually uses semicolons for separation of the entries. 
        For our example, such a file named
        <span class="quote">&#8220;<span class="quote">presidentsOfUSA.csv</span>&#8221;</span>
        could look like this:
        </p><pre class="programlisting">Bill Clinton;democrats;1993
George W. Bush;republicans;2001
Barack Obama;democrats;2009
</pre><p>
        To annotate our documents we could use the following set of
        rules:
        </p><pre class="programlisting">WORDTABLE presidentsOfUSA = 'presidentsOfUSA.csv';
DECLARE Annotation PresidentOfUSA(STRING party, INT yearOfInauguration);
Document{-&gt;MARKTABLE(PresidentOfUSA, 1, presidentsOfUSA, "party" = 2, 
		"yearOfInauguration" = 3)};</pre><p>
      </p>
    </div>
  </div>
  <div class="section" title="2.15.&nbsp;Simple Rules based on Regular Expressions"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.tools.ruta.language.regexprule">2.15.&nbsp;Simple Rules based on Regular Expressions</h2></div></div></div>
    
    <p>
      The UIMA Ruta language includes, additionally to the normal rules, a simplified rule syntax for processing regular expressions.
      These simple rules consist of two parts separated by <span class="quote">&#8220;<span class="quote">-&gt;</span>&#8221;</span>: The left part is the regular expression 
      (flags: DOTALL and MULTILINE), which may contain capturing groups. The right part defines, which kind of annotations 
      should be created for each match of the regular expression. If a type is given without a group index, then an annotation of that type is
      created for the complete regular expression match, which corresponds to group 0. Each type can be extended with additional feature assignments, 
      which store the value of the given expression in the feature specified by the given StringExpression. However, if the expression 
      refers to a number (NumberExpression), then the match of the corresponding capturing group is applied. 
      These simple rules can be restricted to match only within
      certain annotations using the BLOCK construct, and ignore all filtering settings.
    </p>
    
    <pre class="programlisting">
RegExpRule        -&gt; StringExpression "-&gt;" GroupAssignment 
                     ("," GroupAssignment)* ";"
GroupAssignment   -&gt; TypeExpression FeatureAssignment?
                     | NumberEpxression "=" TypeExpression 
                       FeatureAssignment?
FeatureAssignment -&gt; "(" StringExpression "=" Expression 
                      ("," StringExpression "=" Expression)* ")"
</pre>
    
    <p>
      The following example contains a simple rule, which is able to create annotations of two different types. It creates an annotation 
      of the type <span class="quote">&#8220;<span class="quote">T1</span>&#8221;</span> for each match of the complete regular expression and an annotation 
      of the type <span class="quote">&#8220;<span class="quote">T2</span>&#8221;</span> for each match of the first capturing group.
    </p>
    
    <pre class="programlisting">"A(.*?)C" -&gt; T1, 1 = T2;</pre>
    
    
  </div>
  <div class="section" title="2.16.&nbsp;Language Extensions"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.tools.ruta.language.extensions">2.16.&nbsp;Language Extensions</h2></div></div></div>
    
    <p>
      The UIMA Ruta language can be extended with external blocks, actions, conditions, 
      type functions, boolean functions, string functions and number functions. 
      The block constructs are able to introduce new rule matching paradigms. 
      The other extensions provide atomic elements to the language, e.g., a condition that evaluates project-specific properties.
      An exemplary implementation of each kind of extension can be found in the project
      <span class="quote">&#8220;<span class="quote">ruta-ep-example-extensions</span>&#8221;</span> and a simple UIMA Ruta project, which uses these extensions, is located at 
      <span class="quote">&#8220;<span class="quote">ExtensionsExample</span>&#8221;</span>. Both projects are part of the source release of UIMA ruta and are located in the <span class="quote">&#8220;<span class="quote">example-projects</span>&#8221;</span> folder.
    </p>
    <div class="section" title="2.16.1.&nbsp;Provided Extensions"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.language.extensions.core-ext">2.16.1.&nbsp;Provided Extensions</h3></div></div></div>
	    
	    <p>
	      The UIMA Ruta language already provides extensions besides the exemplary elements. 
	      The projet ruta-core-ext contains the implementation for the analysis engine and the project
	      ruta-ep-core-ext contains the integration in the UIMA Ruta Workbench.
	    </p>
	    
	    <div class="section" title="2.16.1.1.&nbsp;DOCUMENTBLOCK"><div class="titlepage"><div><div><h4 class="title" id="ugr.tools.ruta.language.extensions.core-ext.documentblock">2.16.1.1.&nbsp;DOCUMENTBLOCK</h4></div></div></div>
      
      <p>
        This additional block construct applies the contained statements/rules on 
        the complete document independent of previous windows and restictions. 
        It resets the matching context, but otherwise behaves like a normal BLOCK.
      </p>
      <pre class="programlisting">BLOCK(ex) NUM{}{
  DOCUMENTBLOCK W{}{
    // do something with the words
  }
}</pre>
      <p>
        The example contains two blocks. The first block iterates over all numbers (NUM). 
        The second block resets the match context and matches on all words (W), for every previously matched number.
      </p>
      </div>
	    <div class="section" title="2.16.1.2.&nbsp;ONLYFIRST"><div class="titlepage"><div><div><h4 class="title" id="ugr.tools.ruta.language.extensions.core-ext.onlyfirst">2.16.1.2.&nbsp;ONLYFIRST</h4></div></div></div>
	    
      <p>
        This additional block construct applies the contained statements/rules only until 
        the first one was successfully applied. The following example provides an overview of the syntax:
      </p>
      <pre class="programlisting">ONLYFIRST Document{}{
  Document{CONTAINS(Keyword1) -&gt; Doc1};
  Document{CONTAINS(Keyword2) -&gt; Doc2};
  Document{CONTAINS(Keyword3) -&gt; Doc3};
}</pre>
      <p>
        The block contains three rules each evaluating if the document contains a specific annotation of the type Keyword1/2/3.
        If the first rule is able to match, then the other two rules will not try to apply. Straightforwardly, if the first rule failed to match and 
        the second rules is able to match, then the third rule will not try to be applied.
      </p>
	    </div>
    </div>
    <div class="section" title="2.16.2.&nbsp;ONLYONCE"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.language.extensions.core-ext.onlyonce">2.16.2.&nbsp;ONLYONCE</h3></div></div></div>
      
      <p>
        Rules within this block construct will stop after the first successful match.
        The following example provides an overview of the syntax:
      </p>
      <pre class="programlisting">ONLYONCE Document{}{
  CW{-&gt; FirstCW};
  NUM+{-&gt; FirstNumList};
}</pre>
      <p>
        The block contains two rules. 
        The first rule will annotate the first capitalized word of the document with the type FirstCW.
        All further possible matches will be skipped.
        The second rule will annotate the first sequence of numbers with the type FirstNumList.
        The greedy behavior of the quantifiers is not changed by the ONLYONCE block.
       </p>
    </div>
        <div class="section" title="2.16.3.&nbsp;Stringfunctions"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.language.extensions.core-ext.stringfunctions">2.16.3.&nbsp;Stringfunctions</h3></div></div></div>
      
      <p>
        In order to manipulate Strings in variables a bunch of Stringfunctions
        have been added.
        They will all be presented with a short example demonstrating their use.
      </p>
      <div class="section" title="2.16.3.1.&nbsp;firstCharToUpperCase(IStringExpression expr)"><div class="titlepage"><div><div><h4 class="title" id="d5e2458">2.16.3.1.&nbsp;firstCharToUpperCase(IStringExpression expr)</h4></div></div></div>
        
        <pre class="programlisting">STRING s;
STRINGLIST sl;
SW{-&gt; MATCHEDTEXT(s), ADD(sl, firstCharToUpperCase(s))};
CW{INLIST(sl) -&gt; Test};</pre>
        <p>
          This example declares a STRING and a STRINGLIST. Afterwards for every
          small-written word,
          the according word with a capital first Character is added to the
          STRINGLIST.
          This might be helpful in german Named-Entity-Recognition where you will
          encounter "der blonde Junge..." and "der Blonde",
          both map to the same entity. Applied to the word "blonde" you can then
          also track the second appearance of that Person.
          In the last line a rule marks all words in the STRINGLIST as a Test
          Annotation.
        </p>
      </div>
      <div class="section" title="2.16.3.2.&nbsp;replaceFirst(IStringExpression expr, IStringExpression searchTerm, IStringExpression replacement)"><div class="titlepage"><div><div><h4 class="title" id="d5e2462">2.16.3.2.&nbsp;replaceFirst(IStringExpression expr, IStringExpression
          searchTerm,
          IStringExpression replacement)
        </h4></div></div></div>
        
        <pre class="programlisting">STRING s;
STRINGLIST sl;
CW{-&gt; MATCHEDTEXT(s), ADD(sl, replaceFirst(s,"e","o"))};
CW{INLIST(sl) -&gt; Test};</pre>
        <p>
          This example declares a STRING and a STRINGLIST. Next every capital
          Word CW is added
          to the STRINGLIST, however the first "e" is going to be replaced by
          "o". Afterwards all
          instances of the STRINGLIST are matched with all present CWs and
          annotated as a Test Annotation if a match occurs.
        </p>
      </div>
      <div class="section" title="2.16.3.3.&nbsp;replaceAll(IStringExpression expr, IStringExpression searchTerm, IStringExpression replacement)"><div class="titlepage"><div><div><h4 class="title" id="d5e2466">2.16.3.3.&nbsp;replaceAll(IStringExpression expr, IStringExpression
          searchTerm,
          IStringExpression replacement)
        </h4></div></div></div>
        
        <pre class="programlisting">STRING s;
STRINGLIST sl;
CW{-&gt; MATCHEDTEXT(s), ADD(sl, replaceAll(s,"e","o"))};
CW{INLIST(sl) -&gt; Test};</pre>
        <p>
          This example declares a STRING and a STRINGLIST. Next every capital
          Word CW is added
          to the STRINGLIST, however similar to the above example at first
          there is going to be a replacement.
          This time all "e"`s are going to be replaced by "o"`s. Afterwards all
          instances of the STRINGLIST are matched with all present CWs and
          annotated as a Test Annotation if a match occurs.
        </p>
      </div>

      <div class="section" title="2.16.3.4.&nbsp;substring(IStringExpression expr, INumberExpression from, INumberExpression to)"><div class="titlepage"><div><div><h4 class="title" id="d5e2470">2.16.3.4.&nbsp;substring(IStringExpression expr, INumberExpression from,
          INumberExpression to)
        </h4></div></div></div>
        
        <pre class="programlisting">STRING s;
STRINGLIST sl;
CW{-&gt; MATCHEDTEXT(s), ADD(sl, substring(s,0,9))};
SW{INLIST(sl) -&gt; Test};</pre>
        <p>
          This example declares a STRING and a STRINGLIST. Imagine you found the
          word "Alexanderplatz" but
          you only want to continue with the word "Alexander". This snippet
          shows how this can be done by
          using the Stringfunctions in RUTA. If a word has less character than
          specified in the arguments,
          nothing will be executed.

        </p>
      </div>

      <div class="section" title="2.16.3.5.&nbsp;toLowerCase(IStringExpression expr)"><div class="titlepage"><div><div><h4 class="title" id="d5e2474">2.16.3.5.&nbsp;toLowerCase(IStringExpression expr)</h4></div></div></div>
        
        <pre class="programlisting">STRING s;
STRINGLIST sl;
CW{-&gt; MATCHEDTEXT(s), ADD(sl, toLowerCase(s))};
SW{INLIST(sl) -&gt; Test};</pre>
        <p>
          This example declares a STRING and a STRINGLIST. A problem you might
          encounter is that you
          want to know whether the first word of a sentence is really a
          noun.(Again more or less german related)
          By using this function you could add all words that start a
          sentence(which usually means a capitalized word) to a list
          as in this example. Then test if it also appears within the text but
          this time as lowercase. As a result you could change its
          POS-Tag.

        </p>
      </div>
            <div class="section" title="2.16.3.6.&nbsp;toUpperCase(IStringExpression expr)"><div class="titlepage"><div><div><h4 class="title" id="d5e2478">2.16.3.6.&nbsp;toUpperCase(IStringExpression expr)</h4></div></div></div>
        
        <pre class="programlisting">STRING s;
STRINGLIST sl;
CW{-&gt; MATCHEDTEXT(s), ADD(sl, toUpperCase(s))};
SW{INLIST(sl) -&gt; T1};</pre>
        <p>
          This example declares a STRING and a STRINGLIST. A typical scenario for
          its use might be
          Named-Entity-Recognition. This time you want to find all organizations given an input
          document.
          At first you might track-down all fully capitalized words. As a
          second step you can use this function
          and iterate over all CW insances and compare the found instance with
          all the uppercase organizations that were
          found before.
        </p>
      </div>


      <div class="section" title="2.16.3.7.&nbsp;contains(IStringExpression expr,IStringExpression contains)"><div class="titlepage"><div><div><h4 class="title" id="d5e2482">2.16.3.7.&nbsp;contains(IStringExpression expr,IStringExpression contains)
        </h4></div></div></div>
        
        <pre class="programlisting">STRING s;
BOOLEAN a ;
BLOCK(forEACH) W{}{
    W{-&gt;MATCHEDTEXT(s), ASSIGN(a,contains(s,"er"))};
    W{a -&gt;Test};
}</pre>
        <p>
          If you want to find all words that contain a given charactersequence.
          Assume again you are in a NER-Task
          you found the token "Alexanderplatz" using this function you can track
          down the names that are part of a given token.
          This example uses a BLOCK to iterate over each word and then assigns
          whether the text of that word contains the given char-sequence.
          If so it is annotated as a Test annotation.
        </p>
      </div>

      <div class="section" title="2.16.3.8.&nbsp;endsWith(IStringExpression expr,IStringExpression expr)"><div class="titlepage"><div><div><h4 class="title" id="d5e2486">2.16.3.8.&nbsp;endsWith(IStringExpression expr,IStringExpression expr)
        </h4></div></div></div>
        
        <pre class="programlisting">STRING s;
BOOLEAN a;
BLOCK(forEACH) W{}{
    W{-&gt;MATCHEDTEXT(s), ASSIGN(a,endsWith(s,"str."))};
    W{a -&gt;Test};
}</pre>
        <p>
          Assume you found the suffix "str." as a strong indicator whether a given
          token represents
          location (a street) by using this function you can now easily identify all
          of those words, given
          a valid suffix.
        </p>
      </div>

      <div class="section" title="2.16.3.9.&nbsp;startsWith(IStringExpression expr,IStringExpression expr)"><div class="titlepage"><div><div><h4 class="title" id="d5e2490">2.16.3.9.&nbsp;startsWith(IStringExpression expr,IStringExpression expr)
        </h4></div></div></div>
        
        <pre class="programlisting">STRING s;
BOOLEAN a ;
BLOCK(forEACH) W{}{
    W{-&gt;MATCHEDTEXT(s), ASSIGN(a,startsWith(s,"sprech"))};
    W{a -&gt;Test};
}</pre>
        <p>
  Given a stem of a word you want to mark every instance that was possibly derived from that stem.
  If you decide to use that function you can detect all those words in 1 line and in a next step mark all
  of them as an Annotationtype of choice.
  
        </p>
      </div>
      
            <div class="section" title="2.16.3.10.&nbsp;equals(IStringExpression expr,IStringExpression expr) and equalsIgnoreCase(expr,expr)"><div class="titlepage"><div><div><h4 class="title" id="d5e2494">2.16.3.10.&nbsp;equals(IStringExpression expr,IStringExpression expr) and equalsIgnoreCase(expr,expr)
        </h4></div></div></div>
        
        <pre class="programlisting">STRING s;
STRING s2 = "Kenny";
BOOLEAN a;
BLOCK(forEACH) W{}{
    W{-&gt;MATCHEDTEXT(s), ASSIGN(a,equals(s,s2))};
    W{-&gt;MATCHEDTEXT(s), ASSIGN(a,equalsIgnoreCase(s,s2))};
    W{a -&gt;Test};
}</pre>
        <p>
  These functions check whether both arguments are equal in terms of the
  text of the token that they contain.
  
  
        </p>
      </div>
      
                  <div class="section" title="2.16.3.11.&nbsp;isEmpty(IStringExpression expr) and equalsIgnoreCase(expr,expr)"><div class="titlepage"><div><div><h4 class="title" id="d5e2498">2.16.3.11.&nbsp;isEmpty(IStringExpression expr) and equalsIgnoreCase(expr,expr)
        </h4></div></div></div>
        
        <pre class="programlisting">STRING s;
BOOLEAN a;
BLOCK(forEACH) W{}{
    W{-&gt;MATCHEDTEXT(s), ASSIGN(a,isEmpty(s))};
    W{a -&gt;Test};
}</pre>
        <p>
An equivalent function to the Java Stringlibrary. It checks whether or not a given variable contains
an empty Stringliteral "" or not.
  
        </p>
      </div>
          </div>
    <div class="section" title="2.16.4.&nbsp;Adding new Language Elements"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.language.extensions.new">2.16.4.&nbsp;Adding new Language Elements</h3></div></div></div>
    
    <p>
      The extension of the UIMA Ruta language is illustrated using an exmaple on how to add a new condition.
      Other langauge elements can be specified straightforwardly by using the corresponding interfaces and extensions.
    </p>
    <p>
      Three classes need to be implemented for adding a new condition that also is resolved in the UIMA Ruta Workbench:
    </p>
    <p>
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
	    <p>
	      An implementation of the condition extending AbstractRutaCondition.
	    </p>
    </li><li class="listitem">
      <p>
        An implementation of IRutaConditionExtension, which provides the condition implementation to the engine.
      </p>
    </li><li class="listitem">
      <p>
        An implementation of IIDEConditionExtension, which provides the condition for the UIMA Ruta Workench.
      </p>
    </li></ol></div><p>
    </p>
    <p>
      The exemplary project provides implementation of all possible language elements. 
      This project contains the implementations for the analysis engine and also the implementation 
      for the UIMA Ruta Workbench, and is therefore an Eclipse plugin (mind the pom file).
    </p>
    <p>
      Concerning the ExampleCondition condition extension, there are four important spots/classes:
    </p>
    <p>
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
      <p>
        ExampleCondition.java provides the implementation of the new condition, which evaluates dates.
      </p>
    </li><li class="listitem">
      <p>
        ExampleConditionExtension.java provides the extension for the analysis engine. 
        It knows the name of the condition, its implementation, can create new instances 
        of that condition, and is able to verbalize the condition for the explanation components.
      </p>
    </li><li class="listitem">
      <p>
        ExampleConditionIDEExtension provides the syntax check for the editor and the keyword for syntax coloring.
      </p>
    </li><li class="listitem">
      <p>
        The plugin.xml defines the extension for the Workbench:
      </p>
    </li></ol></div><p>
    </p><pre class="programlisting">&lt;extension point="org.apache.uima.ruta.ide.conditionExtension"&gt;
  &lt;condition
    class="org.apache.uima.ruta.example.extensions.
      ExampleConditionIDEExtension"
    engine="org.apache.uima.ruta.example.extensions.
      ExampleConditionExtension"&gt;
  &lt;/condition&gt;
&lt;/extension&gt;</pre><p>
    </p>
    <p>
      If the UIMA Ruta Workbench is not used or the rules are only applied in UIMA pipelines, 
      only the ExampleCondition and ExampleConditionExtension are needed, and org.apache.uima.ruta.example.extensions.ExampleConditionExtension 
      needs to be added to the additionalExtensions parameter of your UIMA Ruta analysis engine (descriptor).
    </p>
    <p>
      Adding new conditions using Java projects in the same workspace has not been tested yet, 
      but at least the Workbench support will be missing due to the inclusion of extensions 
      using the extension point mechanism of Eclipse.    
    </p>
    </div>
  </div>
</div>
  
  <div class="chapter" title="Chapter&nbsp;3.&nbsp;Apache UIMA Ruta Workbench" id="ugr.tools.ruta.workbench"><div class="titlepage"><div><div><h2 class="title">Chapter&nbsp;3.&nbsp;Apache UIMA Ruta Workbench</h2></div></div></div>
  
  <p>
  The Apache UIMA Ruta Workbench, which is made available as an Eclipse-plugin, offers a powerful environment for creating and working on UIMA Ruta projects. It provides two main
  perspectives and several views to develop, run, debug, test and evaluate UIMA Ruta
  rules in a comfortable way, supporting many of the known Eclipse features, e.g., auto-completion.
  Moreover, it makes the creation of dictionaries like tree word lists easy and supports machine
  learning methods, which can be used within a knowledge engineering process. The following chapter
  starts with the installation of the workbench, followed by a description of all its features.
  </p>

  <div class="section" title="3.1.&nbsp;Installation"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="section.ugr.tools.ruta.workbench.install">3.1.&nbsp;Installation</h2></div></div></div>
  
  <p>

    Do the installation of the UIMA Ruta Workbench as follows:
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
        <p>
          Download, install and start Eclipse. The Eclipse version currently supported by UIMA Ruta is given 
          on the webpage of the <a class="ulink" href="https://uima.apache.org/ruta.html" target="_top">project</a>. 
          This is normally the latest version of Eclipse, which can be obtained
          from the <a class="ulink" href="https://eclipse.org/" target="_top">eclipse.org</a> download site.
        </p>
      </li><li class="listitem">
        <p>
          Add the Apache UIMA update site (
          <a class="ulink" href="http://www.apache.org/dist/uima/eclipse-update-site/" target="_top">http://www.apache.org/dist/uima/eclipse-update-site/
          </a>) to the available
          software sites in your Eclipse installation.
          Click on <span class="quote">&#8220;<span class="quote">Help <span class="symbol">&#8594;</span> Install New Software</span>&#8221;</span>. This opens the install wizard, which can be
          seen in <a class="xref" href="#figure.ugr.tools.ruta.workbench.install.update" title="Figure&nbsp;3.1.&nbsp; Eclipse update site">Figure&nbsp;3.1, &#8220; Eclipse update site
      &#8221;</a>
        </p>
      </li><li class="listitem">
        <p>
          Select or enter the Apache UIMA update site (<a class="ulink" href="http://www.apache.org/dist/uima/eclipse-update-site/" target="_top">http://www.apache.org/dist/uima/eclipse-update-site/
          </a>)in field
          <span class="quote">&#8220;<span class="quote">Work with:</span>&#8221;</span>
          and press <span class="quote">&#8220;<span class="quote">Enter</span>&#8221;</span>.
        </p>
      </li><li class="listitem">
        <p>
          Select <span class="quote">&#8220;<span class="quote">Apache UIMA Ruta</span>&#8221;</span> and (if not yet installed) <span class="quote">&#8220;<span class="quote">Apache UIMA Eclipse tooling and runtime support</span>&#8221;</span>
          by clicking into the related checkbox.
        </p>
      </li><li class="listitem">
        <p>
          Also select
          <span class="quote">&#8220;<span class="quote">Contact all update
            sites during install to find required software
          </span>&#8221;</span>
          and click on
          <span class="quote">&#8220;<span class="quote">Next</span>&#8221;</span>.
        </p>
      </li><li class="listitem">
        <p>
          On the next page, click <span class="quote">&#8220;<span class="quote">Next</span>&#8221;</span>
          again. Now, the license
          agreement site is displayed. To install UIMA Ruta read the license and
          choose
          <span class="quote">&#8220;<span class="quote">I accept the ...</span>&#8221;</span>
          if you agree to it. Then,
          click on <span class="quote">&#8220;<span class="quote">Finish</span>&#8221;</span>
        </p>
      </li></ol></div><p>
  </p>
  <p>
    </p><div class="figure"><a name="figure.ugr.tools.ruta.workbench.install.update"></a><div class="figure-contents">
      
      <div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="500"><tr><td align="center"><img src="images/tools/ruta/workbench/install/update.png" align="middle" width="500" alt="Eclipse update site."></td></tr></table></div>
    </div><p class="title"><b>Figure&nbsp;3.1.&nbsp; Eclipse update site
      </b></p></div><p><br class="figure-break">
  </p>
  <p>
    Now, UIMA Ruta is going to be installed.
    After the successful
    installation, switch to the UIMA Ruta
    perspective. To get an overview, see
    <a class="xref" href="#section.ugr.tools.ruta.workbench.overview" title="3.2.&nbsp;UIMA Ruta Workbench Overview">Section&nbsp;3.2, &#8220;UIMA Ruta Workbench Overview&#8221;</a>.
  </p>
  <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
    <p>
      It is sometimes necessary to increase to available PermGenSpace by adding 
      <span class="quote">&#8220;<span class="quote">-XX:PermSize=64M -XX:MaxPermSize=228M</span>&#8221;</span> to the config.ini file of your Eclipse installation.
    </p>
  </div>
  <p>
    Several times within this chapter we use a UIMA Ruta example
    project
    to illustrate the use of the UIMA Ruta Workbench.
    The <span class="quote">&#8220;<span class="quote">ExampleProject</span>&#8221;</span> project is part of the source release of UIMA Ruta (example-projects folder).
  </p>
  <p>
    To import this project into the workbench do
    <span class="quote">&#8220;<span class="quote">File <span class="symbol">&#8594;</span>
      Import...
    </span>&#8221;</span>
    . Select
    <span class="quote">&#8220;<span class="quote">Existing Projects into Workspace</span>&#8221;</span>
    under
    <span class="quote">&#8220;<span class="quote">General</span>&#8221;</span>
    . Select the
    <span class="quote">&#8220;<span class="quote">ExampleProject</span>&#8221;</span>
    directory
    in your file system as root directory and click on
    <span class="quote">&#8220;<span class="quote">Finish</span>&#8221;</span>
    . The
    example project is now available in your workspace.
  </p>
</div>

  <div class="section" title="3.2.&nbsp;UIMA Ruta Workbench Overview"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="section.ugr.tools.ruta.workbench.overview">3.2.&nbsp;UIMA Ruta Workbench Overview</h2></div></div></div>
  
  <p>
    The UIMA Ruta Workbench provides two main perspectives.
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
        <p>
          The
          <span class="quote">&#8220;<span class="quote">UIMA Ruta perspective</span>&#8221;</span>, which provides the main functionality for working on UIMA Ruta projects. See
          <a class="xref" href="#section.ugr.tools.ruta.workbench.ruta_perspective" title="3.4.&nbsp;UIMA Ruta Perspective">Section&nbsp;3.4, &#8220;UIMA Ruta Perspective&#8221;</a>.
        </p>
      </li><li class="listitem">
        <p>
          The
          <span class="quote">&#8220;<span class="quote">Explain perspective</span>&#8221;</span>, which provides functionality primarily used to explain how a set of rules
          are executed on input documents. See
          <a class="xref" href="#section.ugr.tools.ruta.workbench.explain_perspective" title="3.5.&nbsp;UIMA Ruta Explain Perspective">Section&nbsp;3.5, &#8220;UIMA Ruta Explain Perspective&#8221;</a>.
        </p>
      </li></ol></div><p>
  </p>
  <p>
    The following image shows the UIMA Ruta perspective.
    </p><div class="figure"><a name="figure.ugr.tools.ruta.workbench.overview.ruta_perspective"></a><div class="figure-contents">
      
      <div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="576"><tr><td align="center"><img src="images/tools/ruta/workbench/overview/screenshot_ruta_perspective_.png" align="middle" width="576" alt="The UIMA Ruta perspective."></td></tr></table></div>
    </div><p class="title"><b>Figure&nbsp;3.2.&nbsp; The UIMA Ruta perspective.
      </b></p></div><p><br class="figure-break">
    As you can see, the UIMA Ruta perspective provides an editor for editing documents, e.g.,
    UIMA Ruta scripts, and several views for different other tasks. The Script Explorer, for
    example, helps to manage your UIMA Ruta projects.
  </p>
  <p>
    The following
    <a class="xref" href="#table.ugr.tools.ruta.workbench.overview.views" title="Table&nbsp;3.1.&nbsp;UIMA Ruta views">Table&nbsp;3.1, &#8220;UIMA Ruta views&#8221;</a>
    lists all available UIMA Ruta views:
    </p><div class="table"><a name="table.ugr.tools.ruta.workbench.overview.views"></a><p class="title"><b>Table&nbsp;3.1.&nbsp;UIMA Ruta views</b></p><div class="table-contents">
      
      <table summary="UIMA Ruta views" style="border-collapse: collapse;border-top: 0.5pt solid black; border-bottom: 0.5pt solid black; border-left: 0.5pt solid black; border-right: 0.5pt solid black; "><colgroup><col class="c1"><col class="c2"></colgroup><thead><tr><th style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; " align="center">View</th><th style="border-bottom: 0.5pt solid black; " align="center">Detailed description</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">Annotation Test</td><td style="border-bottom: 0.5pt solid black; ">
              See
              <a class="xref" href="#section.ugr.tools.ruta.workbench.testing.usage" title="3.8.1.&nbsp;Usage">Section&nbsp;3.8.1, &#8220;Usage&#8221;</a>
            </td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">Applied Rules</td><td style="border-bottom: 0.5pt solid black; ">
              See
              <a class="xref" href="#section.ugr.tools.ruta.workbench.explain_perspective.applied_rules" title="3.5.1.&nbsp;Applied Rules">Section&nbsp;3.5.1, &#8220;Applied Rules&#8221;</a>
            </td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">Check Annotations</td><td style="border-bottom: 0.5pt solid black; ">
              See
              <a class="xref" href="#section.tools.ruta.workbench.check" title="3.10.&nbsp;Check Annotations view">Section&nbsp;3.10, &#8220;Check Annotations view&#8221;</a>
            </td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">Covering Rules</td><td style="border-bottom: 0.5pt solid black; ">
              See
              <a class="xref" href="#section.ugr.tools.ruta.workbench.explain_perspective.covering_rules" title="3.5.4.&nbsp;Covering Rules">Section&nbsp;3.5.4, &#8220;Covering Rules&#8221;</a>
            </td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">Created By</td><td style="border-bottom: 0.5pt solid black; ">
              See
              <a class="xref" href="#section.ugr.tools.ruta.workbench.explain_perspective.created_by" title="3.5.6.&nbsp;Created By">Section&nbsp;3.5.6, &#8220;Created By&#8221;</a>
            </td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">Failed Rules</td><td style="border-bottom: 0.5pt solid black; ">
              See
              <a class="xref" href="#section.ugr.tools.ruta.workbench.explain_perspective.matched_and_failed_rules" title="3.5.2.&nbsp;Matched Rules and Failed Rules">Section&nbsp;3.5.2, &#8220;Matched Rules and Failed Rules&#8221;</a>
            </td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">False Negative</td><td style="border-bottom: 0.5pt solid black; ">
              See
              <a class="xref" href="#section.ugr.tools.ruta.workbench.testing.usage" title="3.8.1.&nbsp;Usage">Section&nbsp;3.8.1, &#8220;Usage&#8221;</a>
            </td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">False Positive</td><td style="border-bottom: 0.5pt solid black; ">
              See
              <a class="xref" href="#section.ugr.tools.ruta.workbench.testing.usage" title="3.8.1.&nbsp;Usage">Section&nbsp;3.8.1, &#8220;Usage&#8221;</a>
            </td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">Matched Rules</td><td style="border-bottom: 0.5pt solid black; ">
              See
              <a class="xref" href="#figure.ugr.tools.ruta.workbench.explain_perspective.matched_and_failed_rules" title="Figure&nbsp;3.9.&nbsp; The views Matched Rules and Failed Rules">Figure&nbsp;3.9, &#8220; The views Matched Rules and Failed Rules
        &#8221;</a>
            </td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">Rule Elements</td><td style="border-bottom: 0.5pt solid black; ">
              See
              <a class="xref" href="#section.ugr.tools.ruta.workbench.explain_perspective.rule_elements" title="3.5.3.&nbsp;Rule Elements">Section&nbsp;3.5.3, &#8220;Rule Elements&#8221;</a>
            </td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">Rule List</td><td style="border-bottom: 0.5pt solid black; ">
              See
              <a class="xref" href="#section.ugr.tools.ruta.workbench.explain_perspective.rule_list" title="3.5.5.&nbsp;Rule List">Section&nbsp;3.5.5, &#8220;Rule List&#8221;</a>
            </td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">Statistics</td><td style="border-bottom: 0.5pt solid black; ">
              See
              <a class="xref" href="#section.ugr.tools.ruta.workbench.explain_perspective.statistics" title="3.5.7.&nbsp;Statistics">Section&nbsp;3.5.7, &#8220;Statistics&#8221;</a>
            </td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">Ruta Query</td><td style="border-bottom: 0.5pt solid black; ">
              See
              <a class="xref" href="#section.ugr.tools.ruta.workbench.ruta_query" title="3.7.&nbsp;Ruta Query View">Section&nbsp;3.7, &#8220;Ruta Query View&#8221;</a>
            </td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">TextRuler</td><td style="border-bottom: 0.5pt solid black; ">
              See
              <a class="xref" href="#section.tools.ruta.workbench.textruler" title="3.9.&nbsp;TextRuler">Section&nbsp;3.9, &#8220;TextRuler&#8221;</a>
            </td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">TextRuler Results</td><td style="border-bottom: 0.5pt solid black; ">
              See
              <a class="xref" href="#section.tools.ruta.workbench.textruler" title="3.9.&nbsp;TextRuler">Section&nbsp;3.9, &#8220;TextRuler&#8221;</a>
            </td></tr><tr><td style="border-right: 0.5pt solid black; ">True Positive</td><td style="">
              See
              <a class="xref" href="#section.ugr.tools.ruta.workbench.testing.usage" title="3.8.1.&nbsp;Usage">Section&nbsp;3.8.1, &#8220;Usage&#8221;</a>
            </td></tr></tbody></table>
    </div></div><p><br class="table-break">
  </p>
  <p>
    The following
    <a class="xref" href="#table.ugr.tools.ruta.workbench.overview.wizards" title="Table&nbsp;3.2.&nbsp;UIMA Ruta wizards">Table&nbsp;3.2, &#8220;UIMA Ruta wizards&#8221;</a>
    lists all UIMA Ruta wizards:
    </p><div class="table"><a name="table.ugr.tools.ruta.workbench.overview.wizards"></a><p class="title"><b>Table&nbsp;3.2.&nbsp;UIMA Ruta wizards</b></p><div class="table-contents">
      
      <table summary="UIMA Ruta wizards" style="border-collapse: collapse;border-top: 0.5pt solid black; border-bottom: 0.5pt solid black; border-left: 0.5pt solid black; border-right: 0.5pt solid black; "><colgroup><col class="c1"><col class="c2"></colgroup><thead><tr><th style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; " align="center">Wizard</th><th style="border-bottom: 0.5pt solid black; " align="center">Detailed description</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid black; ">Create UIMA Ruta project</td><td style="">
              See
              <a class="xref" href="#section.ugr.tools.ruta.workbench.projects.create_projects" title="3.3.1.&nbsp;UIMA Ruta create project wizard">Section&nbsp;3.3.1, &#8220;UIMA Ruta create project wizard&#8221;</a>
            </td></tr></tbody></table>
    </div></div><p><br class="table-break">
  </p>
</div>

  <div class="section" title="3.3.&nbsp;UIMA Ruta Projects"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="section.ugr.tools.ruta.workbench.projects">3.3.&nbsp;UIMA Ruta Projects</h2></div></div></div>
  
  <p>
    UIMA Ruta projects used within the UIMA Ruta Workbench need to have
    a certain folder structure. The parts of this folder structure are
    explained in
    <a class="xref" href="#table.ugr.tools.ruta.workbench.create_project.folder_strucutre" title="Table&nbsp;3.3.&nbsp;Project folder structure">Table&nbsp;3.3, &#8220;Project folder structure&#8221;</a>. To create a UIMA Ruta project it is recommended to use the provided
    wizard, explained in
    <a class="xref" href="#section.ugr.tools.ruta.workbench.projects.create_projects" title="3.3.1.&nbsp;UIMA Ruta create project wizard">Section&nbsp;3.3.1, &#8220;UIMA Ruta create project wizard&#8221;</a>. If this wizard is used, the required folder structure is
    automatically created.
  </p>

  <p>
    </p><div class="table"><a name="table.ugr.tools.ruta.workbench.create_project.folder_strucutre"></a><p class="title"><b>Table&nbsp;3.3.&nbsp;Project folder structure</b></p><div class="table-contents">
      
      <table summary="Project folder structure" style="border-collapse: collapse;border-top: 0.5pt solid black; border-bottom: 0.5pt solid black; border-left: 0.5pt solid black; border-right: 0.5pt solid black; "><colgroup><col class="c1"><col class="c2"></colgroup><thead><tr><th style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; " align="center">Folder</th><th style="border-bottom: 0.5pt solid black; " align="center">Description</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">script</td><td style="border-bottom: 0.5pt solid black; ">
              Source folder for UIMA Ruta scripts and packages.
            </td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">descriptor</td><td style="border-bottom: 0.5pt solid black; ">
              Build folder for UIMA components. Analysis engines and type
              systems
              are created automatically from the related script files.
            </td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">input</td><td style="border-bottom: 0.5pt solid black; ">
              Folder that contains the files that will be processed when
              launching a
              UIMA Ruta script. Such input files could be plain
              text,
              HTML or xmiCAS files.
            </td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">output</td><td style="border-bottom: 0.5pt solid black; ">
              Folder that contains the resulting xmiCAS files. One xmiCAS
              file is generated for each associated document in the input
              folder.
            </td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">resources</td><td style="border-bottom: 0.5pt solid black; ">
              Default folder for word lists, dictionaries and tables.
            </td></tr><tr><td style="border-right: 0.5pt solid black; ">test</td><td style="">
              Folder for test-driven development.
            </td></tr></tbody></table>
    </div></div><p><br class="table-break">
  </p>
  <p>
    <a class="xref" href="#figure.ugr.tools.ruta.workbench.projects.test_project" title="Figure&nbsp;3.3.&nbsp;A newly created UIMA Ruta project">Figure&nbsp;3.3, &#8220;A newly created UIMA Ruta project&#8221;</a>
    shows a project, newly created with the wizard.

    </p><div class="figure"><a name="figure.ugr.tools.ruta.workbench.projects.test_project"></a><div class="figure-contents">
      
      <div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="300"><tr><td align="center"><img src="images/tools/ruta/workbench/projects/test_project.PNG" align="middle" width="300" alt="A newly created UIMA Ruta project."></td></tr></table></div>
    </div><p class="title"><b>Figure&nbsp;3.3.&nbsp;A newly created UIMA Ruta project</b></p></div><p><br class="figure-break">
  </p>

  <div class="section" title="3.3.1.&nbsp;UIMA Ruta create project wizard"><div class="titlepage"><div><div><h3 class="title" id="section.ugr.tools.ruta.workbench.projects.create_projects">3.3.1.&nbsp;UIMA Ruta create project wizard</h3></div></div></div>
    
    <p>
      To create a new UIMA Ruta project, switch to UIMA Ruta perspective
      and click <span class="quote">&#8220;<span class="quote">File <span class="symbol">&#8594;</span> New <span class="symbol">&#8594;</span> UIMA Ruta Project</span>&#8221;</span>. This opens the corresponding wizard.
    </p>

    <p>
      <a class="xref" href="#figure.ugr.tools.ruta.workbench.projects.create_projects.wizard1" title="Figure&nbsp;3.4.&nbsp;Wizard start page">Figure&nbsp;3.4, &#8220;Wizard start page&#8221;</a>
      shows the start page of the wizard.
      </p><div class="figure"><a name="figure.ugr.tools.ruta.workbench.projects.create_projects.wizard1"></a><div class="figure-contents">
        
        <div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="450"><tr><td align="center"><img src="images/tools/ruta/workbench/projects/wizard1.PNG" align="middle" width="450" alt="Wizard start page."></td></tr></table></div>
      </div><p class="title"><b>Figure&nbsp;3.4.&nbsp;Wizard start page</b></p></div><p><br class="figure-break">
    </p>
    <p>
      To create a simple UIMA Ruta project, enter a project name for
      your project and click
      <span class="quote">&#8220;<span class="quote">Finish</span>&#8221;</span>. This will create everything you need to start.
    </p>
    <p>
      Other possible settings on this page are the desired location of
      the project,
      the interpreter to use and the working set you wish to
      work on, all of them are self-explaining.
    </p>
    
    <p>
      <a class="xref" href="#figure.ugr.tools.ruta.workbench.projects.create_projects.wizard2" title="Figure&nbsp;3.5.&nbsp;Wizard second page">Figure&nbsp;3.5, &#8220;Wizard second page&#8221;</a>
      shows the second page of the wizard.
      </p><div class="figure"><a name="figure.ugr.tools.ruta.workbench.projects.create_projects.wizard2"></a><div class="figure-contents">
        
        <div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="450"><tr><td align="center"><img src="images/tools/ruta/workbench/projects/wizard2.PNG" align="middle" width="450" alt="Wizard second page."></td></tr></table></div>
      </div><p class="title"><b>Figure&nbsp;3.5.&nbsp;Wizard second page</b></p></div><p><br class="figure-break">
    </p>

  </div>

</div>

  <div class="section" title="3.4.&nbsp;UIMA Ruta Perspective"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="section.ugr.tools.ruta.workbench.ruta_perspective">3.4.&nbsp;UIMA Ruta Perspective</h2></div></div></div>
  
  <p>
    The UIMA Ruta perspective is the main view to manage UIMA Ruta
    projects. There are several views associated with the UIMA Ruta
    perspective: Annotation Test, Annotation Browser, Selection,
    TextRuler and Ruta Query. Since Annotation Test, TextRuler and
    Ruta Query have a stand-alone functionality. They are explained
    in separate sections.
  </p>

  <p>
    To make it possible to reproduce all of the examples used below,
    switch to the UIMA Ruta Explain perspective within your Eclipse
    workbench.
    Import the UIMA Ruta example project and open the main
    UIMA Ruta script file 'Main.ruta'. Now press the 'Run' button (green
    arrow) and wait for the end of execution. Open the resulting xmiCAS
    file 'Test1.txt.xmi', which you can find in the output folder.
  </p>

  <div class="section" title="3.4.1.&nbsp;Annotation Browser"><div class="titlepage"><div><div><h3 class="title" id="section.ugr.tools.ruta.workbench.ruta_perspective.annotation_browser">3.4.1.&nbsp;Annotation Browser</h3></div></div></div>
    
    <p>
      The Annotation Browser can be used to view the annotations
      created by the execution of a UIMA Ruta project. If an xmiCAS file
      is opened and active in the editor, the related annotations are shown
      in this view.
    </p>
    <p>
      The result of the execution of the UIMA Ruta example project is
      shown in <a class="xref" href="#figure.ugr.tools.ruta.workbench.ruta_perspective.annotation_browser" title="Figure&nbsp;3.6.&nbsp; Annotation Browser view">Figure&nbsp;3.6, &#8220; Annotation Browser view
        &#8221;</a>.
      You can see that there are 5 annotations of 5 different types in the document. 
      Highlighting of certain types can be controlled by the checkboxes in the tree view. 
      The names of the types are abbreviated by their package constituents. Full type names are provided by tooltips
      and can be copied into the clipboard by hitting 'ctrl + c'. 
      This can be especially useful to paste a type name into the Query View.    
    </p>
    <p>
      </p><div class="figure"><a name="figure.ugr.tools.ruta.workbench.ruta_perspective.annotation_browser"></a><div class="figure-contents">
        
        <div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="300"><tr><td align="center"><img src="images/tools/ruta/workbench/ruta/AnnotationBrowser_2.2.0.png" align="middle" width="300" alt="Annotation Browser view."></td></tr></table></div>
      </div><p class="title"><b>Figure&nbsp;3.6.&nbsp; Annotation Browser view
        </b></p></div><p><br class="figure-break">
    </p>
    <p>
      Moreover, this view has two possible filters. Using the
      <span class="quote">&#8220;<span class="quote">Only types with...</span>&#8221;</span>-filter leads to a list containing only those types that contain
      the entered text. 
      The <span class="quote">&#8220;<span class="quote">Only annotations with...</span>&#8221;</span>-filter leads to an analogous list. 
      Both list filters can be quickly activated by hitting the return key. 
    </p>
	<p>
		Type highlighting can be reset by the action represented by a
		switched-off light bulb at the top of the view. 
		The light bulb that is turned on sets all types visible in the tree view of the page highlighted in the CAS editor.   
	</p>
	<p>
      The offsets of selected annotations can be modified with ctrl + u (reduce begin), ctrl + i (increase begin), ctrl + o (reduce end), and ctrl + p (increase end).
    </p>
    <p>
      The user can choose whether parent types are displayed using the preference page <span class="quote">&#8220;<span class="quote">UIMA Cas Editor -&gt; Cas Editor Views</span>&#8221;</span>.
    </p>
  </div>

  <div class="section" title="3.4.2.&nbsp;Selection"><div class="titlepage"><div><div><h3 class="title" id="section.ugr.tools.ruta.workbench.ruta_perspective.selection">3.4.2.&nbsp;Selection</h3></div></div></div>
    
    <p>
      The Selection view is very similar to the Annotation Browser
      view, but only shows annotations that affect a specific text passage.
      To get such a list, click on any position in the opened xmiCAS
      document or select a certain text passage.
    </p>
    <p>
      If you select the text passage
      <code class="literal">2008</code>, the Selection view will be generated as shown in
      <a class="xref" href="#figure.ugr.tools.ruta.workbench.ruta_perspective.annotation_browser" title="Figure&nbsp;3.6.&nbsp; Annotation Browser view">Figure&nbsp;3.6, &#8220; Annotation Browser view
        &#8221;</a>.
    </p>
    <p>
      </p><div class="figure"><a name="figure.ugr.tools.ruta.workbench.ruta_perspective.selection"></a><div class="figure-contents">
        
        <div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="560"><tr><td align="center"><img src="images/tools/ruta/workbench/ruta/selection.png" align="middle" width="560" alt="Selection view."></td></tr></table></div>
      </div><p class="title"><b>Figure&nbsp;3.7.&nbsp; Selection view
        </b></p></div><p><br class="figure-break">
    </p>
    <p>
      The Selection view has the same filtering and modification options as
      described in Annotation Browser view.
    </p>
  </div>

</div>
  
  <div class="section" title="3.5.&nbsp;UIMA Ruta Explain Perspective"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="section.ugr.tools.ruta.workbench.explain_perspective">3.5.&nbsp;UIMA Ruta Explain Perspective</h2></div></div></div>
  
  <p>
    Writing new rules is laborious, especially if the newly written
    rules do not behave as expected. The UIMA Ruta system is able to
    record the application of each single rule and block in order to
    provide an explanation of the rule inference and a
    minimal debugging functionality. The information about the application of the rules
    itself is stored in the resulting xmiCAS output file, if the parameters
    of the executed engine are configured correctly. The simplest way to
    generate these explanation information is to click on the common 'Debug' button (looks like a green bug)
    while having the UIMA Ruta script file you want to debug active in
    your editor. The current UIMA Ruta file will then be executed on the text files in the input
    directory and xmiCAS are created in the output directory containing the
    additional UIMA feature structures describing the
    rule inference. To show the newly created execution information, you can either open the
    Explain perspective or open the necessary views separately and arrange
    them as you like. There are eight views that display information about
    the execution of the rules: Applied Rules, Covering Rules, Created By,
    Failed Rules, Matched Rules, Rule Elements, Rule List
    and Statistics. All of theses views are further explained in detail, using the
    UIMA Ruta example project for examples.
  </p>

  <p>
    To make it possible to reproduce all of the examples used below,
    switch to the UIMA Ruta Explain perspective within your Eclipse
    workbench.
    Import the UIMA Ruta example project and open the main
    Ruta script file 'Main.ruta'. Now press the 'Debug' button
    and wait
    for the end of execution. Open the resulting xmiCAS file
    'Test1.txt.xmi', which you can find in the output folder.
  </p>

  <div class="section" title="3.5.1.&nbsp;Applied Rules"><div class="titlepage"><div><div><h3 class="title" id="section.ugr.tools.ruta.workbench.explain_perspective.applied_rules">3.5.1.&nbsp;Applied Rules</h3></div></div></div>
    
    <p>
      The Applied Rules view displays structured information about all
      rules that tried to apply to the input documents.
    </p>
    <p>
      The structure is as follows: if BLOCK constructs were used in the
      executed Ruta file, the rules contained in that block will be
      represented as child node in the tree of the view. Each Ruta
      file is a BLOCK construct itself and named after the file. The
      root node of the view is, therefore, always a BLOCK containing the rules of the
      executed UIMA Ruta script. Additionally, if a rule calls a different
      Ruta file, then the root block of that file is the child of the
      calling rule.
    </p>
    <p>
      If you double-click on one of the rules, the related script file
      is opened within the editor and the rule itself is selected.
    </p>
    <p>
      <a class="xref" href="#section.ugr.tools.ruta.workbench.explain_perspective" title="3.5.&nbsp;UIMA Ruta Explain Perspective">Section&nbsp;3.5, &#8220;UIMA Ruta Explain Perspective&#8221;</a>
      shows the whole rule hierarchy resulting from the UIMA Ruta example
      project. The root of the whole hierarchy is the BLOCK associated to
      the 'Main.ruta' script. On the next level, the rules called by the
      'Main.ruta' script are listed. Since there is a call to each of the
      script files 'Year.ruta',
      'Author.ruta' and 'Title.ruta', these are included
      into the hierarchy, each forming their own block.
    </p>
    <p>
      The following image shows the UIMA Ruta Applied Rules view.
      </p><div class="figure"><a name="figure.ugr.tools.ruta.workbench.explain_perspective.applied_rules"></a><div class="figure-contents">
        
        <div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="576"><tr><td align="center"><img src="images/tools/ruta/workbench/explain/applied_rules_view.png" align="middle" width="576" alt="Applied Rules view."></td></tr></table></div>
      </div><p class="title"><b>Figure&nbsp;3.8.&nbsp; Applied Rules view
        </b></p></div><p><br class="figure-break">
    </p>
    <p>
      Besides the hierarchy, the view shows how often a rule tried to match
      in total and how often it succeeded. This is shown in brackets at the
      beginning of each rule entry. The Applied Rules view tells us
      that the rule
      <code class="literal">NUM{REGEXP("19..|20..") -&gt; MARK(Year)};</code>
      within script 'Year.ruta' tried to match twice but only succeeded once.
    </p>
    <p>
      After this information, the rule itself is given. Notice that
      each rule is given with all the parameters it has been executed.
      Have a look at rule entry
      <code class="literal">[1/1]Document{-&gt;MARKFAST(FirstName,FirstNameList,false,0,true)}
      </code> within BLOCK Author. The rule obviously has been executed with five
      parameters. If you double-click on this rule, you will get to the
      rule in the script file 'Author.ruta'. It shows the rule as follows:
      <code class="literal">Document{-&gt; MARKFAST(FirstName, FirstNameList)};</code>. This means the last three parameters have been default values used
      to execute the rule.
    </p>
    <p>
      Additionally, some profiling information, giving details about
      the absolute time and the percentage of total execution time the rule
      needed, is added at the end of each rule entry.
    </p>
    <p>
      The selection (single-click) of a rule in this view will
      directly change the information visualized in the views Failed Rules
      and Matched Rules.
    </p>
  </div>

  <div class="section" title="3.5.2.&nbsp;Matched Rules and Failed Rules"><div class="titlepage"><div><div><h3 class="title" id="section.ugr.tools.ruta.workbench.explain_perspective.matched_and_failed_rules">3.5.2.&nbsp;Matched Rules and Failed Rules</h3></div></div></div>
    
    <p>
      If a rule is selected (single-click) in the Applied Rules view,
      then the Matched Rules view displays all instances (text passages) on
      which the rule matched. On the contrary, the Failed Rules view shows
      the instances on which the rule tried but failed to match.
    </p>
    <p>
      Select rule <code class="literal">[2/3]Name{-PARTOF(NameListPart)} NameLinker[1,2]{-&gt;
        MARK(NameListPart,1,2)};</code> within BLOCK Author.
      <a class="xref" href="#figure.ugr.tools.ruta.workbench.explain_perspective.matched_and_failed_rules" title="Figure&nbsp;3.9.&nbsp; The views Matched Rules and Failed Rules">Figure&nbsp;3.9, &#8220; The views Matched Rules and Failed Rules
        &#8221;</a>
      shows the text passages this rule tried to match on. One did not
      succeed. It is displayed within the Failed Rules view. Two
      succeeded and are shown in the Matched Rules view.
    </p>
    <p>
      The following image shows the UIMA Ruta Applied Rules view.
      </p><div class="figure"><a name="figure.ugr.tools.ruta.workbench.explain_perspective.matched_and_failed_rules"></a><div class="figure-contents">
        
        <div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="576"><tr><td align="center"><img src="images/tools/ruta/workbench/explain/matched_and_failed.png" align="middle" width="576" alt="The views Matched Rules and Failed Rules."></td></tr></table></div>
      </div><p class="title"><b>Figure&nbsp;3.9.&nbsp; The views Matched Rules and Failed Rules
        </b></p></div><p><br class="figure-break">
    </p>
    <p>
      The selection (single-click) of one of the text passages in
      either Matched Rules view or Failed Rules view will directly change
      the information visualized in the Rule Elements view.
    </p>
  </div>

  <div class="section" title="3.5.3.&nbsp;Rule Elements"><div class="titlepage"><div><div><h3 class="title" id="section.ugr.tools.ruta.workbench.explain_perspective.rule_elements">3.5.3.&nbsp;Rule Elements</h3></div></div></div>
    
    <p>
      If you select one of the listed instances in the Matched or
      Failed Rules view, then the Rule Elements view contains a listing
      of the rule elements and their conditions belonging to the related rule
      used on the specific text passage. There is detailed
      information available on what text passage each rule element did or
      did not match and which condition did or did not evaluate true.
    </p>
    <p>
      Within the Rule Elements view, each rule element generates its
      own explanation hierarchy. On the root level, the rule element itself
      is given. An apostrophe at the beginning of the rule element
      indicates that this rule was the anchor for the rule execution. On
      the next level, the text passage on which the rule element tried to
      match on is given. The last level explains, why the rule element
      did or did not match. The first entry on this level tells, if the text
      passage is of the requested annotation type. If it is, a green hook
      is shown in front of the requested type. Otherwise, a red cross is
      shown. In the following the rule conditions and their evaluation on
      the given text passage are shown.
    </p>
    <p>
      In the previous example, select the listed instance
      <code class="literal">Bethard, S.</code>. The Rule Elements view shows the related explanation displayed
      in <a class="xref" href="#figure.ugr.tools.ruta.workbench.explain_perspective.rule_elements" title="Figure&nbsp;3.10.&nbsp; The views Matched Rules and Failed Rules">Figure&nbsp;3.10, &#8220; The views Matched Rules and Failed Rules
        &#8221;</a>.
    </p>
    <p>
      The following image shows the UIMA Ruta Rule Elements view.
      </p><div class="figure"><a name="figure.ugr.tools.ruta.workbench.explain_perspective.rule_elements"></a><div class="figure-contents">
        
        <div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="250"><tr><td align="center"><img src="images/tools/ruta/workbench/explain/rule_elements.png" align="middle" width="250" alt="The Rule Elements view."></td></tr></table></div>
      </div><p class="title"><b>Figure&nbsp;3.10.&nbsp; The views Matched Rules and Failed Rules
        </b></p></div><p><br class="figure-break">
    </p>
    <p>
      As you can see, the first rule element <code class="literal">Name{-PARTOF(NameListPart)}</code>
      matched on the text passage <code class="literal">Bethard, S.</code>
      since it is firstly annotated with a <span class="quote">&#8220;<span class="quote">Name</span>&#8221;</span> annotation and secondly it is not part of an annotation
      <span class="quote">&#8220;<span class="quote">NameListPart</span>&#8221;</span>. However, as this first text passage is not followed by a
      <span class="quote">&#8220;<span class="quote">NameLinker</span>&#8221;</span> annotation the whole rule fails.
    </p>
  </div>

  <div class="section" title="3.5.4.&nbsp;Covering Rules"><div class="titlepage"><div><div><h3 class="title" id="section.ugr.tools.ruta.workbench.explain_perspective.covering_rules">3.5.4.&nbsp;Covering Rules</h3></div></div></div>
    
    <p>
      This views is very similar to the Applied Rules view, but
      displays only rules and blocks under a given selection. If the user
      clicks on any position in the xmiCAS document, a Covering Rules view
      is generated containing only rule elements that affect that position
      in the document. The Matched Rules,
      Failed Rules and Rule Elements
      views only contain match
      information of that position.
    </p>
  </div>

  <div class="section" title="3.5.5.&nbsp;Rule List"><div class="titlepage"><div><div><h3 class="title" id="section.ugr.tools.ruta.workbench.explain_perspective.rule_list">3.5.5.&nbsp;Rule List</h3></div></div></div>
    
    <p>
      This views is very similar to the Applied Rules view and the
      Covering Rules view, but displays only rules and NO blocks under a
      given selection. If the user clicks on any position in the xmiCAS
      document, a list of rules that matched or tried to match on that
      position in the document is generated within the Rule List view. The
      Matched Rules, Failed Rules and Rule Elements views only contain
      match information of that position. Additionally, this view provides
      a text field for filtering the rules. Only those rules remain that
      contain the entered text.
    </p>
  </div>

  <div class="section" title="3.5.6.&nbsp;Created By"><div class="titlepage"><div><div><h3 class="title" id="section.ugr.tools.ruta.workbench.explain_perspective.created_by">3.5.6.&nbsp;Created By</h3></div></div></div>
    
    <p>
      The Created By view tells you which rule created a specific
      annotation. To get this information, select an annotation in the
      Annotation Browser. After doing this, the Created By view shows the
      related information.
    </p>
    <p>
      To see how this works, use the example project and go to the
      Annotation view. Select the
      <span class="quote">&#8220;<span class="quote">d.u.e.Year</span>&#8221;</span>
      annotation <span class="quote">&#8220;<span class="quote">(2008)</span>&#8221;</span>. The Created By view displays the information, shown in
      <a class="xref" href="#figure.ugr.tools.ruta.workbench.explain_perspective.created_by" title="Figure&nbsp;3.11.&nbsp; The Created By view">Figure&nbsp;3.11, &#8220; The Created By view
        &#8221;</a>. 
      You can double-click on the shown rule to jump to the related
      document <span class="quote">&#8220;<span class="quote">Year.ruta</span>&#8221;</span>.
    </p>
    <p>
      The following image shows the UIMA Ruta Created By view.
      </p><div class="figure"><a name="figure.ugr.tools.ruta.workbench.explain_perspective.created_by"></a><div class="figure-contents">
        
        <div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="560"><tr><td align="center"><img src="images/tools/ruta/workbench/explain/created_by.png" align="middle" width="560" alt="The Created By view."></td></tr></table></div>
      </div><p class="title"><b>Figure&nbsp;3.11.&nbsp; The Created By view
        </b></p></div><p><br class="figure-break">
    </p>
  </div>

  <div class="section" title="3.5.7.&nbsp;Statistics"><div class="titlepage"><div><div><h3 class="title" id="section.ugr.tools.ruta.workbench.explain_perspective.statistics">3.5.7.&nbsp;Statistics</h3></div></div></div>
    
    <p>
      The Statistics view displays profiling information for the used
      conditions and actions of the UIMA Ruta language. Three
      numbers are
      given for each element: The total time of execution, the amount of
      executions and the average time per execution.
    </p>
    <p>
      The following image shows the UIMA Ruta Statistics view generated
      form the UIMA Ruta example project.
      </p><div class="figure"><a name="figure.ugr.tools.ruta.workbench.explain_perspective.statistics"></a><div class="figure-contents">
        
        <div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="300"><tr><td align="center"><img src="images/tools/ruta/workbench/explain/statistics.png" align="middle" width="300" alt="The Statistics view."></td></tr></table></div>
      </div><p class="title"><b>Figure&nbsp;3.12.&nbsp; The Statistics view
        </b></p></div><p><br class="figure-break">
    </p>
  </div>

</div>
  
  <div class="section" title="3.6.&nbsp;UIMA Ruta CDE perspective"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="section.tools.ruta.workbench.cde">3.6.&nbsp;UIMA Ruta CDE perspective</h2></div></div></div>
  
  <p>
    The UIMA Ruta CDE (Constraint-Driven Evaluation) provides some views and functionality to investigate and evaluate a set
    of annotated documents using domain and background knowledge formalized as constraints and UIMA Ruta rules. 
    <a class="xref" href="#figure.tools.ruta.workbench.cde" title="Figure&nbsp;3.13.&nbsp;The UIMA Ruta cde framework">Figure&nbsp;3.13, &#8220;The UIMA Ruta cde framework
      &#8221;</a> provides an overview of the perspective. Its views are described in the following.
  </p>
  <div class="figure"><a name="figure.tools.ruta.workbench.cde"></a><div class="figure-contents">
      
      <div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="776"><tr><td align="center"><img src="images/tools/ruta/workbench/cde/cde.png" align="middle" width="776" alt="UIMA Ruta CDE perspective"></td></tr></table></div>
    </div><p class="title"><b>Figure&nbsp;3.13.&nbsp;The UIMA Ruta cde framework
      </b></p></div><br class="figure-break">
  <div class="section" title="3.6.1.&nbsp;CDE Documents view"><div class="titlepage"><div><div><h3 class="title" id="section.tools.ruta.workbench.cde.documents">3.6.1.&nbsp;CDE Documents view</h3></div></div></div>
  
  <p>
  This view provides the general functionality to specify, which set of documents should be evaluated.  The green start button in the toolbar 
  starts the evaluation process with the given configuration specified in the different views.
  The text field <span class="quote">&#8220;<span class="quote">Documents</span>&#8221;</span> specifies the set of documents that have been annotated by an arbitrary model or set of rules. 
  These xmiCAS documents can contain additional annotations, which are used by the simple rule-based constraints. The text field <span class="quote">&#8220;<span class="quote">Test Data</span>&#8221;</span>
  specifies an optional folder with gold standard documents. These documents can be applied for comparing the resulting CDE value to an F1 score.
  The text field <span class="quote">&#8220;<span class="quote">Type System</span>&#8221;</span> refers to a type system descriptor, which defines all types that are needed for the evaluation.
  Each text field is sensitive to drag and drop. The use can select a folder in the script explorer and drag and drop it on the text field.
  Directly below the text fields, the values of different evaluation measures are given comparing the resulting CDE value to the F1 score. 
  These values are of course only available, if annotated gold standard data is specified in the text field <span class="quote">&#8220;<span class="quote">Test Data</span>&#8221;</span>.
  </p>
  <p>
    The table at the bottom of the view contains all documents that are inspected. 
    The intervals specifying the color of the icon of each documents dependent of the CDE result can be set in the preference page.
    If the evaluation has finished, then the CDE value is displayed and additionally the F1 score, if available. The table is sortable.
    A double-click on a documents opens it in the CAS Editor.
  </p>
  </div>
  <div class="section" title="3.6.2.&nbsp;CDE Constraints view"><div class="titlepage"><div><div><h3 class="title" id="section.tools.ruta.workbench.cde.constraints">3.6.2.&nbsp;CDE Constraints view</h3></div></div></div>
  
  <p>This view specifies the currently applied constraints and their weights. This list is used to calculate the overall CDE value
  of one document: the average of the weighted sum. The buttons in the toolbar of the view export and import the constraint using a simple xml format.
  The buttons in the right part of the view can modify the list of the constraints. Currently, three types of constraints are supported: 
  Simple UIMA Ruta rules, a list of simple UIMA Ruta rules and word distribution constraints. All constraints return a value between 0 and 1. 
  The constraints based on UIMA Ruta rules return the ratio how often the rule was applied to how often the rules tried to apply. The rule
  <span class="quote">&#8220;<span class="quote">Author{STARTSWITH(Reference)};</span>&#8221;</span>, for example, returns 1, if all author annotations start with a reference annotation. The word distribution 
  constraints refer to a txt file in which each line has the format <span class="quote">&#8220;<span class="quote">"Proceedings":Booktitle 0.95, Journal 0.05</span>&#8221;</span> specifying
  the distribution of the word proceedings concerning the interesting annotations. If no quotes are given for the first term, then the term is interpreted as an annotation type.
  The result value is currently calculated by using the cosine similarity of the expected and observed frequencies.
  </p>
  </div>
  <div class="section" title="3.6.3.&nbsp;CDE Result view"><div class="titlepage"><div><div><h3 class="title" id="section.tools.ruta.workbench.cde.result">3.6.3.&nbsp;CDE Result view</h3></div></div></div>
  
  <p>
    The result view displays the result values of each constraint for the document that is selected in the CDE Documents view.
  </p>
  </div>
</div>
  
  <div class="section" title="3.7.&nbsp;Ruta Query View"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="section.ugr.tools.ruta.workbench.ruta_query">3.7.&nbsp;Ruta Query View</h2></div></div></div>
  
  <p> With the Query View, the UIMA Ruta language can be used to write queries on a set of
    documents. A query is simply a set of UIMA Ruta rules. Each query returns a list of all text
    passages the query applies to. For example, if you have a set of annotated documents containing
    a number of Author annotations, you could use the Query View to get a list of all the author
    names associated with these annotations.
    The set of relevant files can be restricted by a regular expression over the file names, e.g., "files_0[0-9]\\.xmi".
  </p>
  <p>
    </p><div class="figure"><a name="figure.ugr.tools.ruta.workbench.ruta_query.query_view"></a><div class="figure-contents">
      
      <div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="576"><tr><td align="center"><img src="images/tools/ruta/workbench/query/Query2.2.0.png" align="middle" width="576" alt="Query View"></td></tr></table></div>
    </div><p class="title"><b>Figure&nbsp;3.14.&nbsp;The Query View.
        <span class="bold">(1)</span>
        Start Button;
        <span class="bold">(2)</span>
        Export Button</b></p></div><p><br class="figure-break">
  </p>
  <p>
    Use the Query view as follows:
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
        <p>
          The field
          <span class="quote">&#8220;<span class="quote">Query Data</span>&#8221;</span>
          specifies the folder containing the documents on which the query should be executed. You
          can either click on the button next to the field to specify the folder by browsing through
          the file system or you can drag and drop a folder directly into the field. If the
          checkbox is activated, all subfolders are included.
        </p>
      </li><li class="listitem">
        <p>
          The field
          <span class="quote">&#8220;<span class="quote">Type System</span>&#8221;</span>
          has to contain a type system or a UIMA Ruta script that specifies all types that are used
          in the query. You can either click on the button next to the field to specify the type
          system by browsing through the file system or you can drag and drop a type system
          directly into the field.
        </p>
      </li><li class="listitem">
        <p> The query in form of one or more UIMA Ruta rules is specified in the text field in
          the middle of the view.</p>
      </li><li class="listitem">
        <p> After pressing the start button, the query is started. The results are subsequently
          displayed in the bottom text field.</p>
      </li></ol></div><p>
  </p>
  <p> The resulting list consists of all text passages the query applied to. Above the text
    field, information about the entire number of matches and the number of different documents the
    query applied to is given. Each item in the list shows both the matched text passage and in
    brackets the document related to the text passage. By double-clicking on one of the listed
    items, the related document is opened in the editor and the matched text passage is selected. If
    the related document is already open you can jump to another matched text passage within the the
    same document with one click on the listed item. Of course, this text passage is selected. 
    By clicking on the export button, a list of all matched text passaged is showed in a
    separate window. For further usage, e.g. as a list of authors in another UIMA Ruta project,
    copy the content of this window to another text file.
  </p>
  <p> The screenshot shows an example where a rule is used to find occurrences of years within
    brackets in the input file of the UIMA Ruta example. After pressing the run button the result
    list contains all occurrences. Recognize that the rule does not create any annotation. The list
    lists all rule matches, not the created annotations.
  </p>
</div>
  
  <div class="section" title="3.8.&nbsp;Testing"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="section.ugr.tools.ruta.workbench.testing">3.8.&nbsp;Testing</h2></div></div></div>
  
  <p> The UIMA Ruta Workbench comes bundled with its own testing environment that allows you to
    test and evaluate UIMA Ruta scripts. It provides full back-end testing capabilities and allows
    you to examine test results in detail.
  </p>
  <p> To test the quality of a written UIMA Ruta script, the testing procedure compares a
    previously annotated gold standard file with the resulting xmiCAS file created by the selected
    UIMA Ruta script. As a product of the testing operation a new xmiCAS file will be created,
    containing detailed information about the test results. The evaluators compare the offsets of
    annotations and, depending on the selected evaluator, add true positive, false positive or false
    negative annotations for each tested annotation to the resulting xmiCAS file. Afterwards
    precision, recall and f1-score are calculated for each test file and each type in the test file.
    The f1-score is also calculated for the whole test set. The testing environment consists of four
    views: Annotation Test, True Positive, False Positive and False Negative. The Annotation Test
    view is by default associated with the UIMA Ruta perspective.
  </p>
  <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
    There are two options for choosing the types that should be evaluated, which is specified by the preference <span class="quote">&#8220;<span class="quote">Use all types</span>&#8221;</span>.
    If this preference is activated (by default), then the user has to selected the types using the toolbar in the view. 
    There are button for selecting the included and excluded types. If this preference is deactivated, 
    then only the types present in the current test document are evaluated. This can result in missing false positive, if 
    the an annotation of a specific type was created by the rules and no annotation of this type is present in the test document.
  </p></div>
  <p>
    <a class="xref" href="#figure.ugr.tools.ruta.workbench.testing.script_explorer" title="Figure&nbsp;3.15.&nbsp;Test folder structure.">Figure&nbsp;3.15, &#8220;Test folder structure. &#8221;</a>
    shows the script explorer. Every UIMA Ruta project contains a folder called
    <span class="quote">&#8220;<span class="quote">test</span>&#8221;</span>. This folder is the default location for the test-files. In the folder each script file has its
    own subfolder with a relative path equal to the scripts package path in the
    <span class="quote">&#8220;<span class="quote">script</span>&#8221;</span> folder. This folder contains the test files. In every scripts test folder, you will also find a
    result folder where the results of the tests are saved. If you like to use test files from
    another location in the file system, the results will be saved in the
    <span class="quote">&#8220;<span class="quote">temp</span>&#8221;</span> subfolder of the project's test folder. All files in the temp folder will be deleted once
    Eclipse is closed.
  </p>
  <p>
    </p><div class="figure"><a name="figure.ugr.tools.ruta.workbench.testing.script_explorer"></a><div class="figure-contents">
      
      <div class="mediaobject" align="center"><img src="images/tools/ruta/workbench/testing/script_explorer.png" align="middle" alt="The test folder structure."></div>
    </div><p class="title"><b>Figure&nbsp;3.15.&nbsp;Test folder structure. </b></p></div><p><br class="figure-break">
  </p>
  <div class="section" title="3.8.1.&nbsp;Usage"><div class="titlepage"><div><div><h3 class="title" id="section.ugr.tools.ruta.workbench.testing.usage">3.8.1.&nbsp;Usage</h3></div></div></div>
    
    <p> This section describes the general proceeding when using the testing environment. </p>
    <p>
      Currently, the testing environment has no own perspective associated to it. It is recommended
      to start within the UIMA Ruta perspective. There, the Annotation Test view is open by
      default. The True Positive, False Positive and False Negative views have to be opened
      manually:
      <span class="quote">&#8220;<span class="quote">Window -&gt; Show View -&gt; True Positive/False Positive/False Negative </span>&#8221;</span>.
    </p>
    <p> To explain the usage of the UIMA Ruta testing environment, the UIMA Ruta example project
      is used again. Open this project. 
      Firstly, one has to select a script for testing: UIMA Ruta will always test the script, that
      is currently open and active in the script editor. So, open the
      <span class="quote">&#8220;<span class="quote">Main.ruta</span>&#8221;</span>
      script file of the UIMA Ruta example project.
      The next <a class="link" href="#figure.ugr.tools.ruta.workbench.testing.annotation_test_initial_view" title="Figure&nbsp;3.16.&nbsp; The Annotation Test view. Button from left to right: Start Test; Select excluded type; Select included type; Select evaluator/preferences; Export to CSV; Extend Classpath">figure</a>.
      shows the Annotation Test view after doing this.
    </p>
    <p>
      </p><div class="figure"><a name="figure.ugr.tools.ruta.workbench.testing.annotation_test_initial_view"></a><div class="figure-contents">
        
        <div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="576"><tr><td align="center"><img src="images/tools/ruta/workbench/testing/annotation_test_initial_view_2_2_0.png" align="middle" width="576" alt="The Annotation Test view."></td></tr></table></div>
      </div><p class="title"><b>Figure&nbsp;3.16.&nbsp;
          The Annotation Test view. Button from left to right:
          Start Test; Select excluded type; Select included type; Select evaluator/preferences; Export to CSV; Extend Classpath
        </b></p></div><p><br class="figure-break">
    </p>
    <p> All control elements that are needed for the interaction with the testing environment
      are located here. At the top right, there is the buttons bar. At the top left
      of the view the name of the script that is going to be tested is shown. It is
      always equal to the script active in the editor. Below this, the test list is
      located. This list contains the different files for testing. Right next to the name of the script
      file you can select the desired view. Right to this you get statistics
      over all ran tests: the number of all true positives (TP), false positives (FP) and false
      negatives (FN). In the field below, you will find a table with statistic
      information for a single selected test file. To change this view, select a file in the test
      list field. The table shows a total TP, FP and FN information, as well as precision, recall
      and f1-score for every type as well as for the whole file.
    </p>
    <p>
      There is also an experimental feature to extend the classpath during testing, which allows to 
      evaluate scripts that call analysis engines in the same workspace.
      Therefore, you have to toggle the button in the toolbar of the view. 
    </p>
    <p>
      Next, you have to add test files to your project. A test file is a previously annotated xmiCAS
      file that can be used as a golden standard for the test. You can use any xmiCAS file. The
      UIMA Ruta example project already contains such test files. These files are listed
      in the Annotation Test view. Try do delete these files by selecting them and clicking on
      <code class="literal">Del</code>. Add these files again by simply dragging them from the Script Explorer into the test file
      list. A different way to add test-files is to use the
      <span class="quote">&#8220;<span class="quote">Load all test files from selected folder</span>&#8221;</span>
      button (green plus). It can be used to add all xmiCAS files from a selected folder.
    </p>
    <p>
      Sometimes it is necessary to create some annotations manually: To create annotations manually,
      use the
      <span class="quote">&#8220;<span class="quote">Cas Editor</span>&#8221;</span>
      perspective delivered with the UIMA workbench.
    </p>
    <p>
      The testing environment supports different evaluators that allow a
      sophisticated analysis of the behavior of a UIMA Ruta script. The evaluator can be chosen in
      the testing environment's preference page. The preference page can be opened either through
      the menu or by clicking on the
      <span class="quote">&#8220;<span class="quote">Select evaluator</span>&#8221;</span>
      button (blue gear wheels) in the testing view's toolbar. Clicking the button will open a
      filtered version of the UIMA Ruta preference page. The default evaluator is the "Exact CAS
      Evaluator", which compares the offsets of the annotations between the test file and the file
      annotated by the tested script. To get an overview of all available evaluators, see
      <a class="xref" href="#section.ugr.tools.ruta.workbench.testing.evaluators" title="3.8.2.&nbsp;Evaluators">Section&nbsp;3.8.2, &#8220;Evaluators&#8221;</a>
    </p>
    <p>
      This preference page (see <a class="xref" href="#figure.ugr.tools.ruta.workbench.testing.preference" title="Figure&nbsp;3.17.&nbsp;The testing preference page view">Figure&nbsp;3.17, &#8220;The testing preference page view   &#8221;</a>) 
      offers a few options that will modify the plug-ins general behavior. For example, the
      preloading of previously collected result data can be turned off. An important option in the
      preference page is the evaluator you can select. On default the "exact evaluator" is selected,
      which compares the offsets of the annotations, that are contained in the file produced by the
      selected script with the annotations in the test file. Other evaluators will compare
      annotations in a different way.
    </p>
    <p>
      </p><div class="figure"><a name="figure.ugr.tools.ruta.workbench.testing.preference"></a><div class="figure-contents">
        
        <div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="476"><tr><td align="center"><img src="images/tools/ruta/workbench/testing/preference_2_2_0.png" align="middle" width="476" alt="The testing preference page view."></td></tr></table></div>
      </div><p class="title"><b>Figure&nbsp;3.17.&nbsp;The testing preference page view   </b></p></div><p><br class="figure-break">
    </p>
    <p>
      During a test-run it might be convenient to disable testing for specific
      types like punctuation or tags. The
      <span class="quote">&#8220;<span class="quote">Select excluded types</span>&#8221;</span>
      button (white exclamation in a red disk) will open a dialog (see <a class="xref" href="#figure.ugr.tools.ruta.workbench.testing.excluded_types" title="Figure&nbsp;3.18.&nbsp;Excluded types window">Figure&nbsp;3.18, &#8220;Excluded types window   &#8221;</a>) 
      where all types can be selected that should not be considered in the test.
    </p>
    <p>
      </p><div class="figure"><a name="figure.ugr.tools.ruta.workbench.testing.excluded_types"></a><div class="figure-contents">
        
        <div class="mediaobject" align="center"><img src="images/tools/ruta/workbench/testing/excluded_types.png" align="middle" alt="Excluded types window."></div>
      </div><p class="title"><b>Figure&nbsp;3.18.&nbsp;Excluded types window   </b></p></div><p><br class="figure-break">
    </p>
    <p>
      A test-run can be started by clicking on the start button. Do this for the
      UIMA Ruta example project.
      <a class="xref" href="#figure.ugr.tools.ruta.workbench.testing.annotation_test_test_run" title="Figure&nbsp;3.19.&nbsp;The Annotation Test view.">Figure&nbsp;3.19, &#8220;The Annotation Test view.   &#8221;</a>
      shows the results.
    </p>
    <p>
      </p><div class="figure"><a name="figure.ugr.tools.ruta.workbench.testing.annotation_test_test_run"></a><div class="figure-contents">
        
        <div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="576"><tr><td align="center"><img src="images/tools/ruta/workbench/testing/annotation_test_test_run_2_2_0.png" align="middle" width="576" alt="The Annotation Test view."></td></tr></table></div>
      </div><p class="title"><b>Figure&nbsp;3.19.&nbsp;The Annotation Test view.   </b></p></div><p><br class="figure-break">
    </p>
    <p>The testing main view displays some information on how well the script
      did after every test run. It will display an overall number of true positive, false positive
      and false negatives annotations of all result files as well as an overall f1-score.
      Furthermore, a table will be displayed that contains the overall statistics of the selected
      test file as well as statistics for every single type in the test file. The information
      displayed are true positives, false positives, false negatives, precision, recall and
      f1-measure. </p>
    <p>
      The testing environment also supports the export of the overall data in form of a
      comma-separated table. Clicking the
      <span class="quote">&#8220;<span class="quote">export data</span>&#8221;</span>
      button will open a dialog window that contains this table. The text in this table can be
      copied and easily imported into other applications.
    </p>
    <p>
      When running a test, the evaluator will create a new result xmiCAS file and will
      add new true positive, false positive and false negative annotations. By clicking on a file in
      the test-file list, you can open the corresponding result xmiCAS file in the CAS
      Editor. While displaying the result xmiCAS file in the CAS Editor, the True Positive, False
      Positive and False Negative views allow easy navigation through the new tp, fp and fn
      annotations. The corresponding annotations are displayed in a hierarchic tree structure. This
      allows an easy tracing of the results within the testing document. Clicking on one of the
      annotations in those views will highlight the annotation in the CAS Editor. Opening
      <span class="quote">&#8220;<span class="quote">test1.result.xmi</span>&#8221;</span>
      in the UIMA Ruta example project changes the True Positive view as shown in
      <a class="xref" href="#figure.ugr.tools.ruta.workbench.testing.true_positive" title="Figure&nbsp;3.20.&nbsp;The True Positive view.">Figure&nbsp;3.20, &#8220;The True Positive view.   &#8221;</a>.
      Notice that the type system, which will be used by the CAS Editor to open the evaluated file, 
      can only be resolved for the tested script, if the test files are located in the associated
      folder structure that is the folder with the name of the script. If the files are located 
      in the temp folder, for example by adding the files to the list of test cases by drag and drop,
      other strategies to find the correct type system will be applied. For UIMA Ruta projects, 
      for example, this will be the type system of the last launched script in this project. 
    </p>
    <p>
      </p><div class="figure"><a name="figure.ugr.tools.ruta.workbench.testing.true_positive"></a><div class="figure-contents">
        
        <div class="mediaobject" align="center"><img src="images/tools/ruta/workbench/testing/true_positive.png" align="middle" alt="The True Positive view."></div>
      </div><p class="title"><b>Figure&nbsp;3.20.&nbsp;The True Positive view.   </b></p></div><p><br class="figure-break">
    </p>
  </div>
  <div class="section" title="3.8.2.&nbsp;Evaluators"><div class="titlepage"><div><div><h3 class="title" id="section.ugr.tools.ruta.workbench.testing.evaluators">3.8.2.&nbsp;Evaluators</h3></div></div></div>
    
    <p> When testing a CAS file, the system compared the offsets of the annotations of a
      previously annotated gold standard file with the offsets of the annotations of the result file
      the script produced. Responsible for comparing annotations in the two CAS files are
      evaluators. These evaluators have different methods and strategies implemented for comparing the
      annotations. Also, an extension point is provided that allows easy implementation
      of new evaluators. </p>
    <p> Exact Match Evaluator: The Exact Match Evaluator compares the offsets of the annotations
      in the result and the golden standard file. Any difference will be marked with either a false
      positive or false negative annotations. </p>
    <p> Partial Match Evaluator: The Partial Match Evaluator compares the offsets of the
      annotations in the result and golden standard file. It will allow differences in the beginning
      or the end of an annotation. For example, "corresponding" and "corresponding " will not be
      annotated as an error. </p>
    <p> Core Match Evaluator: The Core Match Evaluator accepts annotations that share a core
      expression. In this context, a core expression is at least four digits long and starts with a
      capitalized letter. For example, the two annotations "L404-123-421" and "L404-321-412" would be
      considered a true positive match, because "L404" is considered a core expression that is
      contained in both annotations. </p>
    <p> Word Accuracy Evaluator: Compares the labels of all words/numbers in an annotation,
      whereas the label equals the type of the annotation. This has the consequence, for example,
      that each word or number that is not part of the annotation is counted as a single false
      negative. For example in the sentence: "Christmas is on the 24.12 every year." The script
      labels "Christmas is on the 12" as a single sentence, while the test file labels the sentence
      correctly with a single sentence annotation. While, for example, the Exact CAS Evaluator is
      only assigning a single False Negative annotation, Word Accuracy Evaluator will mark every word
      or number as a single false negative. </p>
    <p> Template Only Evaluator: This Evaluator compares the offsets of the annotations and the
      features, that have been created by the script. For example, the text "Alan Mathison Turing" is
      marked with the author annotation and "author" contains 2 features: "FirstName" and
      "LastName". If the script now creates an author annotation with only one feature, the
      annotation will be marked as a false positive. </p>
    <p> Template on Word Level Evaluator: The Template On Word Evaluator compares the offsets of
      the annotations. In addition, it also compares the features and feature structures and the
      values stored in the features. For example, the annotation "author" might have features like
      "FirstName" and "LastName". The authors name is "Alan Mathison Turing" and the script correctly
      assigns the author annotation. The feature assigned by the script are "Firstname : Alan",
      "LastName : Mathison", while the correct feature values are "FirstName Alan" and "LastName
      Turing". In this case, the Template Only Evaluator will mark an annotation as a false positive,
      since the feature values differ. </p>
  </div>
</div>
  
  <div class="section" title="3.9.&nbsp;TextRuler"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="section.tools.ruta.workbench.textruler">3.9.&nbsp;TextRuler</h2></div></div></div>
  
  <p>
    Apache UIMA Ruta TextRuler is a framework for supervised rule induction included in the UIMA Ruta Workbench. 
    It provides several configurable algorithms, which are able to learn new rules based on given labeled data.
    The framework was created in order to support the user by suggesting new rules for the given task. 
    The user selects a suitable learning algorithm and adapts its configuration parameters. Furthermore, 
    the user engineers a set of annotation-based features, which enable the algorithms to form efficient, effective and comprehensive rules.
    The rule learning algorithms present their suggested rules in a new view, in which the user can either copy 
    the complete script or single rules to a new script file, where the rules can be further refined.
  </p>
  <p>
    This section gives a short introduction about the included features and learners, and how to use the framework to learn UIMA Ruta rules. First, the 
    available rule learning algorithms are introduced in <a class="xref" href="#section.tools.ruta.workbench.textruler.learner" title="3.9.1.&nbsp;Included rule learning algorithms">Section&nbsp;3.9.1, &#8220;Included rule learning algorithms&#8221;</a>. Then, 
    the user interface and the usage is explained in <a class="xref" href="#section.tools.ruta.workbench.textruler.ui" title="3.9.2.&nbsp;The TextRuler view">Section&nbsp;3.9.2, &#8220;The TextRuler view&#8221;</a> and 
    <a class="xref" href="#section.tools.ruta.workbench.textruler.example" title="4.4.&nbsp;Induce rules with the TextRuler framework">Section&nbsp;4.4, &#8220;Induce rules with the TextRuler framework&#8221;</a> illustrates the usage with an exemplary UIMA Ruta project.
  </p>
   <div class="section" title="3.9.1.&nbsp;Included rule learning algorithms"><div class="titlepage"><div><div><h3 class="title" id="section.tools.ruta.workbench.textruler.learner">3.9.1.&nbsp;Included rule learning algorithms</h3></div></div></div>
    
    <p>
      This section gives a short description of the rule learning algorithms,
      which are provided in the UIMA Ruta TextRuler framework.
      </p>
      <div class="section" title="3.9.1.1.&nbsp;LP2"><div class="titlepage"><div><div><h4 class="title" id="section.tools.ruta.workbench.textruler.lp2">3.9.1.1.&nbsp;LP2</h4></div></div></div>
      
      <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
      <p>
        This rule learner is an experimental implementation of the ideas and algorithms published in:
        F. Ciravegna. (LP)2, Rule Induction for Information Extraction Using Linguistic
        Constraints. Technical Report CS-03-07, Department of Computer Science, University of
        Sheffield, Sheffield, 2003.
      </p>
      </div>
      <p>This algorithms learns separate rules for
        the beginning and the end of a single slot, which are later combined 
        in order to identify the targeted annotation. The learning strategy is a bottom-up covering
        algorithm. It starts by creating a specific seed instance with a window of w tokens to the
        left and right of the target boundary and searches for the best generalization. Additional context rules are
        induced in order to identify missing boundaries. The current implementation does not support correction rules.
        The TextRuler framework provides two versions of this algorithm: LP2 (naive) is a straightforward implementation
        with limited expressiveness concerning the resulting Ruta rules. LP2 (optimized) is an improved 
        version with a dynamic programming approach and is providing better results in general.
        The following parameters are available. For a more detailed description of the parameters, 
        please refer to the implementation and the publication.
      </p>
      <p>
      </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
          <p>Context Window Size (to the left and right)</p>
        </li><li class="listitem">
          <p>Best Rules List Size</p>
        </li><li class="listitem">
          <p>Minimum Covered Positives per Rule</p>
        </li><li class="listitem">
          <p>Maximum Error Threshold</p>
        </li><li class="listitem">
          <p>Contextual Rules List Size</p>
        </li></ul></div><p>
      </p>
    </div>
    
    <div class="section" title="3.9.1.2.&nbsp;WHISK"><div class="titlepage"><div><div><h4 class="title" id="section.tools.ruta.workbench.textruler.whisk">3.9.1.2.&nbsp;WHISK</h4></div></div></div>
      
      <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
      <p>
        This rule learner is an experimental implementation of the ideas and algorithms published in:
        Stephen Soderland, Claire Cardie, and Raymond Mooney. Learning Information
        Extraction Rules for Semi-Structured and Free Text. In Machine Learning, volume 34,
        pages 233-272, 1999.
      </p>
      </div>
      <p>WHISK is a multi-slot method that operates on all three kinds of documents and learns
        single- or multi-slot rules looking similar to regular expressions. However, the current implementation only support single slot rules.
        The top-down covering algorithm begins with the most general rule and specializes it by adding single rule terms
        until the rule does not make errors anymore on the training set. The TextRuler framework provides two versions of this algorithm:
        WHISK (token) is a naive token-based implementation. WHISK (generic) is an optimized and improved implementation, 
        which is able to refer to arbitrary annotations and also supports primitive features. The following parameters are available. For a more detailed description of the parameters, 
        please refer to the implementation and the publication.
        </p>
      <p>
      </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
          <p>Parameters Window Size</p>
        </li><li class="listitem">
          <p>Maximum Error Threshold</p>
        </li><li class="listitem">
          <p>PosTag Root Type</p>
        </li><li class="listitem">
          <p>Considered Features (comma-separated) - only WHISK (generic)</p>
        </li></ul></div><p>
      </p>
    </div>  
    <div class="section" title="3.9.1.3.&nbsp;TraBaL"><div class="titlepage"><div><div><h4 class="title" id="section.tools.ruta.workbench.textruler.trabal">3.9.1.3.&nbsp;TraBaL</h4></div></div></div>
      
      <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
      <p>
        This rule learner is an implementation of the ideas and algorithms published in:
        Benjamin Eckstein, Peter Kluegl, and Frank Puppe. Towards Learning Error-Driven 
        Transformations for Information Extraction. Workshop Notes of the LWA 2011 - 
        Learning, Knowledge, Adaptation, 2011.
      </p>
      </div>
      <p>
        The TraBal rule learner induces rules that try to correct annotations error and relies on two set of documents. A set of 
        documents with gold standard annotation and an additional set of annotated documents with the same text that possibly contain erroneous
        annotations, for which correction rules should be learnt. First, the algorithm compares the two sets of documents and 
        identifies the present errors. Then, rules for each error are induced and extended. This process can be iterated in order 
        to incrementally remove all errors. The following parameters are available. For a more detailed description of the parameters, 
        please refer to the implementation and the publication.
      </p>
      <p>
      </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
          <p>Number of times, the algorithm iterates.</p>
        </li><li class="listitem">
          <p>Number of basic rules to be created for one example.</p>
        </li><li class="listitem">
          <p>Number of optimized rules to be created for one example.</p>
        </li><li class="listitem">
          <p>Maximum number of iterations, when optimizing rules.</p>
        </li><li class="listitem">
          <p>Maximum allowed error rate.</p>
        </li><li class="listitem">
          <p>Correct features in rules and conditions. (not yet available)</p>
        </li></ul></div><p>
      </p>
    </div>
        <div class="section" title="3.9.1.4.&nbsp;KEP"><div class="titlepage"><div><div><h4 class="title" id="section.tools.ruta.workbench.textruler.kep">3.9.1.4.&nbsp;KEP</h4></div></div></div>
      
      
      <p>
        The name of the rule learner KEP (knowledge engineering patterns) is derived from the idea that humans use different engineering patterns 
        to write annotation rules. This algorithms implements simple rule induction methods for some patterns, such as boundary detection 
        or annotation-based restriction of the window. The results are then combined in order to take advantage of the combination of 
        the different kinds of induced rules. Since the single rules are constructed according to how humans engineer the annotations rules, 
        the resulting rule set should resemble more a handcrafted rule set. Furthermore, by exploiting the synergy of the patterns, solutions for 
        some annotation are much simpler. The following parameters are available. For a more detailed description of the parameters, 
        please refer to the implementation.
      </p>
      <p>
      </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
          <p>Maximum number of <span class="quote">&#8220;<span class="quote">Expand Rules</span>&#8221;</span></p>
        </li><li class="listitem">
          <p>Maximum number of <span class="quote">&#8220;<span class="quote">Infiller Rules</span>&#8221;</span></p>
        </li></ul></div><p>
      </p>
    </div>
  </div>  
   <div class="section" title="3.9.2.&nbsp;The TextRuler view"><div class="titlepage"><div><div><h3 class="title" id="section.tools.ruta.workbench.textruler.ui">3.9.2.&nbsp;The TextRuler view</h3></div></div></div>
   
      <p> 
        The TextRuler view is normally located in the lower center of the UIMA Ruta perspective and is the main
        user interface to configure and start the rule learning algorithms. The view consists of four parts (cf. <a class="xref" href="#figure.tools.ruta.workbench.textruler.main" title="Figure&nbsp;3.21.&nbsp;The UIMA Ruta TextRuler framework">Figure&nbsp;3.21, &#8220;The UIMA Ruta TextRuler framework
      &#8221;</a>): 
        The toolbar contains buttons for starting (green button) and stopping (red button) the learning process, 
        and one button that opening the preference page (blue gears) for configuring the rule induction algorithms cf. <a class="xref" href="#figure.tools.ruta.workbench.textruler.pref" title="Figure&nbsp;3.22.&nbsp;The UIMA Ruta TextRuler Preferences">Figure&nbsp;3.22, &#8220;The UIMA Ruta TextRuler Preferences
      &#8221;</a>.
        The upper part of the view contains text fields for defining the set of utilized documents. <span class="quote">&#8220;<span class="quote">Training Data</span>&#8221;</span>
        points to the absolute location of the folder containing the gold standard documents. <span class="quote">&#8220;<span class="quote">Additional Data</span>&#8221;</span> points
        to the absolute location of documents that can be additionally used by the algorithms. These documents are currently only needed
        by the TraBal algorithm, which tries to learn correction rules for the error in those documents. <span class="quote">&#8220;<span class="quote">Test Data</span>&#8221;</span> is not yet available.
        Finally, <span class="quote">&#8220;<span class="quote">Preprocess Script</span>&#8221;</span> points to the absolute location of a UIMA Ruta script, which contains all necessary types and can be applied
        on the documents before the algorithms start in order to add additional annotations as learning features. The preprocessing can be skipped.
        All text fields support drag and drop: the user can drag a file in the script explorer and drop it in the respective text field.
        In the center of the view, the target types, for which rule should be induced, can be specified in the <span class="quote">&#8220;<span class="quote">Information Types</span>&#8221;</span> list.
        The list <span class="quote">&#8220;<span class="quote">Featured Feature Types</span>&#8221;</span> specify the filtering settings, but it is discourage to change these settings. The user is able to drop
        a simple text file, which contains a type with complete namespace in each line, to the <span class="quote">&#8220;<span class="quote">Information Types</span>&#8221;</span> list in order to add all those types.
        The lower part of the view contains the list of available algorithms. All checked algorithms will be started, if the start button in the toolbar of the view is pressed.
        When the algorithms are started, they display their current action after their name, and a result view with the currently induced rules is displayed 
        in the right part of the perspective.
      </p>
      <div class="figure"><a name="figure.tools.ruta.workbench.textruler.main"></a><div class="figure-contents">
      
      <div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="776"><tr><td align="center"><img src="images/tools/ruta/workbench/textruler/textruler.png" align="middle" width="776" alt="UIMA Ruta TextRuler framework"></td></tr></table></div>
    </div><p class="title"><b>Figure&nbsp;3.21.&nbsp;The UIMA Ruta TextRuler framework
      </b></p></div><br class="figure-break">
    <div class="figure"><a name="figure.tools.ruta.workbench.textruler.pref"></a><div class="figure-contents">
      
      <div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="576"><tr><td align="center"><img src="images/tools/ruta/workbench/textruler/textruler_pref.png" align="middle" width="576" alt="UIMA Ruta TextRuler Preferences"></td></tr></table></div>
    </div><p class="title"><b>Figure&nbsp;3.22.&nbsp;The UIMA Ruta TextRuler Preferences
      </b></p></div><br class="figure-break">
   </div>
</div>

  <div class="section" title="3.10.&nbsp;Check Annotations view"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="section.tools.ruta.workbench.check">3.10.&nbsp;Check Annotations view</h2></div></div></div>
  
  <p>
    The Check Annotations view provides functionality to quickly validate a set of annotations in different documents. 
    The user can specify two folders with xmiCAS files: One folder contains the documents with annotations that should be validated. 
    The other folder is used to store the validated annotations. The view enables a rapid navigation between the documents and their annotations 
    of the selected types can easily be accepted or rejected.
    <a class="xref" href="#figure.tools.ruta.workbench.check" title="Figure&nbsp;3.23.&nbsp;Check Annotations view (right part)">Figure&nbsp;3.23, &#8220;Check Annotations view (right part)
      &#8221;</a> provides an screenshot of the view. Its parts are described in the following.
  </p>
  <div class="figure"><a name="figure.tools.ruta.workbench.check"></a><div class="figure-contents">
      
      <div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="776"><tr><td align="center"><img src="images/tools/ruta/workbench/check/check.png" align="middle" width="776" alt="Check Annotations view"></td></tr></table></div>
    </div><p class="title"><b>Figure&nbsp;3.23.&nbsp;Check Annotations view (right part)
      </b></p></div><br class="figure-break">
  <p>
    The view provides three text fields: the absolute location of the folder with the source documents, which contain the annotations to be validated, 
    the absolute location of the gold folder, where the accepted annotations will be stored, and the absolute location of the type system that contains 
    all necessary types. The toolbar of the view provides seven buttons: the first one updates the set of documents and 
    their annotations in the main part of the view. This is necessary, e.g., if the selected types change or if the annotations in the documents change.
    The second button opens a dialog for choosing the types that need to be checked. Only annotations of those types will be displayed and can be accepted or rejected.
    If features need to be checked together with the annotations of a type, these features have to be selected in this dialog too. Features are shown as sub-nodes of the
    annotation nodes. By default, only annotations that have been checked are transferred from the original document to the according gold document. To also transfer 
    annotations of some type unchecked, these types have to be chosen in another dialog, which is opened with the third button.
    The fourth and fifth button accept/reject the currently selected annotation. Only accepted annotations will be stored in the gold folder. An annotation can also 
    be accepted with the key binding <span class="quote">&#8220;<span class="quote">ctrl+4</span>&#8221;</span> and rejected with the key binding <span class="quote">&#8220;<span class="quote">ctrl+5</span>&#8221;</span>. If an annotation is processed, 
    then the next annotation is automatically selected and a new CAS Editor is opened if necessary. 
    The sixth button adds the currently accepted
    annotations, as well as the annotations of a type selected in the unchecked dialog, to the corresponding file in the gold folder and additionally extends an file
    <span class="quote">&#8220;<span class="quote">data.xml</span>&#8221;</span>, which remembers what types have already been checked in each documents.
    Annotations of these types will not show up again in the main part of the view. With the last button, the user can select the annotation mode of the CAS editor.
    The choice is restricted to the currently selected types. If an annotation is missing in the source documents, then the user can manually add this annotation
    in the CAS Editor. The new annotation will be added as accepted to the list of annotations in the main part of the view.
    By right-clicking on an annotation node in the view's tree viewer, a dialog opens to change the type of an annotation. Right-clicking on a feature node opens another
    dialog to change the feature's value.
  </p>
    
</div>
  
  <div class="section" title="3.11.&nbsp;Creation of Tree Word Lists"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="section.ugr.tools.ruta.workbench.create_dictionaries">3.11.&nbsp;Creation of Tree Word Lists</h2></div></div></div>
  
  <p>
    Tree word lists are external resources, which can be used
    to annotate all occurrences of list items in a document
    with a given annotation type, very fast. For more details
    on their use, see <a class="xref" href="#ugr.tools.ruta.language.external_resources" title="2.14.&nbsp;External resources">Section&nbsp;2.14, &#8220;External resources&#8221;</a>. 
    Since simple tree and multi tree word lists have to be compiled
    the UIMA Ruta Workbench provides an easy way to compile
    them from ordinary text files. These text files have to
    containing one item per line, for example, like in the
    following list of first names: 
    </p><pre class="programlisting">Frank
Peter
Jochen
Martin
</pre><p>
  </p>
  <p>
    To compile a simple tree word list from a text file,
    right-click on the text file in UIMA Ruta script
    explorer. The resulting menu is shown in
    <a class="xref" href="#figure.ugr.tools.ruta.workbench.create_dictionaries_1" title="Figure&nbsp;3.24.&nbsp;Create a simple tree word list">Figure&nbsp;3.24, &#8220;Create a simple tree word list
      &#8221;</a>.

    </p><div class="figure"><a name="figure.ugr.tools.ruta.workbench.create_dictionaries_1"></a><div class="figure-contents">
      
      <div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="250"><tr><td align="center"><img src="images/tools/ruta/workbench/create_tree_lists/create_tree_lists.png" align="middle" width="250" alt="Create a simple tree word list."></td></tr></table></div>
    </div><p class="title"><b>Figure&nbsp;3.24.&nbsp;Create a simple tree word list
      </b></p></div><p><br class="figure-break">
  </p>
  <p>
    When hovering over UIMA Ruta item you can choose
    <span class="quote">&#8220;<span class="quote">Convert to TWL</span>&#8221;</span>.
    Click on it and a tree word list with the same name as the original
    file is generated in the same folder.
  </p>
  <p>
    You can also generate several tree word lists at once. To do so,
    just select
    multiple files and then right-click and do the same like for a single
    list. You will get one tree word list for every selected file.
  </p>
  <p>
    To generate a multi tree work list, select all files, which should be
    generated
    into the multi tree word list. Again right-click and select
    <span class="quote">&#8220;<span class="quote">Convert to Multi TWL</span>&#8221;</span>
    under item UIMA Ruta. A multi tree word list
    named
    <span class="quote">&#8220;<span class="quote">generated.mtwl</span>&#8221;</span>
    will be created.
  </p>

</div>
  
  <div class="section" title="3.12.&nbsp;Apply a UIMA Ruta script to a folder"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.tools.ruta.workbench.apply">3.12.&nbsp;Apply a UIMA Ruta script to a folder</h2></div></div></div>
    
    <p>
      The UIMA Ruta Workbench makes it possible to apply a UIMA Ruta script to any folder of the workspace. 
      Select a folder in the script explorer, right-click to open the context menu and select the menu entry UIMA Ruta.
      There are three options to apply a UIMA Ruta script to the files of the selected folder, 
      cf. <a class="xref" href="#figure.ugr.tools.ruta.workbench.apply" title="Figure&nbsp;3.25.&nbsp;Remove Ruta basics">Figure&nbsp;3.25, &#8220;Remove Ruta basics
      &#8221;</a>.
    </p>
    <p>
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
        <p>
          <span class="bold"><strong>Quick Ruta</strong></span> applies the UIMA Ruta script that is currently opened and focused
          in the UIMA Ruta editor to all suitable files in the selected folder. Files of the type <span class="quote">&#8220;<span class="quote">xmi</span>&#8221;</span> will be adapted 
          and a new xmi-file will be created for other files like txt-files.
        </p>
        </li><li class="listitem">
        <p>
          <span class="bold"><strong>Quick Ruta (remove basics)</strong></span> is very similar to the previous menu entry,
           but removes the annotations of the type <span class="quote">&#8220;<span class="quote">RutaBasic</span>&#8221;</span> after processing a CAS.
        </p>
        </li><li class="listitem">
        <p>
          <span class="bold"><strong>Quick Ruta (no xmi)</strong></span> applies the UIMA Ruta script, but does not change
           nor create an xmi-file. This menu entry can, for example, be used in combination with an imported XMIWriter Analysis Engine, which 
           stores the result of the script in a different folder depending on the execution of the rules.
        </p>
        </li></ol></div><p>
    </p>
    <p>
    </p><div class="figure"><a name="figure.ugr.tools.ruta.workbench.apply"></a><div class="figure-contents">
      
      <div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="250"><tr><td align="center"><img src="images/tools/ruta/workbench/apply/apply.png" align="middle" width="250" alt="Apply a UIMA Ruta script directly on a folder."></td></tr></table></div>
    </div><p class="title"><b>Figure&nbsp;3.25.&nbsp;Remove Ruta basics
      </b></p></div><p><br class="figure-break">
    </p>
    
  </div>
 
</div>
  
  <div class="chapter" title="Chapter&nbsp;4.&nbsp;Apache UIMA Ruta HowTos" id="ugr.tools.ruta.howtos"><div class="titlepage"><div><div><h2 class="title">Chapter&nbsp;4.&nbsp;Apache UIMA Ruta HowTos</h2></div></div></div>
	
	<p>This chapter contains a selection of some use cases and HowTos
		for UIMA Ruta.
	</p>
	<div class="section" title="4.1.&nbsp;Apply UIMA Ruta Analysis Engine in plain Java"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.tools.ruta.ae.basic.apply">4.1.&nbsp;Apply UIMA Ruta Analysis Engine in plain Java</h2></div></div></div>
		
		<p>
			Let us assume that the reader wrote the UIMA Ruta rules using
			the UIMA
			Ruta Workbench, which already creates correctly configured
			descriptors.
			In this case, the following java code can be used to
			apply the UIMA
			Ruta script.
		</p>
		<pre class="programlisting">File specFile = new File("pathToMyWorkspace/MyProject/descriptor/"+
    "my/package/MyScriptEngine.xml");
XMLInputSource in = new XMLInputSource(specFile);
ResourceSpecifier specifier = UIMAFramework.getXMLParser().
    parseResourceSpecifier(in);
// for import by name... set the datapath in the ResourceManager
AnalysisEngine ae = UIMAFramework.produceAnalysisEngine(specifier);
CAS cas = ae.newCAS();
cas.setDocumentText("This is my document.");
ae.process(cas);</pre>
		<div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
			<p>
				The UIMA Ruta Analysis Engine utilizes type priorities. If the
				CAS
				object is
				not created using the UIMA Ruta Analysis Engine
				descriptor by other
				means, then please
				provide the necessary type
				priorities for a valid execution of the UIMA
				Ruta rules.
			</p>
		</div>
		<p>
			If the UIMA Ruta script was written, for example, with a common text
			editor and no configured descriptors are yet available,
			then the
			following java code can be used, which, however, is only
			applicable
			for executing single script files that do not import
			additional
			components or scripts. In this case the other parameters,
			e.g.,
			<span class="quote">&#8220;<span class="quote">additionalScripts</span>&#8221;</span>
			, need to be configured correctly.
		</p>
		<pre class="programlisting">URL aedesc = RutaEngine.class.getResource("BasicEngine.xml");
XMLInputSource inae = new XMLInputSource(aedesc);
ResourceSpecifier specifier = UIMAFramework.getXMLParser().
    parseResourceSpecifier(inae);
ResourceManager resMgr = UIMAFramework.newDefaultResourceManager();
AnalysisEngineDescription aed = (AnalysisEngineDescription) specifier;
TypeSystemDescription basicTypeSystem = aed.getAnalysisEngineMetaData().
    getTypeSystem();

Collection&lt;TypeSystemDescription&gt; tsds = 
    new ArrayList&lt;TypeSystemDescription&gt;();
tsds.add(basicTypeSystem);
// add some other type system descriptors 
// that are needed by your script file   
TypeSystemDescription mergeTypeSystems = CasCreationUtils.
    mergeTypeSystems(tsds);
aed.getAnalysisEngineMetaData().setTypeSystem(mergeTypeSystems);
aed.resolveImports(resMgr);
        
AnalysisEngine ae = UIMAFramework.produceAnalysisEngine(aed, 
    resMgr, null);
File scriptFile = new File("path/to/file/MyScript.ruta");
ae.setConfigParameterValue(RutaEngine.PARAM_SCRIPT_PATHS, 
    new String[] { scriptFile.getParentFile().getAbsolutePath() });
String name = scriptFile.getName().substring(0, 
    scriptFile.getName().length() - 5);
ae.setConfigParameterValue(RutaEngine.PARAM_MAIN_SCRIPT, name);
ae.reconfigure();
CAS cas = ae.newCAS();
cas.setDocumentText("This is my document.");
ae.process(cas);</pre>
		<p>
			There is also a convenience implementation for applying simple
			scripts, which do not introduce new types. The following java code
			applies a simple rule
			<span class="quote">&#8220;<span class="quote">T1 SW{-&gt; MARK(T2)};</span>&#8221;</span>
			on the given CAS. Note that the types need to be already defined in
			the type system of the CAS.
		</p>
		<pre class="programlisting">Ruta.apply(cas, "T1 SW{-&gt; MARK(T2)};");</pre>
	</div>
	<div class="section" title="4.2.&nbsp;Integrating UIMA Ruta in an existing UIMA Annotator"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.tools.ruta.integration">4.2.&nbsp;Integrating UIMA Ruta in an existing UIMA Annotator</h2></div></div></div>
		
		<p>This section provides a walk-through tutorial on integrating
			Ruta in an existing UIMA annotator. In our artificial example
			we will
			use Ruta rules to post-process the output of a
			Part-of-Speech tagger.
			The POS tagger is a UIMA annotator that iterates over
			sentences
			and
			tokens and updates the posTag field of each Token with a part of
			speech. For example, given this text...
		</p>
		<pre class="programlisting">The quick brown fox receives many bets.
The fox places many bets.
The fox gets up early.
The rabbit made up this story.</pre>
		<p>...it assigns the posTag JJ (adjective) to the token
			"brown" , the posTag NN (common noun) to the
			token
			"fox" and the tag VBZ (verb, 3rd person
			singular present) to
			the token "receives" in the first sentence.
		</p>
		<p>We have noticed that the tagger sometimens fails to disambiguate
			NNS (common noun plural) and
			VBZ tags, as in the second sentence. The
			word "up" also seems
			to confuse the tagger,
			which always
			assigns it an RB (adverb) tag, even when it is a particle
			(RP)
			following a verb, as in
			the third and fourth sentences:
		</p>
		<pre class="programlisting">The|DT quick|JJ brown|JJ fox|NN receives|VBZ many|JJ bets|NNS .|.
The|DT fox|NN places|NNS many|JJ bets|NNS .|.
The|DT fox|NN gets|VBZ up|RB early|RB .|.
The|DT rabbit|NN made|VBD up|RB this|DT story|NN .|.</pre>
		<p>Let's imagine that after applying every possible approach
			available in the POS tagging literature, our tagger still generates
			these and some other errors. We decide to write a few Ruta
			rules to
			post-process the output of the tagger.
		</p>
		<div class="section" title="4.2.1.&nbsp;Adding Ruta to our Annotator"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.ae.integration.mvn">4.2.1.&nbsp;Adding Ruta to our Annotator</h3></div></div></div>
			
			<p>The POS tagger is being developed as a Maven-based project.
				Since Ruta maven artifacts are available on Maven Central, we
				add the
				following dependency to the project's pom.xml. The
				functionalities described in this section
				require a version of Ruta
				equal to or greater than 2.1.0.
			</p>
			<pre class="programlisting">&lt;dependency&gt;
  &lt;groupId&gt;org.apache.uima&lt;/groupId&gt;
  &lt;artifactId&gt;ruta-core&lt;/artifactId&gt;
  &lt;version&gt;[2.0.2,)&lt;/version&gt;
&lt;/dependency&gt;</pre>
			<p>We also take care that the Ruta basic typesystem is loaded when
				our annotator is initialized. The Ruta typesystem descriptors are
				available from
				ruta-core/src/main/resources/org/apache/uima/ruta/engine/
			</p>
		</div>
		<div class="section" title="4.2.2.&nbsp;Developing Ruta rules and applying them from inside Java code"><div class="titlepage"><div><div><h3 class="title" id="ugr.tools.ruta.ae.integration.loading">4.2.2.&nbsp;Developing Ruta rules and applying them from inside Java code
			</h3></div></div></div>
			
			<p>We are now ready to write some rules. The ones we develop for
				fixing the two errors look like this:
			</p>
			<pre class="programlisting">Token.posTag =="NN" Token.posTag=="NNS"{-&gt; Token.posTag="VBZ"}
    Token.posTag=="JJ";
Token{REGEXP(Token.posTag, "VB(.?)")} 
    Token.posTag=="RB"{REGEXP("up")-&gt; Token.posTag="RP"};  </pre>
			<p>That
				is, we change a Token's NNS tag to VBZ, if it is surrounded by a
				Token tagged as NN and a Token tagged as JJ. We also change an RB
				tag for an "up" token to RP, if "up" is preceded
				by any verbal tag (VB, VBZ, etc.) matched with the help of the
				<a class="link" href="#ugr.tools.ruta.language.conditions.regexp" title="2.7.22.&nbsp;REGEXP">REGEXP</a>
				condition.
			</p>
			<p>We test our rules in the Ruta Workbench and see that they
				indeed fix most of our problems. We save those and some more rules
				in a text file
				src/main/resources/ruta.txt.
			</p>
			<p>We declare the file with our rules as an external resource and
				we load it during initialization.
				Here's a way to do it using
				uimaFIT:
			</p>
			<pre class="programlisting">/**
 * Ruta rules for post-processing the tagger's output
 */
public static final String RUTA_RULES_PARA = "RutaRules";
ExternalResource(key = RUTA_RULES_PARA, mandatory=false)
...
File rutaRulesF = new File((String) 
    aContext.getConfigParameterValue(RUTA_RULES_PARA));
</pre>
			<p>After our CAS has been populated with posTag annotations from
				the main algorithm, we post-process the CAS using
				Ruta.apply():
			</p>
			<pre class="programlisting">String rutaRules = org.apache.commons.io.FileUtils.readFileToString(
    rutaRulesF, "UTF-8");
Ruta.apply(cas,  rutaRules);    
</pre>
			<p>We are now happy to see that the final output of our annotator
				now
				looks much better:
			</p>
			<pre class="programlisting">The|DT quick|JJ brown|JJ fox|NN receives|VBZ many|JJ bets|NNS .|.
The|DT fox|NN places|VBZ many|JJ bets|NNS .|.
The|DT fox|NN gets|VBZ up|RP early|RB .|.
The|DT rabbit|NN made|VBD up|RP this|DT story|NN .|.</pre>
		</div>
	</div>


	<div class="section" title="4.3.&nbsp;UIMA Ruta Maven Plugin"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.tools.ruta.maven">4.3.&nbsp;UIMA Ruta Maven Plugin</h2></div></div></div>
		
		<p>UIMA Ruta provides a maven plugin for building analysis engine
			and type system descriptors for rule scripts.
			Additionally, this maven plugin is able able to compile word list (gazetteers) to
			the more efficient structures, tree word list and multi tree word
			list. The usage and configuration is shortly summarized in the
			following. An exemplary maven project for UIMA Ruta is given here:
			<code class="code">https://svn.apache.org/repos/asf/uima/ruta/trunk/example-projects/ruta-maven-example</code>
		</p>
		<div class="section" title="4.3.1.&nbsp;generate goal"><div class="titlepage"><div><div><h3 class="title" id="d5e3309">4.3.1.&nbsp;generate goal</h3></div></div></div>
		
		<p>
		The generate goal can be utilized to create xml descriptors for the UIMA Ruta script files. 
		Its usage and configuration is summarized in the following example:
		</p>
		<pre class="programlisting">&lt;plugin&gt;
&lt;groupId&gt;org.apache.uima&lt;/groupId&gt;
&lt;artifactId&gt;ruta-maven-plugin&lt;/artifactId&gt;
&lt;version&gt;2.3.0&lt;/version&gt;
&lt;configuration&gt;

 &lt;!-- This is a exemplary configuration, which explicitly specifies the 
  default configuration values if not mentioned otherwise. --&gt;

 &lt;!--
 The following parameter is optional and should only be specified
 if the structure (e.g., classpath/resources) of the project requires it.
 
 A FileSet specifying the UIMA Ruta script files that should be built. 
 
 If this parameter is not specified, then all UIMA Ruta script files 
 in the output directory (e.g., target/classes) of the project will be built. 
 
 default value: none
 &lt;scriptFiles&gt;
   &lt;directory&gt;${basedir}/some/folder&lt;/directory&gt;
   &lt;includes&gt;
     &lt;include&gt;*.ruta&lt;/include&gt;
   &lt;/includes&gt;
 &lt;/scriptFiles&gt;
 --&gt;

 &lt;!-- The directory where the generated type system descriptors will 
  be written stored. --&gt;
 &lt;!-- default value: ${project.build.directory}/generated-sources/
   ruta/descriptor --&gt;
 &lt;typeSystemOutputDirectory&gt;${project.build.directory}/generated-sources/
   ruta/descriptor&lt;/typeSystemOutputDirectory&gt;

 &lt;!-- The directory where the generated analysis engine descriptors will 
  be stored. --&gt;
 &lt;!-- default value: ${project.build.directory}/generated-sources/ruta/
   descriptor --&gt;
 &lt;analysisEngineOutputDirectory&gt;${project.build.directory}/
  generated-sources/ruta/descriptor&lt;/analysisEngineOutputDirectory&gt;

 &lt;!-- The template descriptor for the generated type system. By default the 
   descriptor of the maven dependency is loaded. --&gt;
 &lt;!-- default value: none --&gt;
 &lt;!-- not used in this example &lt;typeSystemTemplate&gt;...
   &lt;/typeSystemTemplate&gt; --&gt;

 &lt;!-- The template descriptor for the generated analysis engine. 
   By default the descriptor of the maven dependency is loaded. --&gt;
 &lt;!-- default value: none --&gt;
 &lt;!-- not used in this example &lt;analysisEngineTemplate&gt;...
   &lt;/analysisEngineTemplate&gt; --&gt;

 &lt;!-- Script paths of the generated analysis engine descriptor. --&gt;
 &lt;!-- default value: none --&gt;
 &lt;scriptPaths&gt;
  &lt;scriptPath&gt;${basedir}/src/main/ruta/&lt;/scriptPath&gt;
 &lt;/scriptPaths&gt;

 &lt;!-- Descriptor paths of the generated analysis engine descriptor. --&gt;
 &lt;!-- default value: none --&gt;
 &lt;descriptorPaths&gt;
  &lt;descriptorPath&gt;${project.build.directory}/generated-sources/ruta/
   descriptor&lt;/descriptorPath&gt;
 &lt;/descriptorPaths&gt;

 &lt;!-- Resource paths of the generated analysis engine descriptor. --&gt;
 &lt;!-- default value: none --&gt;
 &lt;resourcePaths&gt;
  &lt;resourcePath&gt;${basedir}/src/main/resources/&lt;/resourcePath&gt;
  &lt;resourcePath&gt;${project.build.directory}/generated-sources/ruta/
   resources/&lt;/resourcePath&gt;
 &lt;/resourcePaths&gt;

 &lt;!-- Suffix used for the generated type system descriptors. --&gt;
 &lt;!-- default value: Engine --&gt;
 &lt;analysisEngineSuffix&gt;Engine&lt;/analysisEngineSuffix&gt;

 &lt;!-- Suffix used for the generated analysis engine descriptors. --&gt;
 &lt;!-- default value: TypeSystem --&gt;
 &lt;typeSystemSuffix&gt;TypeSystem&lt;/typeSystemSuffix&gt;

 &lt;!-- Source file encoding. --&gt;
 &lt;!-- default value: ${project.build.sourceEncoding} --&gt;
 &lt;encoding&gt;UTF-8&lt;/encoding&gt;

 &lt;!-- Type of type system imports. false = import by location. --&gt;
 &lt;!-- default value: false --&gt;
 &lt;importByName&gt;false&lt;/importByName&gt;

 &lt;!-- Option to resolve imports while building. --&gt;
 &lt;!-- default value: false --&gt;
 &lt;resolveImports&gt;false&lt;/resolveImports&gt;

 &lt;!-- Amount of retries for building dependent descriptors. Default value 
  -1 leads to three retires for each script. --&gt;
  &lt;!-- default value: -1 --&gt;
 &lt;maxBuildRetries&gt;-1&lt;/maxBuildRetries&gt;

 &lt;!-- List of packages with language extensions --&gt;
 &lt;!-- default value: none --&gt;
 &lt;extensionPackages&gt;
  &lt;extensionPackage&gt;org.apache.uima.ruta&lt;/extensionPackage&gt;
 &lt;/extensionPackages&gt;

 &lt;!-- Add UIMA Ruta nature to .project --&gt;
 &lt;!-- default value: false --&gt;
 &lt;addRutaNature&gt;true&lt;/addRutaNature&gt;


 &lt;!-- Buildpath of the UIMA Ruta Workbench (IDE) for this project --&gt;
 &lt;!-- default value: none --&gt;
 &lt;buildPaths&gt;
  &lt;buildPath&gt;script:src/main/ruta/&lt;/buildPath&gt;
  &lt;buildPath&gt;descriptor:target/generated-sources/ruta/descriptor/
  &lt;/buildPath&gt;
  &lt;buildPath&gt;resources:src/main/resources/&lt;/buildPath&gt;
 &lt;/buildPaths&gt;

&lt;/configuration&gt;
&lt;executions&gt;
 &lt;execution&gt;
  &lt;id&gt;default&lt;/id&gt;
  &lt;phase&gt;process-classes&lt;/phase&gt;
  &lt;goals&gt;
   &lt;goal&gt;generate&lt;/goal&gt;
  &lt;/goals&gt;
 &lt;/execution&gt;
&lt;/executions&gt;
&lt;/plugin&gt;
		</pre>
    <p>The configuration parameters for this goal either define the build behavior, 
    e.g., where the generated descriptor should be placed or which suffix the files should get,
    or the configuration of the generated analysis engine descriptor, e.g., 
    the values of the configuration parameter scriptPaths.
    However, there are also other parameters: addRutaNature and buildPaths. 
    Both can be utilzed to configure the current Eclipse project (due to the missing m2e connector).
    This is required if the functionality of the UIMA Ruta Workbench, e.g., syntax checking or auto-completeion,
     should be available in the maven project. If the parameter addRutaNature is set to true, then
     the UIMA Ruta Workbench will recognize the project as a script project. Only then, 
     the buildpath of the UIMA Ruta project can be configured using the buildPaths parameter, which specifies 
     the three important source folders of the UIMA Ruta project. In normal UIMA Ruta Workbnech projects, 
     these are script, descriptor and resources.
    </p>
		</div>
		
		<div class="section" title="4.3.2.&nbsp;twl goal"><div class="titlepage"><div><div><h3 class="title" id="d5e3314">4.3.2.&nbsp;twl goal</h3></div></div></div>
		
    <p>
    The twl goal can be utilized to create .twl files from .txt files.
    Its usage and configuration is summarized in the following example:
    </p>
    <pre class="programlisting">&lt;plugin&gt;
&lt;groupId&gt;org.apache.uima&lt;/groupId&gt;
&lt;artifactId&gt;ruta-maven-plugin&lt;/artifactId&gt;
&lt;version&gt;2.3.0&lt;/version&gt;
&lt;configuration&gt;&lt;/configuration&gt;
&lt;executions&gt;
&lt;execution&gt;
 &lt;id&gt;default&lt;/id&gt;
 &lt;phase&gt;process-classes&lt;/phase&gt;
 &lt;goals&gt;
  &lt;goal&gt;twl&lt;/goal&gt;
 &lt;/goals&gt;
 &lt;configuration&gt;
  &lt;!-- This is a exemplary configuration, which explicitly specifies 
   the default configuration values if not mentioned otherwise. --&gt;

  &lt;!-- Compress resulting tree word list. --&gt;
  &lt;!-- default value: true --&gt;
  &lt;compress&gt;true&lt;/compress&gt;

  &lt;!-- The source files for the tree word list. --&gt;
  &lt;!-- default value: none --&gt;
  &lt;inputFiles&gt;
   &lt;directory&gt;${basedir}/src/main/resources&lt;/directory&gt;
   &lt;includes&gt;
    &lt;include&gt;*.txt&lt;/include&gt;
   &lt;/includes&gt;
  &lt;/inputFiles&gt;

  &lt;!-- The directory where the generated tree word lists will be 
    written to.--&gt;
  &lt;!-- default value: ${project.build.directory}/generated-sources/
    ruta/resources/ --&gt;
  &lt;outputDirectory&gt;${project.build.directory}/generated-sources/ruta/
    resources/&lt;/outputDirectory&gt;

  &lt;!-- Source file encoding. --&gt;
  &lt;!-- default value: ${project.build.sourceEncoding} --&gt;
  &lt;encoding&gt;UTF-8&lt;/encoding&gt;

 &lt;/configuration&gt;
&lt;/execution&gt;
&lt;/executions&gt;
&lt;/plugin&gt;
       </pre>
		</div>
		
		<div class="section" title="4.3.3.&nbsp;mtwl goal"><div class="titlepage"><div><div><h3 class="title" id="d5e3318">4.3.3.&nbsp;mtwl goal</h3></div></div></div>
    
    <p>
    The mtwl goal can be utilized to create a .mtwl file from multiple .txt files.
    Its usage and configuration is summarized in the following example:
    </p>
    <pre class="programlisting">&lt;plugin&gt;
&lt;groupId&gt;org.apache.uima&lt;/groupId&gt;
&lt;artifactId&gt;ruta-maven-plugin&lt;/artifactId&gt;
&lt;version&gt;2.3.0&lt;/version&gt;
&lt;configuration&gt;&lt;/configuration&gt;
&lt;executions&gt;
&lt;execution&gt;
 &lt;id&gt;default&lt;/id&gt;
 &lt;phase&gt;process-classes&lt;/phase&gt;
 &lt;goals&gt;
  &lt;goal&gt;mtwl&lt;/goal&gt;
 &lt;/goals&gt;
 &lt;configuration&gt;
  &lt;!-- This is a exemplary configuration, which explicitly specifies 
   the default configuration values if not mentioned otherwise. --&gt;

  &lt;!-- Compress resulting tree word list. --&gt;
  &lt;!-- default value: true --&gt;
  &lt;compress&gt;true&lt;/compress&gt;

  &lt;!-- The source files for the multi tree word list. --&gt;
  &lt;!-- default value: none --&gt;
  &lt;inputFiles&gt;
   &lt;directory&gt;${basedir}/src/main/resources&lt;/directory&gt;
   &lt;includes&gt;
    &lt;include&gt;*.txt&lt;/include&gt;
   &lt;/includes&gt;
  &lt;/inputFiles&gt;

  &lt;!-- The directory where the generated tree word list will be 
    written to. --&gt;
  &lt;!-- default value: ${project.build.directory}/generated-sources/ruta/
    resources/generated.mtwl --&gt;
  &lt;outputFile&gt;${project.build.directory}/generated-sources/ruta/resources/
    generated.mtwl&lt;/outputFile&gt;

  &lt;!-- Source file encoding. --&gt;
  &lt;!-- default value: ${project.build.sourceEncoding} --&gt;
  &lt;encoding&gt;UTF-8&lt;/encoding&gt;
  
 &lt;/configuration&gt;
&lt;/execution&gt;
&lt;/executions&gt;
&lt;/plugin&gt;
       </pre>
    </div>
		
	</div>

  <div class="section" title="4.4.&nbsp;Induce rules with the TextRuler framework"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="section.tools.ruta.workbench.textruler.example">4.4.&nbsp;Induce rules with the TextRuler framework</h2></div></div></div>
   
      <p> 
      This section gives a short example how the TextRuler framework is applied in order to induce annotation rules. We refer to the screenshot in <a class="xref" href="#figure.tools.ruta.workbench.textruler.main" title="Figure&nbsp;3.21.&nbsp;The UIMA Ruta TextRuler framework">Figure&nbsp;3.21, &#8220;The UIMA Ruta TextRuler framework
      &#8221;</a>
      for the configuration and are using the exemplary UIMA Ruta project <span class="quote">&#8220;<span class="quote">TextRulerExample</span>&#8221;</span>, which is part of the source release of UIMA Ruta.
      After importing the project into your workspace, please rebuild all UIMA Ruta scripts in order to create the descriptors, e.g., by cleaning the project.
      </p>
      <p> 
        In this example, we are using the <span class="quote">&#8220;<span class="quote">KEP</span>&#8221;</span> algorithm for learning annotation rules for identifying Bibtex entries in the reference section of scientific publications:
        </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
          <p>Select the folder <span class="quote">&#8220;<span class="quote">single</span>&#8221;</span> and drag and drop it to the <span class="quote">&#8220;<span class="quote">Training Data</span>&#8221;</span> text field. This folder contains one file with 
          correct annotations and serves as gold standard data in our example.</p>
        </li><li class="listitem">
          <p>Select the file <span class="quote">&#8220;<span class="quote">Feature.ruta</span>&#8221;</span> and drag and drop it to the <span class="quote">&#8220;<span class="quote">Preprocess Script</span>&#8221;</span> text field. This UIMA Ruta script knows all necessary types, especially the types
          of the annotations we try the learn rules for, and additionally it contains rules that create useful annotations, which can be used by the algorithm in order to learn better rules.</p>
        </li><li class="listitem">
          <p>Select the file <span class="quote">&#8220;<span class="quote">InfoTypes.txt</span>&#8221;</span> and drag and drop it to the <span class="quote">&#8220;<span class="quote">Information Types</span>&#8221;</span> list. This specifies the goal of the learning process, 
          which types of annotations should be annotated by the induced rules, respectively.</p>
        </li><li class="listitem">
          <p>Check the checkbox of the <span class="quote">&#8220;<span class="quote">KEP</span>&#8221;</span> algorithm and press the start button in the toolbar fo the view.</p>
        </li><li class="listitem">
          <p>The algorithm now tries to induce rules for the targeted types. The current result is displayed in the view <span class="quote">&#8220;<span class="quote">KEP Results</span>&#8221;</span> in the right part of the perspective.</p>
        </li><li class="listitem">
          <p>After the algorithms finished the learning process, create a new UIMA Ruta file in the <span class="quote">&#8220;<span class="quote">uima.ruta.example</span>&#8221;</span> package and copy the content of the result view
          to the new file. Now, the induced rules can be applied as a normal UIMA Ruta script file.</p>
        </li></ol></div><p>
      </p>
    </div>
    <div class="section" title="4.5.&nbsp;HTML annotations in plain text"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="section.tools.ruta.howto.html">4.5.&nbsp;HTML annotations in plain text</h2></div></div></div>
     
      <p> 
       The following script provides an example how to process HTML files with UIMA Ruta in order to get plain text documents 
       that still contain information about the HTML tags in form of annotations. The analysis engine descriptor HtmlViewWriter is identical to the common ViewWriter, 
       but additionally specifies a type system. More information about different options to configure the
       conversion can be found in <a class="link" href="#ugr.tools.ruta.ae.htmlconverter" title="1.5.6.&nbsp;HTML Converter">here</a>.
      </p>
          <pre class="programlisting">PACKAGE uima.ruta.example;

ENGINE utils.HtmlAnnotator;
ENGINE utils.HtmlConverter;
ENGINE HtmlViewWriter;
TYPESYSTEM utils.HtmlTypeSystem;
TYPESYSTEM utils.SourceDocumentInformation;

Document{-&gt; RETAINTYPE(SPACE,BREAK)};
Document{-&gt; EXEC(HtmlAnnotator)};

Document { -&gt; CONFIGURE(HtmlConverter, "inputView" = "_InitialView", 
    "outputView" = "plain"), 
      EXEC(HtmlConverter)};

Document{ -&gt; CONFIGURE(ViewWriter, "inputView" = "plain", 
    "outputView" = "_InitialView", "output" = "/../converted/"), 
    EXEC(HtmlViewWriter)};
       </pre>
    </div>
    
    <div class="section" title="4.6.&nbsp;Sorting files with UIMA Ruta"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="section.tools.ruta.howto.sorter">4.6.&nbsp;Sorting files with UIMA Ruta</h2></div></div></div>
     
      <p> 
       The following script provides an example how to utilize UIMA Ruta for sorting files.
      </p>
          <pre class="programlisting">ENGINE utils.XMIWriter;
TYPESYSTEM utils.SourceDocumentInformation;

DECLARE Pattern;

// some rule-based pattern
(NUM SPECIAL NUM SPECIAL NUM){-&gt; Pattern};

Document{CONTAINS(Pattern)-&gt;CONFIGURE(XMIWriter, 
  "Output" = "../with/"), EXEC(XMIWriter)};
Document{-CONTAINS(Pattern)-&gt;CONFIGURE(XMIWriter, 
  "Output" = "../without/"), EXEC(XMIWriter)};
       </pre>
    </div>
    <div class="section" title="4.7.&nbsp;Converting XML documents with UIMA Ruta"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="section.tools.ruta.howto.xml">4.7.&nbsp;Converting XML documents with UIMA Ruta</h2></div></div></div>
     
      <p> 
       The following script provides an example how to process XML files in order to retain only the text content. the removed XML elements should, howver, be available as annotations. 
       This script can therefore be applied to create xmiCAS files from text document annotated with XML tags. The analysis engine descriptor TEIViewWriter is identical to the common ViewWriter, 
       but additionally specifies a type system.
      </p>
          <pre class="programlisting">ENGINE utils.HtmlAnnotator;
TYPESYSTEM utils.HtmlTypeSystem;
ENGINE utils.HtmlConverter;
ENGINE TEIViewWriter;
TYPESYSTEM utils.SourceDocumentInformation;

DECLARE PersName, LastName, FirstName, AddName;

Document{-&gt;EXEC(HtmlAnnotator, {TAG})};
Document{-&gt; RETAINTYPE(MARKUP,SPACE)};
TAG.name=="PERSNAME"{-&gt; PersName};
TAG.name=="SURNAME"{-&gt; LastName};
TAG.name=="FORENAME"{-&gt; FirstName};
TAG.name=="ADDNAME"{-&gt; AddName};
Document{-&gt; RETAINTYPE};

Document { -&gt; CONFIGURE(HtmlConverter, "inputView" = "_InitialView", 
    "outputView" = "plain", "skipWhitespaces" = false), 
      EXEC(HtmlConverter)};

Document{ -&gt; CONFIGURE(ViewWriter, "inputView" = "plain", "outputView" = 
    "_InitialView", "output" = "/../converted/"), 
    EXEC(TEIViewWriter)};
       </pre>
    </div>
</div>
  
</div></body></html>