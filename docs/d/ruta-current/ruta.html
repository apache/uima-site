<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.20">
<meta name="author" content="Apache UIMA™ Development Community">
<title>Apache UIMA™ - Ruta</title>
<style>
/*! Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment the following line when using as a custom stylesheet */
/* @import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700"; */
html{font-family:sans-serif;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
b,strong{font-weight:bold}
abbr{font-size:.9em}
abbr[title]{cursor:help;border-bottom:1px dotted #dddddf;text-decoration:none}
dfn{font-style:italic}
hr{height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type=button],input[type=reset],input[type=submit]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type=checkbox],input[type=radio]{padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,::before,::after{box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;line-height:1;position:relative;cursor:auto;-moz-tab-size:4;-o-tab-size:4;tab-size:4;word-wrap:anywhere;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ul.square{list-style-type:square}
ul.circle ul:not([class]),ul.disc ul:not([class]),ul.square ul:not([class]){list-style:inherit}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:1px solid #dedede;word-wrap:normal}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre).nobreak{word-wrap:normal}
:not(pre).nowrap{white-space:nowrap}
:not(pre).pre-wrap{white-space:pre-wrap}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;border-radius:3px;box-shadow:0 1px 0 rgba(0,0,0,.2),inset 0 0 0 .1em #fff;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin:0 auto;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:flex;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border:1px solid #e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:none;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:hsla(0,0%,100%,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details{margin-left:1.25rem}
details>summary{cursor:pointer;display:block;position:relative;line-height:1.6;margin-bottom:.625rem;outline:none;-webkit-tap-highlight-color:transparent}
details>summary::-webkit-details-marker{display:none}
details>summary::before{content:"";border:solid transparent;border-left:solid;border-width:.3em 0 .3em .5em;position:absolute;top:.5em;left:-1.25rem;transform:translateX(15%)}
details[open]>summary::before{border:solid transparent;border-top:solid;border-width:.5em .3em 0;transform:translateY(15%)}
details>summary::after{content:"";width:1.25rem;height:1em;position:absolute;top:.3em;left:-1.25rem}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class=paragraph]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6);word-wrap:anywhere}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border:1px solid #e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;border-radius:4px}
.sidebarblock{border:1px solid #dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;border-radius:4px}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:first-child,.sidebarblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child,.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{border-radius:4px;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class=highlight],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos,pre.pygments .linenos{border-right:1px solid;opacity:.35;padding-right:.5em;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}
pre.pygments span.linenos{display:inline-block;margin-right:.75em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans-serif;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;font-size:.85rem;text-align:left;margin-right:0}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:1.25em;word-wrap:anywhere}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>*>tr>*{border-width:1px}
table.grid-cols>*>tr>*{border-width:0 1px}
table.grid-rows>*>tr>*{border-width:1px 0}
table.frame-all{border-width:1px}
table.frame-ends{border-width:1px 0}
table.frame-sides{border-width:0 1px}
table.frame-none>colgroup+*>:first-child>*,table.frame-sides>colgroup+*>:first-child>*{border-top-width:0}
table.frame-none>:last-child>:last-child>*,table.frame-sides>:last-child>:last-child>*{border-bottom-width:0}
table.frame-none>*>tr>:first-child,table.frame-ends>*>tr>:first-child{border-left-width:0}
table.frame-none>*>tr>:last-child,table.frame-ends>*>tr>:last-child{border-right-width:0}
table.stripes-all>*>tr,table.stripes-odd>*>tr:nth-of-type(odd),table.stripes-even>*>tr:nth-of-type(even),table.stripes-hover>*>tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
li>p:empty:only-child::before{content:"";display:inline-block}
ul.checklist>li>p:first-child{margin-left:-1em}
ul.checklist>li>p:first-child>.fa-square-o:first-child,ul.checklist>li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist>li>p:first-child>input[type=checkbox]:first-child{margin-right:.25em}
ul.inline{display:flex;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
td.hdlist2{word-wrap:anywhere}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:4px solid #fff;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);border-radius:50%;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt,summary{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,td.hdlist1,span.alt,summary{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]{border-bottom:1px dotted}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#header,#content,#footnotes,#footer{max-width:none}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media amzn-kf8,print{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
</head>
<body class="book toc2 toc-left">
<div id="header">
<h1>Apache UIMA™ - Ruta</h1>
<div class="details">
<span id="author" class="author">Apache UIMA™ Development Community</span><br>
<span id="revnumber">version 3.4.0</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Ruta Documentation</div>
<ul class="sectlevel1">
<li><a href="#_ugr.tools.ruta.overview">1. Apache UIMA Ruta Overview</a>
<ul class="sectlevel2">
<li><a href="#_ugr.tools.ruta.overview.intro">1.1. What is Apache UIMA Ruta?</a></li>
<li><a href="#_ugr.tools.ruta.overview.gettingstarted">1.2. Getting started</a></li>
<li><a href="#_ugr.tools.ruta.overview.coreconcepts">1.3. Core Concepts</a></li>
<li><a href="#_ugr.tools.ruta.overview.examples">1.4. Learning by Example</a></li>
<li><a href="#_ugr.tools.ruta.ae">1.5. UIMA Analysis Engines</a>
<ul class="sectlevel3">
<li><a href="#_ugr.tools.ruta.ae.basic">1.5.1. Ruta Engine</a>
<ul class="sectlevel4">
<li><a href="#_ugr.tools.ruta.ae.basic.parameter">Configuration Parameters</a>
<ul class="sectlevel5">
<li><a href="#_ugr.tools.ruta.ae.basic.parameter.mainscript">mainScript</a></li>
<li><a href="#_ugr.tools.ruta.ae.basic.parameter.rules">rules</a></li>
<li><a href="#_ugr.tools.ruta.ae.basic.parameter.rulesscriptname">rulesScriptName</a></li>
<li><a href="#_ugr.tools.ruta.ae.basic.parameter.scriptencoding">scriptEncoding</a></li>
<li><a href="#_ugr.tools.ruta.ae.basic.parameter.scriptpaths">scriptPaths</a></li>
<li><a href="#_ugr.tools.ruta.ae.basic.parameter.descriptorpaths">descriptorPaths</a></li>
<li><a href="#_ugr.tools.ruta.ae.basic.parameter.resourcepaths">resourcePaths</a></li>
<li><a href="#_ugr.tools.ruta.ae.basic.parameter.additionalscripts">additionalScripts</a></li>
<li><a href="#_ugr.tools.ruta.ae.basic.parameter.additionalengines">additionalEngines</a></li>
<li><a href="#_ugr.tools.ruta.ae.basic.parameter.additionaluimafitengines">additionalUimafitEngines</a></li>
<li><a href="#_ugr.tools.ruta.ae.basic.parameter.additionalextensions">additionalExtensions</a></li>
<li><a href="#_ugr.tools.ruta.ae.basic.parameter.reloadscript">reloadScript</a></li>
<li><a href="#_ugr.tools.ruta.ae.basic.parameter.seeders">seeders</a></li>
<li><a href="#_ugr.tools.ruta.ae.basic.parameter.defaultfilteredtypes">defaultFilteredTypes</a></li>
<li><a href="#_ugr.tools.ruta.ae.basic.parameter.removebasics">removeBasics</a></li>
<li><a href="#_ugr.tools.ruta.ae.basic.parameter.indexonly">indexOnly</a></li>
<li><a href="#_ugr.tools.ruta.ae.basic.parameter.indexskiptypes">indexSkipTypes</a></li>
<li><a href="#_ugr.tools.ruta.ae.basic.parameter.indexonlymentionedtypes">indexOnlyMentionedTypes</a></li>
<li><a href="#_ugr.tools.ruta.ae.basic.parameter.indexadditionally">indexAdditionally</a></li>
<li><a href="#_ugr.tools.ruta.ae.basic.parameter.reindexonly">reindexOnly</a></li>
<li><a href="#_ugr.tools.ruta.ae.basic.parameter.reindexskiptypes">reindexSkipTypes</a></li>
<li><a href="#_ugr.tools.ruta.ae.basic.parameter.reindexonlymentionedtypes">reindexOnlyMentionedTypes</a></li>
<li><a href="#_ugr.tools.ruta.ae.basic.parameter.reindexadditionally">reindexAdditionally</a></li>
<li><a href="#_ugr.tools.ruta.ae.basic.parameter.indexupdatemode">indexUpdateMode</a></li>
<li><a href="#_ugr.tools.ruta.ae.basic.parameter.validateinternalindexing">validateInternalIndexing</a></li>
<li><a href="#_ugr.tools.ruta.ae.basic.parameter.emptyisinvisible">emptyIsInvisible</a></li>
<li><a href="#_ugr.tools.ruta.ae.basic.parameter.modifydatapath">modifyDataPath</a></li>
<li><a href="#_ugr.tools.ruta.ae.basic.parameter.strictimports">strictImports</a></li>
<li><a href="#_ugr.tools.ruta.ae.basic.parameter.typeignorepattern">typeIgnorePattern</a></li>
<li><a href="#_ugr.tools.ruta.ae.basic.parameter.dynamicanchoring">dynamicAnchoring</a></li>
<li><a href="#_ugr.tools.ruta.ae.basic.parameter.lowmemoryprofile">lowMemoryProfile</a></li>
<li><a href="#_ugr.tools.ruta.ae.basic.parameter.simplegreedyforcomposed">simpleGreedyForComposed</a></li>
<li><a href="#_ugr.tools.ruta.ae.basic.parameter.debug">debug</a></li>
<li><a href="#_ugr.tools.ruta.ae.basic.parameter.debugwithmatches">debugWithMatches</a></li>
<li><a href="#_ugr.tools.ruta.ae.basic.parameter.debugaddtoindexes">debugAddToIndexes</a></li>
<li><a href="#_ugr.tools.ruta.ae.basic.parameter.debugonlyfor">debugOnlyFor</a></li>
<li><a href="#_ugr.tools.ruta.ae.basic.parameter.profile">profile</a></li>
<li><a href="#_ugr.tools.ruta.ae.basic.parameter.statistics">statistics</a></li>
<li><a href="#_ugr.tools.ruta.ae.basic.parameter.createdby">createdBy</a></li>
<li><a href="#_ugr.tools.ruta.ae.basic.parameter.varnames">varNames</a></li>
<li><a href="#_ugr.tools.ruta.ae.basic.parameter.varvalues">varValues</a></li>
<li><a href="#_ugr.tools.ruta.ae.basic.parameter.dictremovews">dictRemoveWS</a></li>
<li><a href="#_ugr.tools.ruta.ae.basic.parameter.csvseparator">csvSeparator</a></li>
<li><a href="#_ugr.tools.ruta.ae.basic.parameter.inferencevisitors">inferenceVisitors</a></li>
<li><a href="#_ugr.tools.ruta.ae.basic.parameter.maxrulematches">maxRuleMatches</a></li>
<li><a href="#_ugr.tools.ruta.ae.basic.parameter.maxruleelementmatches">maxRuleElementMatches</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_ugr.tools.ruta.ae.annotationwriter">1.5.2. Annotation Writer</a>
<ul class="sectlevel4">
<li><a href="#_ugr.tools.ruta.ae.annotationwriter.parameter">Configuration Parameters</a>
<ul class="sectlevel5">
<li><a href="#_ugr.tools.ruta.ae.annotationwriter.parameter.output">Output</a></li>
<li><a href="#_ugr.tools.ruta.ae.annotationwriter.parameter.encoding">Encoding</a></li>
<li><a href="#_ugr.tools.ruta.ae.annotationwriter.parameter.type">Type</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_ugr.tools.ruta.ae.plaintext">1.5.3. Plain Text Annotator</a></li>
<li><a href="#_ugr.tools.ruta.ae.modifier">1.5.4. Modifier</a>
<ul class="sectlevel4">
<li><a href="#_ugr.tools.ruta.ae.modifier.parameter">Configuration Parameters</a>
<ul class="sectlevel5">
<li><a href="#_ugr.tools.ruta.ae.modifier.parameter.stylemap">styleMap</a></li>
<li><a href="#_ugr.tools.ruta.ae.modifier.parameter.descriptorpaths">descriptorPaths</a></li>
<li><a href="#_ugr.tools.ruta.ae.modifier.parameter.outputlocation">outputLocation</a></li>
<li><a href="#_ugr.tools.ruta.ae.modifier.parameter.outputview">outputView</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_ugr.tools.ruta.ae.html">1.5.5. HTML Annotator</a>
<ul class="sectlevel4">
<li><a href="#_ugr.tools.ruta.ae.html.parameter">Configuration Parameters</a>
<ul class="sectlevel5">
<li><a href="#_ugr.tools.ruta.ae.html.parameter.onlycontent">onlyContent</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_ugr.tools.ruta.ae.htmlconverter">1.5.6. HTML Converter</a>
<ul class="sectlevel4">
<li><a href="#_ugr.tools.ruta.ae.htmlconverter.parameter">Configuration Parameters</a>
<ul class="sectlevel5">
<li><a href="#_ugr.tools.ruta.ae.htmlconverter.parameter.outputview">outputView</a></li>
<li><a href="#_ugr.tools.ruta.ae.htmlconverter.parameter.inputview">inputView</a></li>
<li><a href="#_ugr.tools.ruta.ae.htmlconverter.parameter.newlineinducingtags">newlineInducingTags</a></li>
<li><a href="#_ugr.tools.ruta.ae.htmlconverter.parameter.replacelinebreaks">replaceLinebreaks</a></li>
<li><a href="#_ugr.tools.ruta.ae.htmlconverter.parameter.linebreakreplacement">replaceLinebreaks</a></li>
<li><a href="#_ugr.tools.ruta.ae.htmlconverter.parameter.conversionpolicy">conversionPolicy</a></li>
<li><a href="#_ugr.tools.ruta.ae.htmlconverter.parameter.conversionpatterns">conversionPatterns</a></li>
<li><a href="#_ugr.tools.ruta.ae.htmlconverter.parameter.conversionreplacements">conversionReplacements</a></li>
<li><a href="#_ugr.tools.ruta.ae.htmlconverter.parameter.skipwhitespaces">skipWhitespaces</a></li>
<li><a href="#_ugr.tools.ruta.ae.htmlconverter.parameter.processall">processAll</a></li>
<li><a href="#_ugr.tools.ruta.ae.htmlconverter.parameter.newlineinducingtagregexp">newlineInducingTagRegExp</a></li>
<li><a href="#_ugr.tools.ruta.ae.htmlconverter.parameter.gapinducingtags">gapInducingTags</a></li>
<li><a href="#_ugr.tools.ruta.ae.htmlconverter.parameter.gaptext">gapText</a></li>
<li><a href="#_ugr.tools.ruta.ae.htmlconverter.parameter.usespacegap">useSpaceGap</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_ugr.tools.ruta.ae.stylemap">1.5.7. Style Map Creator</a>
<ul class="sectlevel4">
<li><a href="#_ugr.tools.ruta.ae.stylemap.parameter">Configuration Parameters</a>
<ul class="sectlevel5">
<li><a href="#_ugr.tools.ruta.ae.stylemap.parameter.stylemap">styleMap</a></li>
<li><a href="#_ugr.tools.ruta.ae.stylemap.parameter.descriptorpaths">descriptorPaths</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_ugr.tools.ruta.ae.cutter">1.5.8. Cutter</a>
<ul class="sectlevel4">
<li><a href="#_ugr.tools.ruta.ae.cutter.parameter">Configuration Parameters</a>
<ul class="sectlevel5">
<li><a href="#_ugr.tools.ruta.ae.cutter.parameter.keep">keep</a></li>
<li><a href="#_ugr.tools.ruta.ae.cutter.parameter.inputview">inputView</a></li>
<li><a href="#_ugr.tools.ruta.ae.cutter.parameter.outputview">outputView</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_ugr.tools.ruta.ae.view">1.5.9. View Writer</a>
<ul class="sectlevel4">
<li><a href="#_ugr.tools.ruta.ae.view.parameter">Configuration Parameters</a>
<ul class="sectlevel5">
<li><a href="#_ugr.tools.ruta.ae.view.parameter.output">output</a></li>
<li><a href="#_ugr.tools.ruta.ae.view.parameter.inputview">inputView</a></li>
<li><a href="#_ugr.tools.ruta.ae.view.parameter.outputview">outputView</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_ugr.tools.ruta.ae.xmi">1.5.10. XMI Writer</a>
<ul class="sectlevel4">
<li><a href="#_ugr.tools.ruta.ae.xmi.parameter">Configuration Parameters</a>
<ul class="sectlevel5">
<li><a href="#_ugr.tools.ruta.ae.xmi.parameter.output">Output</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#_ugr.tools.ruta.language.language">2. Apache UIMA Ruta Language</a>
<ul class="sectlevel2">
<li><a href="#_ugr.tools.ruta.language.syntax">2.1. Syntax</a></li>
<li><a href="#_ugr.tools.ruta.language.anchoring">2.2. Rule elements and their matching order</a></li>
<li><a href="#_ugr.tools.ruta.language.seeding">2.3. Basic annotations and tokens</a></li>
<li><a href="#_ugr.tools.ruta.language.quantifier">2.4. Quantifiers</a>
<ul class="sectlevel3">
<li><a href="#_ugr.tools.ruta.language.quantifier.sg">2.4.1. * Star Greedy</a></li>
<li><a href="#_ugr.tools.ruta.language.quantifier.sr">2.4.2. *? Star Reluctant</a></li>
<li><a href="#_ugr.tools.ruta.language.quantifier.pg">2.4.3. + Plus Greedy</a></li>
<li><a href="#_ugr.tools.ruta.language.quantifier.pr">2.4.4. +? Plus Reluctant</a></li>
<li><a href="#_ugr.tools.ruta.language.quantifier.qg">2.4.5. ? Question Greedy</a></li>
<li><a href="#_ugr.tools.ruta.language.quantifier.qr">2.4.6. ?? Question Reluctant</a></li>
<li><a href="#_ugr.tools.ruta.language.quantifier.mmg">2.4.7. [x,y] Min Max Greedy</a></li>
<li><a href="#_ugr.tools.ruta.language.quantifier.mmr">2.4.8. [x,y]? Min Max Reluctant</a></li>
</ul>
</li>
<li><a href="#_ugr.tools.ruta.language.declarations">2.5. Declarations</a>
<ul class="sectlevel3">
<li><a href="#_ugr.tools.ruta.language.declarations.type">2.5.1. Types</a></li>
<li><a href="#_ugr.tools.ruta.language.declarations.variable">2.5.2. Variables</a></li>
<li><a href="#_ugr.tools.ruta.language.declarations.ressource">2.5.3. Resources</a></li>
<li><a href="#_ugr.tools.ruta.language.declarations.scripts">2.5.4. Scripts</a></li>
<li><a href="#_ugr.tools.ruta.language.declarations.components">2.5.5. Components</a></li>
</ul>
</li>
<li><a href="#_ugr.tools.ruta.language.expressions">2.6. Expressions</a>
<ul class="sectlevel3">
<li><a href="#_ugr.tools.ruta.language.expressions.type">2.6.1. Type Expressions</a></li>
<li><a href="#_ugr.tools.ruta.language.expressions.annotation">2.6.2. Annotation Expressions</a></li>
<li><a href="#_ugr.tools.ruta.language.expressions.number">2.6.3. Number Expressions</a></li>
<li><a href="#_ugr.tools.ruta.language.expressions.string">2.6.4. String Expressions</a></li>
<li><a href="#_ugr.tools.ruta.language.expressions.boolean">2.6.5. Boolean Expressions</a></li>
<li><a href="#_ugr.tools.ruta.language.expressions.lists">2.6.6. List Expressions</a></li>
<li><a href="#_ugr.tools.ruta.language.expressions.features">2.6.7. Feature Expressions</a></li>
</ul>
</li>
<li><a href="#_ugr.tools.ruta.language.conditions">2.7. Conditions</a>
<ul class="sectlevel3">
<li><a href="#_ugr.tools.ruta.language.conditions.after">2.7.1. AFTER</a></li>
<li><a href="#_ugr.tools.ruta.language.conditions.and">2.7.2. AND</a></li>
<li><a href="#_ugr.tools.ruta.language.conditions.before">2.7.3. BEFORE</a></li>
<li><a href="#_ugr.tools.ruta.language.conditions.contains">2.7.4. CONTAINS</a></li>
<li><a href="#_ugr.tools.ruta.language.conditions.contextcount">2.7.5. CONTEXTCOUNT</a></li>
<li><a href="#_ugr.tools.ruta.language.conditions.count">2.7.6. COUNT</a></li>
<li><a href="#_ugr.tools.ruta.language.conditions.currentcount">2.7.7. CURRENTCOUNT</a></li>
<li><a href="#_ugr.tools.ruta.language.conditions.endswith">2.7.8. ENDSWITH</a></li>
<li><a href="#_ugr.tools.ruta.language.conditions.feature">2.7.9. FEATURE</a></li>
<li><a href="#_ugr.tools.ruta.language.conditions.if">2.7.10. IF</a></li>
<li><a href="#_ugr.tools.ruta.language.conditions.inlist">2.7.11. INLIST</a></li>
<li><a href="#_ugr.tools.ruta.language.conditions.is">2.7.12. IS</a></li>
<li><a href="#_ugr.tools.ruta.language.conditions.last">2.7.13. LAST</a></li>
<li><a href="#_ugr.tools.ruta.language.conditions.mofn">2.7.14. MOFN</a></li>
<li><a href="#_ugr.tools.ruta.language.conditions.near">2.7.15. NEAR</a></li>
<li><a href="#_ugr.tools.ruta.language.conditions.not">2.7.16. NOT</a></li>
<li><a href="#_ugr.tools.ruta.language.conditions.or">2.7.17. OR</a></li>
<li><a href="#_ugr.tools.ruta.language.conditions.parse">2.7.18. PARSE</a></li>
<li><a href="#_ugr.tools.ruta.language.conditions.partof">2.7.19. PARTOF</a></li>
<li><a href="#_ugr.tools.ruta.language.conditions.partofneq">2.7.20. PARTOFNEQ</a></li>
<li><a href="#_ugr.tools.ruta.language.conditions.position">2.7.21. POSITION</a></li>
<li><a href="#_ugr.tools.ruta.language.conditions.regexp">2.7.22. REGEXP</a></li>
<li><a href="#_ugr.tools.ruta.language.conditions.score">2.7.23. SCORE</a></li>
<li><a href="#_ugr.tools.ruta.language.conditions.size">2.7.24. SIZE</a></li>
<li><a href="#_ugr.tools.ruta.language.conditions.startswith">2.7.25. STARTSWITH</a></li>
<li><a href="#_ugr.tools.ruta.language.conditions.totalcount">2.7.26. TOTALCOUNT</a></li>
<li><a href="#_ugr.tools.ruta.language.conditions.vote">2.7.27. VOTE</a></li>
</ul>
</li>
<li><a href="#_ugr.tools.ruta.language.actions">2.8. Actions</a>
<ul class="sectlevel3">
<li><a href="#_ugr.tools.ruta.language.actions.add">2.8.1. ADD</a></li>
<li><a href="#_ugr.tools.ruta.language.actions.addfiltertype">2.8.2. ADDFILTERTYPE</a></li>
<li><a href="#_ugr.tools.ruta.language.actions.addretaintype">2.8.3. ADDRETAINTYPE</a></li>
<li><a href="#_ugr.tools.ruta.language.actions.assign">2.8.4. ASSIGN</a></li>
<li><a href="#_ugr.tools.ruta.language.actions.call">2.8.5. CALL</a></li>
<li><a href="#_ugr.tools.ruta.language.actions.clear">2.8.6. CLEAR</a></li>
<li><a href="#_ugr.tools.ruta.language.actions.color">2.8.7. COLOR</a></li>
<li><a href="#_ugr.tools.ruta.language.actions.configure">2.8.8. CONFIGURE</a></li>
<li><a href="#_ugr.tools.ruta.language.actions.create">2.8.9. CREATE</a></li>
<li><a href="#_ugr.tools.ruta.language.actions.del">2.8.10. DEL</a></li>
<li><a href="#_ugr.tools.ruta.language.actions.dynamicanchoring">2.8.11. DYNAMICANCHORING</a></li>
<li><a href="#_ugr.tools.ruta.language.actions.exec">2.8.12. EXEC</a></li>
<li><a href="#_ugr.tools.ruta.language.actions.fill">2.8.13. FILL</a></li>
<li><a href="#_ugr.tools.ruta.language.actions.filtertype">2.8.14. FILTERTYPE</a></li>
<li><a href="#_ugr.tools.ruta.language.actions.gather">2.8.15. GATHER</a></li>
<li><a href="#_ugr.tools.ruta.language.actions.get">2.8.16. GET</a></li>
<li><a href="#_ugr.tools.ruta.language.actions.getfeature">2.8.17. GETFEATURE</a></li>
<li><a href="#_ugr.tools.ruta.language.actions.getlist">2.8.18. GETLIST</a></li>
<li><a href="#_ugr.tools.ruta.language.actions.greedyanchoring">2.8.19. GREEDYANCHORING</a></li>
<li><a href="#_ugr.tools.ruta.language.actions.log">2.8.20. LOG</a></li>
<li><a href="#_ugr.tools.ruta.language.actions.mark">2.8.21. MARK</a></li>
<li><a href="#_ugr.tools.ruta.language.actions.markfast">2.8.22. MARKFAST</a></li>
<li><a href="#_ugr.tools.ruta.language.actions.markfirst">2.8.23. MARKFIRST</a></li>
<li><a href="#_ugr.tools.ruta.language.actions.marklast">2.8.24. MARKLAST</a></li>
<li><a href="#_ugr.tools.ruta.language.actions.markonce">2.8.25. MARKONCE</a></li>
<li><a href="#_ugr.tools.ruta.language.actions.markscore">2.8.26. MARKSCORE</a></li>
<li><a href="#_ugr.tools.ruta.language.actions.marktable">2.8.27. MARKTABLE</a></li>
<li><a href="#_ugr.tools.ruta.language.actions.matchedtext">2.8.28. MATCHEDTEXT</a></li>
<li><a href="#_ugr.tools.ruta.language.actions.merge">2.8.29. MERGE</a></li>
<li><a href="#_ugr.tools.ruta.language.actions.remove">2.8.30. REMOVE</a></li>
<li><a href="#_ugr.tools.ruta.language.actions.removeduplicate">2.8.31. REMOVEDUPLICATE</a></li>
<li><a href="#_ugr.tools.ruta.language.actions.removefiltertype">2.8.32. REMOVEFILTERTYPE</a></li>
<li><a href="#_ugr.tools.ruta.language.actions.removeretaintype">2.8.33. REMOVERETAINTYPE</a></li>
<li><a href="#_ugr.tools.ruta.language.actions.replace">2.8.34. REPLACE</a></li>
<li><a href="#_ugr.tools.ruta.language.actions.retaintype">2.8.35. RETAINTYPE</a></li>
<li><a href="#_ugr.tools.ruta.language.actions.setfeature">2.8.36. SETFEATURE</a></li>
<li><a href="#_ugr.tools.ruta.language.actions.shift">2.8.37. SHIFT</a></li>
<li><a href="#_ugr.tools.ruta.language.actions.split">2.8.38. SPLIT</a></li>
<li><a href="#_ugr.tools.ruta.language.actions.transfer">2.8.39. TRANSFER</a></li>
<li><a href="#_ugr.tools.ruta.language.actions.trie">2.8.40. TRIE</a></li>
<li><a href="#_ugr.tools.ruta.language.actions.trim">2.8.41. TRIM</a></li>
<li><a href="#_ugr.tools.ruta.language.actions.unmark">2.8.42. UNMARK</a></li>
<li><a href="#_ugr.tools.ruta.language.actions.unmarkall">2.8.43. UNMARKALL</a></li>
</ul>
</li>
<li><a href="#_ugr.tools.ruta.language.filtering">2.9. Robust extraction using filtering</a></li>
<li><a href="#_ugr.tools.ruta.language.wildcard">2.10. Wildcard #</a></li>
<li><a href="#_ugr.tools.ruta.language.optional">2.11. Optional match _</a></li>
<li><a href="#_ugr.tools.ruta.language.labels">2.12. Label expressions</a></li>
<li><a href="#_ugr.tools.ruta.language.blocks">2.13. Blocks</a>
<ul class="sectlevel3">
<li><a href="#_ugr.tools.ruta.language.blocks.block">2.13.1. BLOCK</a>
<ul class="sectlevel4">
<li><a href="#_ugr.tools.ruta.language.blocks.block.condition">Conditioned statements</a></li>
<li><a href="#_ugr.tools.ruta.language.blocks.block.foreach">Loops with restriction of the matching window</a></li>
<li><a href="#_ugr.tools.ruta.language.blocks.block.procedure">Procedures</a></li>
</ul>
</li>
<li><a href="#_ugr.tools.ruta.language.blocks.foreach">2.13.2. FOREACH</a></li>
</ul>
</li>
<li><a href="#_ugr.tools.ruta.language.inlined">2.14. Inlined rules</a></li>
<li><a href="#_ugr.tools.ruta.language.macro">2.15. Macros for conditions and actions</a></li>
<li><a href="#_ugr.tools.ruta.language.score">2.16. Heuristic extraction using scoring rules</a></li>
<li><a href="#_ugr.tools.ruta.language.modification">2.17. Modification</a></li>
<li><a href="#_ugr.tools.ruta.language.external_resources">2.18. External resources</a>
<ul class="sectlevel3">
<li><a href="#_wordlists">2.18.1. WORDLISTs</a></li>
<li><a href="#_wordtables">2.18.2. WORDTABLEs</a></li>
</ul>
</li>
<li><a href="#_ugr.tools.ruta.language.regexprule">2.19. Simple Rules based on Regular Expressions</a></li>
<li><a href="#_ugr.tools.ruta.language.extensions">2.20. Language Extensions</a>
<ul class="sectlevel3">
<li><a href="#_ugr.tools.ruta.language.extensions.core_ext">2.20.1. Provided Extensions</a>
<ul class="sectlevel4">
<li><a href="#_ugr.tools.ruta.language.extensions.core_ext.documentblock">DOCUMENTBLOCK</a></li>
<li><a href="#_ugr.tools.ruta.language.extensions.core_ext.onlyfirst">ONLYFIRST</a></li>
<li><a href="#_ugr.tools.ruta.language.extensions.core_ext.onlyonce">ONLYONCE</a></li>
<li><a href="#_ugr.tools.ruta.language.extensions.core_ext.stringfunctions">Stringfunctions</a>
<ul class="sectlevel5">
<li><a href="#_firstchartouppercaseistringexpression_expr">firstCharToUpperCase(IStringExpression expr)</a></li>
<li><a href="#_replacefirstistringexpression_expr_istringexpressionsearchtermistringexpressionreplacement">replaceFirst(IStringExpression expr, IStringExpressionsearchTerm,IStringExpressionreplacement)</a></li>
<li><a href="#_replaceallistringexpression_expr_istringexpressionsearchtermistringexpressionreplacement">replaceAll(IStringExpression expr, IStringExpressionsearchTerm,IStringExpressionreplacement)</a></li>
<li><a href="#_substringistringexpression_expr_inumberexpression_frominumberexpression_to">substring(IStringExpression expr, INumberExpression from,INumberExpression to)</a></li>
<li><a href="#_tolowercaseistringexpression_expr">toLowerCase(IStringExpression expr)</a></li>
<li><a href="#_touppercaseistringexpression_expr">toUpperCase(IStringExpression expr)</a></li>
<li><a href="#_containsistringexpression_expristringexpression_contains">contains(IStringExpression expr,IStringExpression contains)</a></li>
<li><a href="#_endswithistringexpression_expristringexpression_expr">endsWith(IStringExpression expr,IStringExpression expr)</a></li>
<li><a href="#_startswithistringexpression_expristringexpression_expr">startsWith(IStringExpression expr,IStringExpression expr)</a></li>
<li><a href="#_equalsistringexpression_expristringexpression_expr_and_equalsignorecaseexprexpr">equals(IStringExpression expr,IStringExpression expr) and equalsIgnoreCase(expr,expr)</a></li>
<li><a href="#_isemptyistringexpression_expr_and_equalsignorecaseexprexpr">isEmpty(IStringExpression expr) and equalsIgnoreCase(expr,expr)</a></li>
</ul>
</li>
<li><a href="#_ugr.tools.ruta.language.extensions.core_ext.typefunctions">typeFromString</a></li>
</ul>
</li>
<li><a href="#_ugr.tools.ruta.language.extensions.new">2.20.2. Adding new Language Elements</a></li>
</ul>
</li>
<li><a href="#_ugr.tools.ruta.language.internal_indxexing">2.21. Internal indexing and reindexing</a>
<ul class="sectlevel3">
<li><a href="#_ugr.tools.ruta.language.internal_indxexing.why">2.21.1. Why additional indexing?</a></li>
<li><a href="#_ugr.tools.ruta.language.internal_indxexing.how">2.21.2. How is it stored, created and updated?</a></li>
<li><a href="#_ugr.tools.ruta.language.internal_indxexing.optimize">2.21.3. How to optimize the performance?</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_ugr.tools.ruta.workbench">3. Apache UIMA Ruta Workbench</a>
<ul class="sectlevel2">
<li><a href="#_section.ugr.tools.ruta.workbench.install">3.1. Installation</a></li>
<li><a href="#_section.ugr.tools.ruta.workbench.overview">3.2. UIMA Ruta Workbench Overview</a></li>
<li><a href="#_section.ugr.tools.ruta.workbench.projects">3.3. UIMA Ruta Projects</a>
<ul class="sectlevel3">
<li><a href="#_section.ugr.tools.ruta.workbench.projects.create_projects">3.3.1. UIMA Ruta create project wizard</a></li>
</ul>
</li>
<li><a href="#_section.ugr.tools.ruta.workbench.ruta_perspective">3.4. UIMA Ruta Perspective</a>
<ul class="sectlevel3">
<li><a href="#_section.ugr.tools.ruta.workbench.ruta_perspective.annotation_browser">3.4.1. Annotation Browser</a></li>
<li><a href="#_section.ugr.tools.ruta.workbench.ruta_perspective.selection">3.4.2. Selection</a></li>
</ul>
</li>
<li><a href="#_section.ugr.tools.ruta.workbench.explain_perspective">3.5. UIMA Ruta Explain Perspective</a>
<ul class="sectlevel3">
<li><a href="#_section.ugr.tools.ruta.workbench.explain_perspective.applied_rules">3.5.1. Applied Rules</a></li>
<li><a href="#_section.ugr.tools.ruta.workbench.explain_perspective.matched_and_failed_rules">3.5.2. Matched Rules and Failed Rules</a></li>
<li><a href="#_section.ugr.tools.ruta.workbench.explain_perspective.rule_elements">3.5.3. Rule Elements</a></li>
<li><a href="#_section.ugr.tools.ruta.workbench.explain_perspective.inlined_rules">3.5.4. Inlined Rules</a></li>
<li><a href="#_section.ugr.tools.ruta.workbench.explain_perspective.covering_rules">3.5.5. Covering Rules</a></li>
<li><a href="#_section.ugr.tools.ruta.workbench.explain_perspective.rule_list">3.5.6. Rule List</a></li>
<li><a href="#_section.ugr.tools.ruta.workbench.explain_perspective.created_by">3.5.7. Created By</a></li>
<li><a href="#_section.ugr.tools.ruta.workbench.explain_perspective.statistics">3.5.8. Statistics</a></li>
</ul>
</li>
<li><a href="#_section.tools.ruta.workbench.cde">3.6. UIMA Ruta CDE perspective</a>
<ul class="sectlevel3">
<li><a href="#_section.tools.ruta.workbench.cde.documents">3.6.1. CDE Documents view</a></li>
<li><a href="#_section.tools.ruta.workbench.cde.constraints">3.6.2. CDE Constraints view</a></li>
<li><a href="#_section.tools.ruta.workbench.cde.result">3.6.3. CDE Result view</a></li>
</ul>
</li>
<li><a href="#_section.ugr.tools.ruta.workbench.ruta_query">3.7. Ruta Query View</a></li>
<li><a href="#_section.ugr.tools.ruta.workbench.testing">3.8. Testing</a>
<ul class="sectlevel3">
<li><a href="#_section.ugr.tools.ruta.workbench.testing.usage">3.8.1. Usage</a></li>
<li><a href="#_section.ugr.tools.ruta.workbench.testing.evaluators">3.8.2. Evaluators</a></li>
</ul>
</li>
<li><a href="#_section.tools.ruta.workbench.textruler">3.9. TextRuler</a>
<ul class="sectlevel3">
<li><a href="#_section.tools.ruta.workbench.textruler.learner">3.9.1. Included rule learning algorithms</a>
<ul class="sectlevel4">
<li><a href="#_section.tools.ruta.workbench.textruler.lp2">LP2</a></li>
<li><a href="#_section.tools.ruta.workbench.textruler.whisk">WHISK</a></li>
<li><a href="#_section.tools.ruta.workbench.textruler.trabal">TraBaL</a></li>
<li><a href="#_section.tools.ruta.workbench.textruler.kep">KEP</a></li>
</ul>
</li>
<li><a href="#_section.tools.ruta.workbench.textruler.ui">3.9.2. The TextRuler view</a></li>
</ul>
</li>
<li><a href="#_section.tools.ruta.workbench.check">3.10. Check Annotations view</a></li>
<li><a href="#_section.ugr.tools.ruta.workbench.create_dictionaries">3.11. Creation of Tree Word Lists</a></li>
<li><a href="#_ugr.tools.ruta.workbench.apply">3.12. Apply a UIMA Ruta script to a folder</a></li>
</ul>
</li>
<li><a href="#_ugr.tools.ruta.howtos">4. Apache UIMA Ruta HowTos</a>
<ul class="sectlevel2">
<li><a href="#_ugr.tools.ruta.ae.basic.apply">4.1. Apply UIMA Ruta Analysis Engine in plain Java</a></li>
<li><a href="#_ugr.tools.ruta.integration">4.2. Integrating UIMA Ruta in an existing UIMA Annotator</a>
<ul class="sectlevel3">
<li><a href="#_ugr.tools.ruta.ae.integration.mvn">4.2.1. Adding Ruta to our Annotator</a></li>
<li><a href="#_ugr.tools.ruta.ae.integration.loading">4.2.2. Developing Ruta rules and applying them from inside Java code</a></li>
</ul>
</li>
<li><a href="#_ugr.tools.ruta.maven">4.3. UIMA Ruta Maven Plugin</a>
<ul class="sectlevel3">
<li><a href="#_generate_goal">4.3.1. generate goal</a></li>
<li><a href="#_twl_goal">4.3.2. twl goal</a></li>
<li><a href="#_mtwl_goal">4.3.3. mtwl goal</a></li>
</ul>
</li>
<li><a href="#_ugr.tools.ruta.archetype">4.4. UIMA Ruta Maven Archetype</a></li>
<li><a href="#_section.tools.ruta.workbench.textruler.example">4.5. Induce rules with the TextRuler framework</a></li>
<li><a href="#_section.tools.ruta.howto.html">4.6. HTML annotations in plain text</a></li>
<li><a href="#_section.tools.ruta.howto.sorter">4.7. Sorting files with UIMA Ruta</a></li>
<li><a href="#_section.tools.ruta.howto.xml">4.8. Converting XML documents with UIMA Ruta</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Copyright © 2023 The Apache Software Foundation</p>
</div>
<h4 id="_license_and_disclaimer" class="discrete">License and Disclaimer</h4>
<div class="paragraph">
<p>The ASF licenses this documentation to you under the Apache License, Version 2.0 (the "License");
you may not use this documentation except in compliance with the License.  You may obtain a copy of
the License at</p>
</div>
<div class="paragraph text-center">
<p><a href="http://www.apache.org/licenses/LICENSE-2.0" class="bare">http://www.apache.org/licenses/LICENSE-2.0</a></p>
</div>
<div class="paragraph">
<p>Unless required by applicable law or agreed to in writing, this documentation and its contents are
distributed under the License on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
either express or implied.  See the License for the specific language governing permissions and
limitations under the License.</p>
</div>
<h4 id="_trademarks" class="discrete">Trademarks</h4>
<div class="paragraph">
<p>All terms mentioned in the text that are known to be trademarks or service marks have been
appropriately capitalized.  Use of such terms in this book should not be regarded as affecting the
validity of the the trademark or service mark.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_ugr.tools.ruta.overview"><a class="anchor" href="#_ugr.tools.ruta.overview"></a>1. Apache UIMA Ruta Overview</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_ugr.tools.ruta.overview.intro"><a class="anchor" href="#_ugr.tools.ruta.overview.intro"></a>1.1. What is Apache UIMA Ruta?</h3>
<div class="paragraph">
<p>Apache UIMA Ruta&#8482; is a rule-based script language supported by Eclipse-based tooling.
The language is designed to enable rapid development of text processing applications within Apache UIMA&#8482;.  A special focus lies on the intuitive and flexible domain specific language for defining  patterns of annotations.
Writing rules for information extraction or other text processing  applications is a tedious process.
The Eclipse-based tooling for UIMA Ruta, called the Apache UIMA Ruta Workbench, was created to support the user and to facilitate every step when writing UIMA Ruta rules.
Both the  Ruta rule language and the UIMA Ruta Workbench integrate smoothly with Apache UIMA.</p>
</div>
</div>
<div class="sect2">
<h3 id="_ugr.tools.ruta.overview.gettingstarted"><a class="anchor" href="#_ugr.tools.ruta.overview.gettingstarted"></a>1.2. Getting started</h3>
<div class="paragraph">
<p>This section gives a short roadmap how to read the documentation and gives some recommendations how to  start developing UIMA Ruta-based applications.
This documentation assumes that the reader knows about  the core concepts of Apache UIMA.
Knowledge of the meaning and usage of the terms &#8220;CAS&#8221;, &#8220;Feature Structure&#8221;, &#8220;Annotation&#8221;, &#8220;Type&#8221;, &#8220;Type System&#8221;  and &#8220;Analysis Engine&#8221; is required.
Please refer to the documentation of Apache UIMA for an introduction.</p>
</div>
<div class="paragraph">
<p>Unexperienced users that want to learn about UIMA Ruta can start with the next two sections: <a href="#_ugr.tools.ruta.overview.coreconcepts">Section 1.3</a> gives a short overview of the core ideas and features of the UIMA Ruta language and Workbench.
This section introduces the main concepts of the UIMA Ruta language.
It explains how UIMA Ruta rules  are composed and applied, and discusses the advantages of the UIMA Ruta system.
The following <a href="#_ugr.tools.ruta.overview.examples">Section 1.4</a> approaches the UIMA Ruta language using a different perspective.
Here, the language is introduced by examples.
The first example starts with explaining how a simple rule looks like, and each following example extends the syntax or semantics of the UIMA Ruta language.
After the consultation of these two sections, the reader is expected to have gained enough  knowledge to start writing her first UIMA Ruta-based application.</p>
</div>
<div class="paragraph">
<p>The UIMA Ruta Workbench was created to support the user and to facilitate the development process.
It is strongly recommended to  use this Eclipse-based IDE since it, for example, automatically configures the component descriptors and provides editing support like syntax checking. <a href="#_section.ugr.tools.ruta.workbench.install">Section 3.1</a> describes how the UIMA Ruta Workbench is installed.
UIMA Ruta rules can also be applied on CAS without using the UIMA Ruta Workbench. <a href="#_ugr.tools.ruta.ae.basic.apply">Section 4.1</a> contains examples how to execute UIMA Ruta rules in plain java.
A good way to get started with UIMA Ruta is to play around with an exemplary UIMA Ruta project, e.g., &#8220;ExampleProject&#8221; in the example-projects of the UIMA Ruta source release.
This UIMA Ruta project contains some simple rules for processing citation metadata.</p>
</div>
<div class="paragraph">
<p><a href="#_ugr.tools.ruta.language.language">Chapter 2</a> and <a href="#_ugr.tools.ruta.workbench">Chapter 3</a> provide  more detailed descriptions and can be referred to in order to gain knowledge of specific parts  of the UIMA Ruta language or the UIMA Ruta Workbench.</p>
</div>
</div>
<div class="sect2">
<h3 id="_ugr.tools.ruta.overview.coreconcepts"><a class="anchor" href="#_ugr.tools.ruta.overview.coreconcepts"></a>1.3. Core Concepts</h3>
<div class="paragraph">
<p>The UIMA Ruta language is an imperative rule language extended with scripting elements.
A UIMA Ruta rule defines a pattern of annotations with additional conditions.
If this pattern applies, then the actions of the rule are performed  on the matched annotations.
A rule is composed of a sequence of rule elements and a rule element essentially consist of four parts:  A matching condition, an optional quantifier, a list of conditions and a list of actions.
The matching condition is typically a type of an annotation by which the rule element matches on the covered text of one of those annotations.
The quantifier specifies, whether it is necessary that the rule element successfully matches and how often the rule element may match.
The list of conditions specifies additional constraints that the matched text or annotations need to fulfill.
The list of actions defines the consequences of the rule and often creates new annotations or modifies existing annotations.
They are only applied if all rule elements of the rule have successfully matched.
Examples for UIMA Ruta rules can be found in <a href="#_ugr.tools.ruta.overview.examples">Section 1.4</a>.</p>
</div>
<div class="paragraph">
<p>When UIMA Ruta rules are applied on a document, respectively on a CAS, then they are always grouped in a script file.
However, a UIMA Ruta script file does not only contain rules, but also other statements.
First of all, each script file starts with a package declaration followed by a list of optional imports.
Then, common statements like rules, type declarations or blocks build the body and functionality of a script. <a href="#_ugr.tools.ruta.ae.basic.apply">Section 4.1</a> gives an example, how UIMA Ruta scripts can be applied in plain Java.
UIMA Ruta script files are naturally organized in UIMA Ruta projects, which is a concept of the UIMA Ruta Workbench.
The structure of a UIMA Ruta project is described in <a href="#_section.ugr.tools.ruta.workbench.projects">Section 3.3</a></p>
</div>
<div class="paragraph">
<p>The inference of UIMA Ruta rules, that is the approach how the rules are applied, can be described as imperative depth-first matching.
In contrast to similar rule-based systems, UIMA Ruta rules are applied in the order they are defined in the script.
The imperative execution of the matching rules may have disadvantages, but also many advantages like an increased rate of development or  an easier explanation.
The second main property of the UIMA Ruta inference is the depth-first matching.
When a rule matches on a pattern of annotations, then an alternative is always tracked until it has matched or failed before the next alternative is considered.
The behavior of a rule may change, if  it has already matched on an early alternative and thus has performed an action, which influences some constraints of the rule.
Examples, how UIMA Ruta rules are applied, are given in <a href="#_ugr.tools.ruta.overview.examples">Section 1.4</a>.</p>
</div>
<div class="paragraph">
<p>The UIMA Ruta language provides the possibility to approach an annotation problem in different ways.
Let us distinguish  some approaches as an example.
It is common in the UIMA Ruta language to create many annotations of different types.
These annotations are probably not the targeted annotation of the domain, but can be helpful to incrementally approximate the annotation of interest.
This enables the user to work &#8220;bottom-up&#8221; and &#8220;top-down&#8221;.
In the former approach, the rules add incrementally more complex annotations using simple ones until the target annotation can be created.
In the latter approach, the rules get more specific while partitioning the document in smaller segments, which result in the targeted annotation, eventually.
By using many &#8220;helper&#8221;-annotations, the engineering task becomes easier and more comprehensive.
The UIMA Ruta language provides distinctive language elements for different tasks.
There are, for example, actions  that are able to create new annotations, actions that are able to remove annotations and actions that are able to modify the offsets of annotations.
This enables, amongst other things, a transformation-based approach.
The user starts by creating general rules that are able to annotate most of the text fragments of interest.
Then, instead of making these rules more complex by adding more conditions for situations where they fail, additional rules are defined that correct the mistakes of the general rules, e.g., by deleting false positive annotations. <a href="#_ugr.tools.ruta.overview.examples">Section 1.4</a> provides some examples how UIMA Ruta rules can be engineered.</p>
</div>
<div class="paragraph">
<p>To write rules manually is a tedious and error-prone process.
The <a href="#_ugr.tools.ruta.workbench">UIMA Ruta Workbench</a> was developed to facilitate writing rules by providing as much tooling support as possible.
This includes, for example, syntax checking and auto completion, which make the development less error-prone.
The user can annotate documents and use these documents as unit tests for test-driven development or  quality maintenance.
Sometimes, it is necessary to debug the rules because they do not match as expected.
In this case, the explanation perspective provides views that explain every detail of the matching process.
Finally, the UIMA Ruta language can also be used by the tooling, for example, by the &#8220;Query&#8221; view.
Here, UIMA Ruta rules can be used as query statements in order to investigate annotated documents.</p>
</div>
<div class="paragraph">
<p>UIMA Ruta smoothly integrates with Apache UIMA.
First of all, the UIMA Ruta rules are applied using a generic Analysis Engine and thus UIMA Ruta scripts can  easily be added to Apache UIMA pipelines.
UIMA Ruta also provides the functionality to import and use other UIMA components like Analysis Engines and Type Systems.
UIMA Ruta rules can refer to every type defined in an imported type system, and the UIMA Ruta Workbench generates a type system descriptor file containing all  types that were defined in a script file.
Any Analysis Engine can be executed by rules as long as their implementation is available in the classpath.
Therefore, functionality outsourced in an arbitrary Analysis Engine can be added and used within UIMA Ruta.</p>
</div>
</div>
<div class="sect2">
<h3 id="_ugr.tools.ruta.overview.examples"><a class="anchor" href="#_ugr.tools.ruta.overview.examples"></a>1.4. Learning by Example</h3>
<div class="paragraph">
<p>This section gives an introduction to the UIMA Ruta language by explaining the rule syntax  and inference with some simplified examples.
It is recommended to use the UIMA Ruta Workbench to write UIMA Ruta rules in order to gain advantages like syntax checking.
A short description how to install the UIMA Ruta Workbench  is given <a href="#_section.ugr.tools.ruta.workbench.install">here</a>.
The following examples make use of the  annotations added by the default seeding of the UIMA Ruta Analysis Engine.
Their meaning is explained along with the examples.</p>
</div>
<div class="paragraph">
<p>The first example consists of a declaration of a type followed by a simple rule.
Type declarations always start with the keyword &#8220;DECLARE&#8221; followed by the short name of the new type.
The namespace of the type is equal to the package declaration of the script file.
If there is no package declaration, then the types declared in the script file have no namespace.
There is also the possibility to create more complex types with features or specific parent types, but this will be neglected for now.
In the example, a simple annotation type with the short name &#8220;Animal&#8221; is defined.
After the declaration of the type, a rule with one rule element is given.
UIMA Ruta rules in general can consist of a sequence of rule elements.
Simple rule elements themselves consist of four parts: A matching condition, an optional quantifier, an optional list of conditions and an optional list of actions.
The rule element in the  following example has a matching condition &#8220;W&#8221;, an annotation type standing for normal words.
Statements like declarations and rules always end with a semicolon.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>DECLARE Animal;
W{REGEXP("dog") -&gt; MARK(Animal)};</code></pre>
</div>
</div>
<div class="paragraph">
<p>The rule element also contains one condition and one action, both surrounded by curly parentheses.
In order to distinguish conditions from actions they are separated by &#8220;&#8594;&#8221;.
The condition &#8220;REGEXP("dog")&#8221; indicates that the matched  word must match the regular expression &#8220;dog&#8221;.
If the matching condition and the additional regular expression are fulfilled, then the action is executed, which creates a new annotation of the type &#8220;Animal&#8221; with the same offsets as the matched token.
The default seeder does actually not add annotations of the type &#8220;W&#8221;, but annotations of the types &#8220;SW&#8221; and &#8220;CW&#8221; for small written words and capitalized words, which both have the parent type &#8220;W&#8221;.</p>
</div>
<div class="paragraph">
<p>There is also the possibility to add implicit actions and conditions, which have no explicit name, but consist only of an expression.
In the part of the conditions, boolean expressions and feature match expression can be applied, and in the part of the actions, type expressions and feature assignment expression can be added.
The following example contains one implicit condition and one implicit action.
The additional condition is a boolean expression (boolean variable), which is set to &#8220;true&#8221;, and therefore is always fulfills the condition.
The &#8220;MARK&#8221; action was replaced by a type expression, which refer to the type &#8220;Animal&#8221;.
The following rule shows, therefore, the same behavior as the rule in the last example.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>DECLARE Animal;
BOOLEAN active = true;
W{REGEXP("dog"), active -&gt; Animal};</code></pre>
</div>
</div>
<div class="paragraph">
<p>There is also a special kind of rules, which follow a different syntax and semantic, and enables a simplified creation of annotations based on regular expression.
The following rule, for example, creates an &#8220;Animal&#8221; annotation for each occurrence of &#8220;dog&#8221; or &#8220;cat&#8221;.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>DECLARE Animal;
"dog|cat" -&gt; Animal;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Since it is tedious to create Animal annotations by matching on different regular expression, we apply an external dictionary in the next example.
The first line defines a word list named &#8220;AnimalsList&#8221;, which is located in the resource folder (the file &#8220;Animals.txt&#8221;  contains one animal name in each line). After the declaration of the type, a rule uses this word list to find all occurrences of animals in the complete document.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>WORDLIST AnimalsList = 'Animals.txt';
DECLARE Animal;
Document{-&gt; MARKFAST(Animal, AnimalsList)};</code></pre>
</div>
</div>
<div class="paragraph">
<p>The matching condition of the rule element refers to the complete document, or more specific to the annotation of the type &#8220;DocumentAnnotation&#8221;, which covers the whole document.
The action &#8220;MARKFAST&#8221; of this rule element creates an annotation of the type &#8220;Animal&#8221; for each found entry of the dictionary &#8220;AnimalsList&#8221;.</p>
</div>
<div class="paragraph">
<p>The next example introduces rules with more than one rule element, whereby one of them is a composed rule element.
The following rule tries to annotate occurrences of animals separated by commas, e.g., &#8220;dog, cat, bird&#8221;.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>DECLARE AnimalEnum;
(Animal COMMA)+{-&gt; MARK(AnimalEnum,1,2)} Animal;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The rule consists of two rule elements, with &#8220;(Animal COMMA)+{&#8594; MARK(AnimalEnum,1,2)}&#8221; being the first rule element and &#8220;Animal&#8221; the second one.
Let us take a closer look at the first rule element.
This rule element is actually composed of two normal rule elements,  that are &#8220;Animal&#8221; and &#8220;COMMA&#8221;, and contains a greedy quantifier and one action.
This rule element, therefore, matches on  one Animal annotation and a following comma.
This is repeated until one of the inner rule elements does not match anymore.
Then, there has to be another Animal annotation afterwards, specified by the second rule element of the rule.
In this case, the rule matches and its action is executed: The MARK action creates a new annotation of the type &#8220;AnimalEnum&#8221;.
However, in contrast to the previous examples, this action also contains two numbers.
These numbers refer to the rule elements that should be used to calculate the span of the created annotation.
The numbers &#8220;1, 2&#8221; state that the new annotation should start with the first rule element, the composed one, and should end with the second rule element.</p>
</div>
<div class="paragraph">
<p>Let us make the composed rule element more complex.
The following rule also matches on lists of animals, which are separated by semicolon.
A disjunctive rule element is therefore added, indicated by the symbol &#8220;|&#8221;, which matches on annotations of the type &#8220;COMMA&#8221; or &#8220;SEMICOLON&#8221;.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>(Animal (COMMA | SEMICOLON))+{-&gt; MARK(AnimalEnum,1,2)} Animal;</code></pre>
</div>
</div>
<div class="paragraph">
<p>There two more special symbols that can be used to link rule elements.
If the symbol &#8220;|&#8221; is replaced by the symbol <code>&amp;</code> in the last example, then the token after the animal need to be a comma and a semicolon, which is of course not possible.
Another symbol with a special meaning is &#8220;%&#8221;, which cannot only be used within a composed rule element (parentheses). This symbol can be interpreted as a global &#8220;and&#8221;: It links several rules, which only fire, if all rules have successfully matched.
In the following example, an annotation of the type &#8220;FoundIt&#8221; is created, if the document contains two periods in a row and two commas in a row:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>PERIOD PERIOD % COMMA COMMA{-&gt; FoundIt};</code></pre>
</div>
</div>
<div class="paragraph">
<p>There is a &#8220;wild card&#8221; (&#8220;#&#8221;) rule element, which can be used to skip some text or annotations until the next rule element is able to match.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>DECLARE Sentence;
PERIOD #{-&gt; MARK(Sentence)} PERIOD;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This rule annotates everything between two &#8220;PERIOD&#8221; annotations with the type &#8220;Sentence&#8221;.
Please note that the resulting  annotations is automatically trimmed using the current filtering settings.
Conditions at wild card rule elements should by avoided and only be used  by advanced users.</p>
</div>
<div class="paragraph">
<p>Another special rule element is called &#8220;optional&#8221; (&#8220;_&#8221;). Sometimes, an annotation should be created on a  text position if it is not followed by an annotation of a specific property.
In contrast to normal rule elements with optional quantifier, the optional rule element does not need to match at all.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>W ANY{-PARTOF(NUM)};
W _{-PARTOF(NUM)};</code></pre>
</div>
</div>
<div class="paragraph">
<p>The two rules in this example specify the same pattern: A word that is not followed by a number.
The difference between the rules  shows itself at the border of the matching window, e.g., at the end of the document.
If the document contains only a single word,  the first rule will not match successfully because the second rule element already fails at its matching condition.
The second rule, however, will successfully match due to the optional rule element.</p>
</div>
<div class="paragraph">
<p>Rule elements can contain more then one condition.
The rule in the next example tries to identify headlines, which are bold,  underlined and end with a colon.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>DECLARE Headline;
Paragraph{CONTAINS(Bold, 90, 100, true),
    CONTAINS(Underlined, 90, 100, true), ENDSWITH(COLON)
    -&gt; MARK(Headline)};</code></pre>
</div>
</div>
<div class="paragraph">
<p>The matching condition of this rule element is given with the type &#8220;Paragraph&#8221;, thus the rule takes a look at all Paragraph annotations.
The rule matches only if the three conditions, separated by commas, are fulfilled.
The first condition &#8220;CONTAINS(Bold, 90, 100, true)&#8221; states that 90%-100% of the matched paragraph annotation should also be annotated with annotations of the type &#8220;Bold&#8221;.
The boolean parameter &#8220;true&#8221; indicates that amount of Bold annotations should be calculated relatively to the matched annotation.
The two numbers &#8220;90,100&#8221; are, therefore, interpreted as percent amounts.
The exact calculation of the coverage is dependent on the tokenization of the document and is neglected for now.
The second condition &#8220;CONTAINS(Underlined, 90, 100, true)&#8221; consequently states that the paragraph should also contain at least 90% of annotations of the type &#8220;underlined&#8221;.
The third condition &#8220;ENDSWITH(COLON)&#8221; finally forces the Paragraph annotation to end with a colon.
It is only fulfilled, if there is an annotation of the type &#8220;COLON&#8221;, which has an end offset equal to the end offset of the matched Paragraph annotation.</p>
</div>
<div class="paragraph">
<p>The readability and maintenance of rules does not increase, if more conditions are added.
One of the strengths of the UIMA Ruta language is that it provides different approaches to solve an annotation task.
The next two examples  introduce actions for transformation-based rules.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>Headline{-CONTAINS(W) -&gt; UNMARK(Headline)};</code></pre>
</div>
</div>
<div class="paragraph">
<p>This rule consists of one condition and one action.
The condition &#8220;-CONTAINS(W)&#8221; is negated (indicated by the character &#8220;-&#8221;),  and is therefore only fulfilled, if there are no annotations of the type &#8220;W&#8221; within the bound of the matched Headline annotation.
The action &#8220;UNMARK(Headline)&#8221; removes the matched Headline annotation.
Put into simple words, headlines that contain no words at all are not headlines.</p>
</div>
<div class="paragraph">
<p>The next rule does not remove an annotation, but changes its offsets dependent on the context.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>Headline{-&gt; SHIFT(Headline, 1, 2)} COLON;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here, the action &#8220;SHIFT(Headline, 1, 2)&#8221; expands the matched Headline annotation to the next colon, if that Headline annotation is followed by a COLON annotation.</p>
</div>
<div class="paragraph">
<p>UIMA Ruta rules can contain arbitrary conditions and actions, which is illustrated by the next example.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>DECLARE Month, Year, Date;
ANY{INLIST(MonthsList) -&gt; MARK(Month), MARK(Date,1,3)}
    PERIOD? NUM{REGEXP(".{2,4}") -&gt; MARK(Year)};</code></pre>
</div>
</div>
<div class="paragraph">
<p>This rule consists of three rule elements.
The first one matches on every token, which has a covered text that occurs in a word lists named &#8220;MonthsList&#8221;.
The second rule element is optional and does not need to be fulfilled, which is indicated by the quantifier &#8220;?&#8221;.
The last rule element matches on numbers that fulfill the regular expression &#8220;REGEXP(".{2,4}"&#8221; and are therefore at least two characters to a maximum of four characters long.
If this rule successfully matches on a text passage, then its three actions are executed: An annotation of the type &#8220;Month&#8221; is created for the first rule element, an annotation of the type &#8220;Year&#8221; is created for the last rule element and an annotation of the type &#8220;Date&#8221;  is created for the span of all three rule elements.
If the word list contains the correct entries, then this rule matches on strings like &#8220;Dec. 2004&#8221;, &#8220;July 85&#8221; or &#8220;11.2008&#8221; and creates the corresponding annotations.</p>
</div>
<div class="paragraph">
<p>After introducing the composition of rule elements, the default matching strategy is examined.
The two rules in the next example create an annotation for a sequence of arbitrary tokens with the only difference of one condition.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>DECLARE Text1, Text2;
ANY+{ -&gt; MARK(Text1)};
ANY+{-PARTOF(Text2) -&gt; MARK(Text2)};</code></pre>
</div>
</div>
<div class="paragraph">
<p>The first rule matches on each occurrence of an arbitrary token and continues this until the end of the document is reached.
This is caused by the greedy quantifier &#8220;+&#8221;.
Note that this rule considers each occurrence of a token and is therefore executed for each token resulting many overlapping annotations.
This behavior is illustrated with an example: When applied on the document &#8220;Peter works for Frank&#8221;, the rule creates four annotations with the covered texts &#8220;Peter works for Frank&#8221;, &#8220;works for Frank&#8221;, &#8220;for Frank&#8221; and &#8220;Frank&#8221;.
The rule first tries to match on the token &#8220;Peter&#8221; and continues its matching.
Then, it tries to match on the token &#8220;works&#8221; and continues its matching, and so on.</p>
</div>
<div class="paragraph">
<p>In this example, the second rule only returns one annotation, which covers the complete document.
This is caused by the additional condition &#8220;-PARTOF(Text2)&#8221;.
The PARTOF condition is fulfilled, if the matched annotation is located within an annotation of the given type, or put in simple words, if the matched annotation is part of an annotation of the type &#8220;Text2&#8221;.
When applied on the  document &#8220;Peter works for Frank&#8221;, the rule matches on the first token &#8220;Peter&#8221;, continues its match and  creates an annotation of the type &#8220;Text2&#8221; for the complete document.
Then it tries to match on the second token &#8220;works&#8221;, but fails,  because this token is already part of an Text2 annotation.</p>
</div>
<div class="paragraph">
<p>UIMA Ruta rules can not only be used to create or modify annotations, but also to create features for annotations.
The next example defines  and assigns a relation of employment, by storing the given annotations as feature values.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>DECLARE Annotation EmplRelation
    (Employee employeeRef, Employer employerRef);
Sentence{CONTAINS(EmploymentIndicator) -&gt; CREATE(EmplRelation,
    "employeeRef" = Employee, "employerRef" = Employer)};</code></pre>
</div>
</div>
<div class="paragraph">
<p>The first statement of this example is a declaration that defines a new type of annotation named &#8220;EmplRelation&#8221;.
This annotation has two features:  One feature with the name &#8220;employeeRef&#8221; of the type &#8220;Employee&#8221; and  one feature with the name &#8220;employerRef&#8221; of the type &#8220;Employer&#8221;.
If the parent type is Annotation, then it can be omitted resulting in the following declaration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>DECLARE EmplRelation (Employee employeeRef, Employer employerRef);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The second statement of the example, which is a simple rule, creates one annotation of the type &#8220;EmplRelation&#8221; for each Sentence annotation that contains at least one annotation of the type &#8220;EmploymentIndicator&#8221;.
Additionally to creating an annotation, the CREATE action also assigns an annotation of the &#8220;Employee&#8221;, which needs to be located within the span of the matched sentence,  to the feature &#8220;employeeRef&#8221; and an Employer annotation to the feature &#8220;employerRef&#8221;.
The annotations mentioned in this  example need to be present in advance.</p>
</div>
<div class="paragraph">
<p>In order to refer to annotations and, for example, assigning them to some features,  special kinds of local and global variables can be utilized.
Local variables for annotations  do not need to be defined by are specified by a label at a rule element.
This label can be utilized for referring to the matched annotation of this rule element within the current rule match alone.
The following example illustrate some simple use cases using local variables:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>DECLARE Annotation EmplRelation
   (Employee employeeRef, Employer employerRef);
e1:Employer # EmploymentIndicator # e2:Employee)
    {-&gt; EmplRelation, EmplRelation.employeeRef=e2,
        EmplRelation.employerRef=e1};</code></pre>
</div>
</div>
<div class="paragraph">
<p>Global variables for annotations are declared like other variables and are able to store annotations across rules as illustrated by the next example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>DECLARE MentionedAfter(Annotation first);
ANNOTATION firstPerson;
# p:Person{-&gt; firstPerson = p};
Entity{-&gt; MentionedAfter, MentionedAfter.first = firstPerson};</code></pre>
</div>
</div>
<div class="paragraph">
<p>The first line declares a new type that are utilized afterwards.
The second line defines a variable  named <code>firstPerson</code> which can store one annotation.
A variable able to hold several annotations  is defined with ANNOTATIONLIST.
The next line assigns the first occurrence of Person annotation to the annotation variable <code>firstPerson</code>.
The last line creates an annotation of the type MentionedAfter and assigns the value  of the variable <code>firstPerson</code> to the feature <code>first</code> of the created annotation.</p>
</div>
<div class="paragraph">
<p>Expressions for annotations can be extended by a feature match and also conditions.
This does also apply for type expressions that represent annotations.
This functionality is illustrated with a simple example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>Sentence{-&gt; CREATE(EmplRelation, "employeeRef" =
    Employee.ct=="Peter"{ENDSWITH(Sentence)})};</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here, an annotation of the type <code>EmplRelation</code> is created for each sentence.
The feature <code>employeeRef</code> is filled with one <code>Employee</code> annotation.
This annotation is specified by its type <code>Employee</code>.
The first annotation of this type within the matched sentence, which covers the text &#8220;Peter&#8221; and also ends with a <code>Sentence</code> annotation, is selected.</p>
</div>
<div class="paragraph">
<p>Sometimes, an annotation which was just created by an action should be assigned to a feature.
This can be achieved by referring to the annotation given its type like it was shown in the  first example with &#8220;EmplRelation&#8221;.
However, this can cause problems in situations, e.g.
where several annotation of a type are present at a specific span.
Local variables using labels can also be used directly at actions,  which create or modify actions.
The action will assign the new annotation the the label variable,  which can then be utilized by following actions as shown in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>W.ct=="Peter"{-&gt; e:Employee, CREATE(EmplRelation, "employeeRef" = e)};</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the last examples, the values of features were defined as annotation types.
However, also primitive  types can be used, as will be shown in the next example, together with a short introduction of variables.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>DECLARE Annotation MoneyAmount(STRING currency, INT amount);
INT moneyAmount;
STRING moneyCurrency;
NUM{PARSE(moneyAmount)} SPECIAL{REGEXP("€") -&gt; MATCHEDTEXT(moneyCurrency),
    CREATE(MoneyAmount, 1, 2, "amount" = moneyAmount,
        "currency" = moneyCurrency)};</code></pre>
</div>
</div>
<div class="paragraph">
<p>First, a new annotation with the name &#8220;MoneyAmount&#8221; and two features are defined, one string feature and one integer feature.
Then, two UIMA Ruta variables are declared, one integer variable and one string variable.
The rule matches on a number, whose value is stored  in the variable &#8220;moneyAmount&#8221;, followed by a special token that needs to be equal to the string &#8220;€&#8221;.
Then, the covered text of the special annotation is stored in the string variable &#8220;moneyCurrency&#8221; and annotation of the type &#8220;MoneyAmount&#8221; spanning over both rule elements is created.
Additionally, the variables are assigned as feature values.</p>
</div>
<div class="paragraph">
<p>Using feature expression for conditions and action, can reduce the complexity of a rule.
The first rule in the following example set the value of the feature &#8220;currency&#8221; of the annotation of the type &#8220;MoneyAmount&#8221; to &#8220;Euro&#8221;, if it was &#8220;€&#8221; before.
The second rule creates an annotation of the type &#8220;LessThan&#8221; for all annotations of the type &#8220;MoneyAmount&#8221;,  if their amount is less than 100 and the currency is &#8220;Euro&#8221;.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>DECLARE LessThan;
MoneyAmount.currency=="€"{-&gt; MoneyAmount.currency="Euro"};
MoneyAmount{(MoneyAmount.amount&lt;=100),
    MoneyAmount.currency=="Euro" -&gt; LessThan};</code></pre>
</div>
</div>
<div class="paragraph">
<p>UIMA Ruta script files with many rules can quickly confuse the reader.
The UIMA Ruta language, therefore, allows to import other script files in order to increase the modularity of a project or to create rule libraries.
The next example imports the rules together with all known types of another script file  and executes that script file.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>SCRIPT uima.ruta.example.SecondaryScript;
Document{-&gt; CALL(SecondaryScript)};</code></pre>
</div>
</div>
<div class="paragraph">
<p>The script file with the name &#8220;SecondaryScript.ruta&#8221;, which is located in the package &#8220;uima/ruta/example&#8221;, is imported and executed by the CALL action on the complete document.
The script needs to be located in the folder specified by the parameter <a href="#_ugr.tools.ruta.ae.basic.parameter.scriptpaths">scriptPaths</a>, or in a corresponding package in the classpath.
It is also possible to import script files of other UIMA Ruta projects, e.g., by adapting the configuration parameters of the UIMA Ruta Analysis Engine or  by setting a project reference in the project properties of a UIMA Ruta project.</p>
</div>
<div class="paragraph">
<p>For simple rules that match on the complete document and only specify actions, a simplified syntax exists that omits the matching parts:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>SCRIPT uima.ruta.example.SecondaryScript;
CALL(SecondaryScript);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The types of important annotations of the application are often defined in a separate type system.
The next example shows how to import those types.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>TYPESYSTEM my.package.NamedEntityTypeSystem;
Person{PARTOF(Organization) -&gt; UNMARK(Person)};</code></pre>
</div>
</div>
<div class="paragraph">
<p>The type system descriptor file with the name &#8220;NamedEntityTypeSystem.xml&#8221; located in the package &#8220;my/package&#8221; is imported.
The descriptor needs to be located in a folder specified by the parameter <a href="#_ugr.tools.ruta.ae.basic.parameter.descriptorpaths">descriptorPaths</a>.</p>
</div>
<div class="paragraph">
<p>It is sometimes easier to express functionality with control structures known by programming languages rather than to engineer all functionality  only with matching rules.
The UIMA Ruta language provides the BLOCK element for some of these use cases.
The UIMA Ruta BLOCK element starts with the keyword &#8220;BLOCK&#8221; followed by its name in parentheses.
The name of a block has two purposes: On the one hand, it is easier to distinguish the block, if they have different names, e.g., in the <a href="#_section.ugr.tools.ruta.workbench.explain_perspective">explain perspective</a> of the UIMA Ruta Workbench.
On the other hand, the name can be used to execute this block using the CALL action.
Hereby, it is possible to access only specific sets of rules of other script files,  or to implement a recursive call of rules.
After the name of the block, a single rule element is given, which has curly parentheses,  even if no conditions or actions are specified.
Then, the body of the block is framed by curly brackets.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>BLOCK(English) Document{FEATURE("language", "en")} {
    // rules for english documents
}
BLOCK(German) Document{FEATURE("language", "de")} {
    // rules for german documents
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This example contains two simple BLOCK statements.
The rules defined within the block are only executed, if the condition in the head of the block is fulfilled.
The rules of the first block are only considered if the feature &#8220;language&#8221; of the document annotation has the value &#8220;en&#8221;.
Following this, the rules of the second block are only considered for German documents.</p>
</div>
<div class="paragraph">
<p>The rule element of the block definition can also refer to other annotation types than &#8220;Document&#8221;.
While the last example implemented something similar  to an if-statement, the next example provides a show case for something similar to a for-each-statement.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>DECLARE SentenceWithNoLeadingNP;
BLOCK(ForEach) Sentence{} {
    Document{-STARTSWITH(NP) -&gt; MARK(SentenceWithNoLeadingNP)};
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here, the rule in the block statement is performed for each occurrence of an annotation of the type &#8220;Sentence&#8221;.
The rule within the block matches on the complete document, which is the current sentence in the context of the block statement.
As a consequence, this example creates an annotation of the type &#8220;SentenceWithNoLeadingNP&#8221; for each sentence  that does not start with a NP annotation.</p>
</div>
<div class="paragraph">
<p>There are two more language constructs (<code>-&gt;</code> and <code>&lt;-</code>) that allow to apply rules within a certain context.
These rules are added to an arbitrary rule element  and are called inlined rules.
The first example interprets the inlined rules as actions.
They are executed if the surrounding rule was able to match,  which makes this one very similar to the block statement.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>DECLARE SentenceWithNoLeadingNP;
Sentence{}-&gt;{
    Document{-STARTSWITH(NP) -&gt; SentenceWithNoLeadingNP};
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>The second one (&lt;-`) interprets the inlined rules as conditions.
The surrounding rule can only match if at least one inlined rule was successfully applied.
In the following example, a sentence is annotated with the type SentenceWithNPNP, if there are two successive NP annotations within this sentence.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>DECLARE SentenceWithNPNP;
Sentence{-&gt; SentenceWithNPNP}&lt;-{
    NP NP;
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>A rule element may be extended with several inlined rule block as condition or action.
If there a more than one inlined rule blocks as condition,  each needs to contain at least one rule that was successfully applied.
In the following example, the rule will one match if the sentence contains  a number followed by a another number and a period followed by a comma, independently from their location within the sentence:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>Sentence&lt;-{NUM NUM;}&lt;-{PERIOD COMMA;};</code></pre>
</div>
</div>
<div class="paragraph">
<p>Let us take a closer look on what exactly the UIMA Ruta rules match.
The following rule matches on a word followed by another word:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>W W;</code></pre>
</div>
</div>
<div class="paragraph">
<p>To be more precise, this rule matches on all documents like <code>Apache UIMA</code>, <code>ApacheUIMA</code>, <code>Apache &lt;b&gt;UIMA&lt;/b&gt;`</code>.
There are two main reasons for this: First of all, it depends on how the available annotations are defined.
The default seeder for the initial annotations creates an annotation for all characters until an upper case character occurs.
Thus, the string &#8220;ApacheUIMA&#8221; consists of  two tokens.
However, more important, the UIMA Ruta language provides a concept of visibility of the annotations.
By default, all annotations of the types &#8220;SPACE&#8221;, &#8220;NBSP&#8221;, &#8220;BREAK&#8221; and &#8220;MARKUP&#8221; (whitespace and XML elements) are filtered and not visible.
This holds of course for their covered text, too.
The rule elements skip all positions of the document where those annotations occur.
The rule in the last example matches on all examples.
Without the default filtering settings,  with all annotations set to visible, the rule matches only on the document &#8220;ApacheUIMA&#8221; since it is the only one that contains two word annotations without any whitespace between them.</p>
</div>
<div class="paragraph">
<p>The filtering setting can also be modified by the UIMA Ruta rules themselves.
The next example provides rules that extend and limit  the amount of visible text of the document.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>Sentence;
Document{-&gt; RETAINTYPE(SPACE)};
Sentence;
Document{-&gt; FILTERTYPE(CW)};
Sentence;
Document{-&gt; RETAINTYPE, FILTERTYPE};</code></pre>
</div>
</div>
<div class="paragraph">
<p>The first rule matches on sentences, which do not start with any filtered type.
Sentences that start with whitespace or markup,  for example, are not considered.
The next rule retains all text that is covered by annotations of the type &#8220;SPACE&#8221; meaning  that the rule elements are now sensible to whitespaces.
The following rule will, therefore, match on sentences that start with whitespaces.
The third rule now filters the type &#8220;CW&#8221; with the consequence that all capitalized words are invisible.
If the following rule now wants to match on sentences, then this is only possible for Sentence annotations that do not start with a capitalized word.
The last rule finally resets the filtering setting to the default configuration in the UIMA Ruta Analysis Engine.</p>
</div>
<div class="paragraph">
<p>The next example gives a showcase for importing external Analysis Engines and for modifying the documents by creating a new view called &#8220;modified&#8221;.
Additional Analysis Engines can be imported with the keyword &#8220;ENGINE&#8221; followed by the name of the descriptor.
These imported Analysis Engines can be  executed with the actions &#8220;CALL&#8221; or &#8220;EXEC&#8221;.
If the executed Analysis Engine adds, removes or modifies annotations, then their types need  to be mentioned when calling the descriptor, or else these annotations will not be correctly processed by the following UIMA Ruta rules.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>ENGINE utils.Modifier;
Date{-&gt; DEL};
MoneyAmount{-&gt; REPLACE("&lt;MoneyAmount/&gt;")};
Document{-&gt; COLOR(Headline, "green")};
Document{-&gt; EXEC(Modifier)};</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this example, we first import an Analysis Engine defined by the descriptor &#8220;Modifier.xml&#8221; located in the folder &#8220;utils&#8221;.
The descriptor needs to be located in the folder specified by the parameter <a href="#_ugr.tools.ruta.ae.basic.parameter.descriptorpaths">descriptorPaths</a>.
The first rule deletes all text covered by annotations of the type &#8220;Date&#8221;.
The second rule replaces the text of all annotations of the type &#8220;MoneyAmount&#8221;  with the string <code>&lt;MoneyAmount/&gt;</code>.
The third rule remembers to set the background color of text in Headline annotation to green.
The last rule finally performs all of these changes in an additional view called &#8220;modified&#8221;, which is specified in the configuration parameters of the analysis engine. <a href="#_ugr.tools.ruta.ae.modifier">Section 1.5.4</a> and <a href="#_ugr.tools.ruta.language.modification">Section 2.17</a> provide a more detailed description.</p>
</div>
<div class="paragraph">
<p>In the last example, a descriptor file was loaded in order to import and apply an external analysis engine.
Analysis engines can also be loaded using uimaFIT,  whereas the given class name has to be present in the classpath.
In the UIMA Ruta Workbench, you can add a dependency to a java project, which contains the  implementation, to the UIMA Ruta project.
The following example loads an analysis engine without an descriptor and applies it on the document.
The additional list of types states that the annotations of those types created by the analysis engine should be available to the following Ruta rules.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>UIMAFIT my.package.impl.MyAnalysisEngine;
Document{-&gt; EXEC(MyAnalysisEngine, {MyType1, MyType2})};</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_ugr.tools.ruta.ae"><a class="anchor" href="#_ugr.tools.ruta.ae"></a>1.5. UIMA Analysis Engines</h3>
<div class="paragraph">
<p>This section gives an overview of the UIMA Analysis Engines shipped with UIMA Ruta.
The most  important one is &#8220;RutaEngine&#8221;, a generic analysis engine, which is able to interpret  and execute script files.
The other analysis engines provide support for some additional functionality or add certain types of annotations.</p>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.ae.basic"><a class="anchor" href="#_ugr.tools.ruta.ae.basic"></a>1.5.1. Ruta Engine</h4>
<div class="paragraph">
<p>This generic Analysis Engine is the most important one for the UIMA Ruta language since it is responsible for applying the UIMA Ruta rules on a CAS.
Its functionality is configured by the configuration parameters,  which, for example, specify the rule file that should be executed.
In the UIMA Ruta Workbench, a basic template named &#8220;BasicEngine.xml&#8221; is given in the descriptor folder of a UIMA Ruta project and correctly configured descriptors typically named &#8220;MyScriptEngine.xml&#8221; are generated in the descriptor folder corresponding to the package namespace of the script file.
The available configuration parameters of the UIMA Ruta Analysis Engine are described in the following.</p>
</div>
<div class="sect4">
<h5 id="_ugr.tools.ruta.ae.basic.parameter"><a class="anchor" href="#_ugr.tools.ruta.ae.basic.parameter"></a>Configuration Parameters</h5>
<div class="paragraph">
<p>The configuration parameters of the UIMA Ruta Analysis Engine can be subdivided into three different groups: parameters for the setup of the environment (<a href="#_ugr.tools.ruta.ae.basic.parameter.mainscript">mainScript</a> to <a href="#_ugr.tools.ruta.ae.basic.parameter.additionalextensions">additionalExtensions</a>),  parameters that change the behavior of the analysis engine (<a href="#_ugr.tools.ruta.ae.basic.parameter.reloadscript">reloadScript</a> to <a href="#_ugr.tools.ruta.ae.basic.parameter.simplegreedyforcomposed">simpleGreedyForComposed</a>)  and parameters for creating additional information how the rules were executed  (<a href="#_ugr.tools.ruta.ae.basic.parameter.debug">debug</a> to <a href="#_ugr.tools.ruta.ae.basic.parameter.createdby">createdBy</a>). First, a short overview of the configuration parameters is given in <a href="#_table.ugr.tools.ruta.ae.parameter">Table 1</a>.
Afterwards, all parameters are described in detail with examples.</p>
</div>
<div class="paragraph">
<p>To change the value of any configuration parameter within a UIMA Ruta script, the CONFIGURE action (see <a href="#_ugr.tools.ruta.language.actions.configure">Section 2.8.8</a>) can be used.
For changing behavior of <a href="#_ugr.tools.ruta.ae.basic.parameter.dynamicanchoring">dynamicAnchoring</a> the DYNAMICANCHORING action  (see <a href="#_ugr.tools.ruta.language.actions.dynamicanchoring">Section 2.8.11</a>) is recommended.</p>
</div>
<table id="_table.ugr.tools.ruta.ae.parameter" class="tableblock frame-all grid-all stretch">
<caption class="title">Table 1. Configuration parameters of the UIMA Ruta Analysis Engine</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Name</th>
<th class="tableblock halign-left valign-top">Short description</th>
<th class="tableblock halign-left valign-top">Type</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#_ugr.tools.ruta.ae.basic.parameter.mainscript">mainScript</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Name with complete namespace of the script which will be interpreted and executed by the analysis engine.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Single String</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#_ugr.tools.ruta.ae.basic.parameter.rules">rules</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Script (list of rules) to be applied.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Single String</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#_ugr.tools.ruta.ae.basic.parameter.rules">rulesScriptName</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This parameter specifies the name of the non-existing script if the parameter 'rules' is used.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Single String</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#_ugr.tools.ruta.ae.basic.parameter.scriptencoding">scriptEncoding</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Encoding of all UIMA Ruta script files.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Single String</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#_ugr.tools.ruta.ae.basic.parameter.scriptpaths">scriptPaths</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">List of absolute locations, which contain the necessary script files like the main script.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Multi String</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#_ugr.tools.ruta.ae.basic.parameter.descriptorpaths">descriptorPaths</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">List of absolute locations, which contain the necessary descriptor files like type systems.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Multi String</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#_ugr.tools.ruta.ae.basic.parameter.resourcepaths">resourcePaths</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">List of absolute locations, which contain the necessary resource files like word lists.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Multi String</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#_ugr.tools.ruta.ae.basic.parameter.additionalscripts">additionalScripts</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Optional list of names with complete namespace of additional scripts, which can be referred to.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Multi String</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#_ugr.tools.ruta.ae.basic.parameter.additionalengines">additionalEngines</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Optional list of names with complete namespace of additional analysis engines, which can be called by UIMA Ruta rules.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Multi String</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#_ugr.tools.ruta.ae.basic.parameter.additionaluimafitengines">additionalUimafitEngines</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Optional list of class names with complete namespace of additional uimaFIT analysis engines, which can be called by UIMA Ruta rules.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Multi String</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#_ugr.tools.ruta.ae.basic.parameter.additionalextensions">additionalExtensions</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">List of factory classes for additional extensions of the UIMA Ruta language like proprietary conditions.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Multi String</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#_ugr.tools.ruta.ae.basic.parameter.reloadscript">reloadScript</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Option to initialize the rule script each time the analysis engine processes a CAS.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Single Boolean</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#_ugr.tools.ruta.ae.basic.parameter.seeders">seeders</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">List of class names that provide additional annotations before the rules are executed.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Multi String</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#_ugr.tools.ruta.ae.basic.parameter.defaultfilteredtypes">defaultFilteredTypes</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">List of complete type names of annotations that are invisible by default.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Multi String</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#_ugr.tools.ruta.ae.basic.parameter.removebasics">removeBasics</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Option to remove all inference annotations after execution of the rule script.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Single Boolean</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#_ugr.tools.ruta.ae.basic.parameter.indexonly">indexOnly</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Option to select annotation types that should be indexed internally in ruta.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Multi String</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#_ugr.tools.ruta.ae.basic.parameter.indexskiptypes">indexSkipTypes</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Option to skip annotation types in the internal indexing.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Multi String</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#_ugr.tools.ruta.ae.basic.parameter.indexonlymentionedtypes">indexOnlyMentionedTypes</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Option to index only mentioned types internally in ruta.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Single Boolean</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#_ugr.tools.ruta.ae.basic.parameter.indexadditionally">indexAdditionally</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Option to index types additionally to the mentioned ones internally in ruta.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Multi String</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#_ugr.tools.ruta.ae.basic.parameter.reindexonly">reindexOnly</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Option to select annotation types that should be reindexed internally in ruta.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Multi String</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#_ugr.tools.ruta.ae.basic.parameter.reindexskiptypes">reindexSkipTypes</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Option to skip annotation types in the internal reindexing.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Multi String</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#_ugr.tools.ruta.ae.basic.parameter.reindexonlymentionedtypes">reindexOnlyMentionedTypes</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Option to reindex only mentioned types internally in ruta.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Single Boolean</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#_ugr.tools.ruta.ae.basic.parameter.reindexadditionally">reindexAdditionally</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Option to reindex types additionally to the mentioned ones internally in ruta.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Multi String</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#_ugr.tools.ruta.ae.basic.parameter.indexupdatemode">indexUpdateMode</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Mode how internal indexing should be applied.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Single String</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#_ugr.tools.ruta.ae.basic.parameter.indexupdatemode">validateInternalIndexing</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Option to validate the internal indexing.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Single String</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#_ugr.tools.ruta.ae.basic.parameter.emptyisinvisible">emptyIsInvisible</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Option to define empty text positions as invisible.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Single Boolean</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#_ugr.tools.ruta.ae.basic.parameter.modifydatapath">modifyDataPath</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Option to extend the datapath by the descriptorPaths</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Single Boolean</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#_ugr.tools.ruta.ae.basic.parameter.strictimports">strictImports</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Option to restrict short type names resolution to those in the declared typesystems.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Single Boolean</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#_ugr.tools.ruta.ae.basic.parameter.typeignorepattern">typeIgnorePattern</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Option to ignore types even if they are available in the typesystem/CAS.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Single String</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#_ugr.tools.ruta.ae.basic.parameter.dynamicanchoring">dynamicAnchoring</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Option to allow rule matches to start at any rule element.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Single Boolean</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#_ugr.tools.ruta.ae.basic.parameter.lowmemoryprofile">lowMemoryProfile</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Option to decrease the memory consumption when processing a large CAS.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Single Boolean</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#_ugr.tools.ruta.ae.basic.parameter.simplegreedyforcomposed">simpleGreedyForComposed</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Option to activate a different inferencer for composed rule elements.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Single Boolean</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#_ugr.tools.ruta.ae.basic.parameter.debug">debug</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Option to add debug information to the CAS.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Single Boolean</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#_ugr.tools.ruta.ae.basic.parameter.debugwithmatches">debugWithMatches</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Option to add information about the rule matches to the CAS.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Single Boolean</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#_ugr.tools.ruta.ae.basic.parameter.debugaddtoindexes">debugAddToIndexes</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Option to add all debug information to the indexes.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Single Boolean</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#_ugr.tools.ruta.ae.basic.parameter.debugonlyfor">debugOnlyFor</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">List of rule ids. If provided, then debug information is only created for
                    those rules.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Multi String</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#_ugr.tools.ruta.ae.basic.parameter.profile">profile</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Option to add profile information to the CAS.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Single Boolean</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#_ugr.tools.ruta.ae.basic.parameter.statistics">statistics</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Option to add statistics of conditions and actions to the CAS.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Single Boolean</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#_ugr.tools.ruta.ae.basic.parameter.createdby">createdBy</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Option to add additional information, which rule created an annotation.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Single Boolean</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#_ugr.tools.ruta.ae.basic.parameter.varnames">varNames</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">String array with names of variables. Is used in combination with varValues.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Multi String</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#_ugr.tools.ruta.ae.basic.parameter.varvalues">varValues</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">String array with values of variables. Is used in combination with varNames.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Multi String</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#_ugr.tools.ruta.ae.basic.parameter.dictremovews">dictRemoveWS</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Remove whitespaces when loading dictionaries.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Single Boolean</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#_ugr.tools.ruta.ae.basic.parameter.csvseparator">csvSeparator</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">String/token to be used to split columns in CSV tables.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Single String</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#_ugr.tools.ruta.ae.basic.parameter.inferencevisitors">inferenceVisitors</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">List of factory classes for additional inference visitors.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Multi String</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#_ugr.tools.ruta.ae.basic.parameter.maxrulematches">maxRuleMatches</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Maximum amount of allowed matches of a single rule.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Single Integer</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#_ugr.tools.ruta.ae.basic.parameter.maxrulematches">maxRuleElementMatches</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Maximum amount of allowed matches of a single rule element.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Single Integer</p></td>
</tr>
</tbody>
</table>
<div class="sect5">
<h6 id="_ugr.tools.ruta.ae.basic.parameter.mainscript"><a class="anchor" href="#_ugr.tools.ruta.ae.basic.parameter.mainscript"></a>mainScript</h6>
<div class="paragraph">
<p>This parameter specifies the rule file that will be executed by the analysis engine and is, therefore, one of the most important ones.
The exact name of the script is given by the complete namespace of the file, which corresponds to its location relative to the given parameter <a href="#_ugr.tools.ruta.ae.basic.parameter.scriptpaths">scriptPaths</a>.
The single names of packages (or folders) are separated by periods.
An exemplary value for this parameter could be "org.apache.uima.Main",  whereas "Main" specifies the file containing the rules and "org.apache.uima" its package.
In this case, the analysis engine loads the script file "Main.ruta", which is located in the folder structure "org/apache/uima/". This parameter has no default value and has to be provided, although it is not specified as mandatory.</p>
</div>
</div>
<div class="sect5">
<h6 id="_ugr.tools.ruta.ae.basic.parameter.rules"><a class="anchor" href="#_ugr.tools.ruta.ae.basic.parameter.rules"></a>rules</h6>
<div class="paragraph">
<p>A String parameter representing the rule that should be applied by the analysis engine.
If set, it replaces the content of file specified by the <a href="#_ugr.tools.ruta.ae.basic.parameter.mainscript">mainScript</a> parameter.</p>
</div>
</div>
<div class="sect5">
<h6 id="_ugr.tools.ruta.ae.basic.parameter.rulesscriptname"><a class="anchor" href="#_ugr.tools.ruta.ae.basic.parameter.rulesscriptname"></a>rulesScriptName</h6>
<div class="paragraph">
<p>This parameter specifies the name of the non-existing script if the <a href="#_ugr.tools.ruta.ae.basic.parameter.rules">rules</a> parameter is used.
The default value is 'Anonymous'.</p>
</div>
</div>
<div class="sect5">
<h6 id="_ugr.tools.ruta.ae.basic.parameter.scriptencoding"><a class="anchor" href="#_ugr.tools.ruta.ae.basic.parameter.scriptencoding"></a>scriptEncoding</h6>
<div class="paragraph">
<p>This parameter specifies the encoding of the rule files.
Its default value is "UTF-8".</p>
</div>
</div>
<div class="sect5">
<h6 id="_ugr.tools.ruta.ae.basic.parameter.scriptpaths"><a class="anchor" href="#_ugr.tools.ruta.ae.basic.parameter.scriptpaths"></a>scriptPaths</h6>
<div class="paragraph">
<p>The parameter scriptPaths refers to a list of String values, which specify the possible locations of script files.
The given locations are absolute paths.
A typical value for this parameter is, for example, "C:/Ruta/MyProject/script/". If the parameter <a href="#_ugr.tools.ruta.ae.basic.parameter.mainscript">mainScript</a> is set to org.apache.uima.Main,  then the absolute path of the script file has to be "C:/Ruta/MyProject/script/org/apache/uima/Main.ruta".  This parameter can contain multiple values, as the main script can refer to multiple projects similar to a class path in Java.</p>
</div>
</div>
<div class="sect5">
<h6 id="_ugr.tools.ruta.ae.basic.parameter.descriptorpaths"><a class="anchor" href="#_ugr.tools.ruta.ae.basic.parameter.descriptorpaths"></a>descriptorPaths</h6>
<div class="paragraph">
<p>This parameter specifies the possible locations for descriptors like analysis engines or type systems, similar to the parameter <a href="#_ugr.tools.ruta.ae.basic.parameter.scriptpaths">scriptPaths</a> for the script files.
A typical value for this parameter  is for example "C:/Ruta/MyProject/descriptor/". The relative values of the parameter <a href="#_ugr.tools.ruta.ae.basic.parameter.additionalengines">additionalEngines</a> are resolved to these absolute locations.
This parameter can contain multiple values, as the main script can refer to multiple projects similar to a class path in Java.</p>
</div>
</div>
<div class="sect5">
<h6 id="_ugr.tools.ruta.ae.basic.parameter.resourcepaths"><a class="anchor" href="#_ugr.tools.ruta.ae.basic.parameter.resourcepaths"></a>resourcePaths</h6>
<div class="paragraph">
<p>This parameter specifies the possible locations of additional resources like word lists or CSV tables.
The string values have to contain absolute locations, for example, "C:/Ruta/MyProject/resources/".</p>
</div>
</div>
<div class="sect5">
<h6 id="_ugr.tools.ruta.ae.basic.parameter.additionalscripts"><a class="anchor" href="#_ugr.tools.ruta.ae.basic.parameter.additionalscripts"></a>additionalScripts</h6>
<div class="paragraph">
<p>The optional parameter additionalScripts is defined as a list of string values and contains script files, which are additionally loaded by the analysis engine.
These script files are specified by their  complete namespace, exactly like the value of the parameter <a href="#_ugr.tools.ruta.ae.basic.parameter.mainscript">mainScript</a>  and can be refered to by language elements, e.g., by executing the containing rules.
An exemplary value of this parameter is "org.apache.uima.SecondaryScript". In this example, the main script could import  this script file by the declaration "SCRIPT org.apache.uima.SecondaryScript;" and then could execute it with the rule  "Document{&#8594; CALL(SecondaryScript)};". This optional list can be used as a replacement of global imports in the script file.</p>
</div>
</div>
<div class="sect5">
<h6 id="_ugr.tools.ruta.ae.basic.parameter.additionalengines"><a class="anchor" href="#_ugr.tools.ruta.ae.basic.parameter.additionalengines"></a>additionalEngines</h6>
<div class="paragraph">
<p>This optional parameter contains a list of additional analysis engines, which can be executed by the UIMA Ruta rules.
The single values are given by the name of the analysis engine with their complete namespace and have to be located relative to one value of the parameter <a href="#_ugr.tools.ruta.ae.basic.parameter.descriptorpaths">descriptorPaths</a>, the location where the analysis engine searches for the descriptor file.
An example for one value of the parameter is "utils.HtmlAnnotator", which points to the descriptor "HtmlAnnotator.xml" in the folder "utils". This optional list can be used as a replacement of global imports in the script file.</p>
</div>
</div>
<div class="sect5">
<h6 id="_ugr.tools.ruta.ae.basic.parameter.additionaluimafitengines"><a class="anchor" href="#_ugr.tools.ruta.ae.basic.parameter.additionaluimafitengines"></a>additionalUimafitEngines</h6>
<div class="paragraph">
<p>This optional parameter contains a list of additional analysis engines, which can be executed by the UIMA Ruta rules.
The single values are given by the name of the implementation with the complete namespace and have to be present int he classpath of the application.
An example for one value of the parameter is "org.apache.uima.ruta.engine.HtmlAnnotator", which points to the "HtmlAnnotator" class.
This optional list can be used as a replacement of global imports in the script file.</p>
</div>
</div>
<div class="sect5">
<h6 id="_ugr.tools.ruta.ae.basic.parameter.additionalextensions"><a class="anchor" href="#_ugr.tools.ruta.ae.basic.parameter.additionalextensions"></a>additionalExtensions</h6>
<div class="paragraph">
<p>This parameter specifies optional extensions of the UIMA Ruta language.
The elements of the string list have to implement the interface  "org.apache.uima.ruta.extensions.IRutaExtension". With these extensions, application-specific conditions and actions can be added to the set of provided ones.</p>
</div>
</div>
<div class="sect5">
<h6 id="_ugr.tools.ruta.ae.basic.parameter.reloadscript"><a class="anchor" href="#_ugr.tools.ruta.ae.basic.parameter.reloadscript"></a>reloadScript</h6>
<div class="paragraph">
<p>This boolean parameter indicates whether the script or resource files should be reloaded when processing a CAS.
The default value is set to false.
In this case, the script files are loaded when the analysis engine is initialized.
If script files or resource files are extended, e.g., a dictionary is filled yet when a collection of documents are processed, then the parameter is needed to be set to true in order to include the changes.</p>
</div>
</div>
<div class="sect5">
<h6 id="_ugr.tools.ruta.ae.basic.parameter.seeders"><a class="anchor" href="#_ugr.tools.ruta.ae.basic.parameter.seeders"></a>seeders</h6>
<div class="paragraph">
<p>This list of string values refers to implementations of the interface "org.apache.uima.ruta.seed.RutaAnnotationSeeder",  which can be used to automatically add annotations to the CAS.
The default value of the parameter is a single seeder, namely "org.apache.uima.ruta.seed.TextSeeder" that adds annotations for token classes like CW, NUM and SEMICOLON, but not MARKUP.
Remember that additional annotations can also be added with  an additional engine that is executed by a UIMA Ruta rule.</p>
</div>
</div>
<div class="sect5">
<h6 id="_ugr.tools.ruta.ae.basic.parameter.defaultfilteredtypes"><a class="anchor" href="#_ugr.tools.ruta.ae.basic.parameter.defaultfilteredtypes"></a>defaultFilteredTypes</h6>
<div class="paragraph">
<p>This parameter specifies a list of types, which are filtered by default when executing a script file.
Using the default values of this parameter, whitespaces, line breaks and markup elements are not visible to Ruta rules.
The visibility of annotations and, therefore, the covered text can be changed using the actions <a href="#_ugr.tools.ruta.language.actions.filtertype">FILTERTYPE</a> and <a href="#_ugr.tools.ruta.language.actions.retaintype">RETAINTYPE</a>.</p>
</div>
</div>
<div class="sect5">
<h6 id="_ugr.tools.ruta.ae.basic.parameter.removebasics"><a class="anchor" href="#_ugr.tools.ruta.ae.basic.parameter.removebasics"></a>removeBasics</h6>
<div class="paragraph">
<p>This parameter specifies whether the inference annotations created by the analysis engine should be removed after processing the CAS.
The default value is set to false.</p>
</div>
</div>
<div class="sect5">
<h6 id="_ugr.tools.ruta.ae.basic.parameter.indexonly"><a class="anchor" href="#_ugr.tools.ruta.ae.basic.parameter.indexonly"></a>indexOnly</h6>
<div class="paragraph">
<p>This parameter specifies the annotation types which should be indexed for ruta&#8217;s internal annotations.
All annotation types that are relevant need to be listed here.
The value of this parameter needs only be adapted for performance and memory optimization in pipelines that contains several ruta analysis engines.
Default value is uima.tcas.Annotation</p>
</div>
</div>
<div class="sect5">
<h6 id="_ugr.tools.ruta.ae.basic.parameter.indexskiptypes"><a class="anchor" href="#_ugr.tools.ruta.ae.basic.parameter.indexskiptypes"></a>indexSkipTypes</h6>
<div class="paragraph">
<p>This parameter specifies annotation types that should not be indexed at all.
These types normally include annotations that provide no meaningful semantics for text processing, e.g., types concerning ruta debug information.</p>
</div>
</div>
<div class="sect5">
<h6 id="_ugr.tools.ruta.ae.basic.parameter.indexonlymentionedtypes"><a class="anchor" href="#_ugr.tools.ruta.ae.basic.parameter.indexonlymentionedtypes"></a>indexOnlyMentionedTypes</h6>
<div class="paragraph">
<p>If this parameter is activated, then only annotations of types are internally indexed that are mentioned with in the rules.
This optimization of the internal indexing can improve the speed and reduce the memory footprint.
However, several features of the rule matching require the indexing of types that are not mentioned in the rules, e.g., literal rule matches, wildcards and actions like MARKFAST, MARKTABLE, TRIE.
Default value is false.</p>
</div>
</div>
<div class="sect5">
<h6 id="_ugr.tools.ruta.ae.basic.parameter.indexadditionally"><a class="anchor" href="#_ugr.tools.ruta.ae.basic.parameter.indexadditionally"></a>indexAdditionally</h6>
<div class="paragraph">
<p>This parameter specifies annotation types that should be index additionally to types mentioned in the rules.
This parameter is only used if the parameter 'indexOnlyMentionedTypes' is activated.</p>
</div>
</div>
<div class="sect5">
<h6 id="_ugr.tools.ruta.ae.basic.parameter.reindexonly"><a class="anchor" href="#_ugr.tools.ruta.ae.basic.parameter.reindexonly"></a>reindexOnly</h6>
<div class="paragraph">
<p>This parameter specifies the annotation types which should be reindexed for ruta&#8217;s internal annotations All annotation types that changed since the last call of a ruta script need to be listed here.
The value of this parameter needs only be adapted for performance optimization in pipelines that  contains several ruta analysis engines.
Default value is uima.tcas.Annotation</p>
</div>
</div>
<div class="sect5">
<h6 id="_ugr.tools.ruta.ae.basic.parameter.reindexskiptypes"><a class="anchor" href="#_ugr.tools.ruta.ae.basic.parameter.reindexskiptypes"></a>reindexSkipTypes</h6>
<div class="paragraph">
<p>This parameter specifies annotation types that should not be reindexed.
These types normally include annotations that are added once and are not changed in the following pipeline, e.g., Tokens or TokenSeed (like CW).</p>
</div>
</div>
<div class="sect5">
<h6 id="_ugr.tools.ruta.ae.basic.parameter.reindexonlymentionedtypes"><a class="anchor" href="#_ugr.tools.ruta.ae.basic.parameter.reindexonlymentionedtypes"></a>reindexOnlyMentionedTypes</h6>
<div class="paragraph">
<p>If this parameter is activated, then only annotations of types are internally reindexed at beginning that are mentioned with in the rules.
This parameter overrides the values of the parameter 'reindexOnly' with the types that are mentioned in the rules.
Default value is false.</p>
</div>
</div>
<div class="sect5">
<h6 id="_ugr.tools.ruta.ae.basic.parameter.reindexadditionally"><a class="anchor" href="#_ugr.tools.ruta.ae.basic.parameter.reindexadditionally"></a>reindexAdditionally</h6>
<div class="paragraph">
<p>This parameter specifies annotation types that should be reindexed additionally to types mentioned in the rules.
This parameter is only used if the parameter 'reindexOnlyMentionedTypes' is activated.</p>
</div>
</div>
<div class="sect5">
<h6 id="_ugr.tools.ruta.ae.basic.parameter.indexupdatemode"><a class="anchor" href="#_ugr.tools.ruta.ae.basic.parameter.indexupdatemode"></a>indexUpdateMode</h6>
<div class="paragraph">
<p>This parameter specifies the mode for updating the internal indexing in RutaBasic annotations.
This is a technical parameter for optimizing the runtime performance/speed of RutaEngines.
Available modes are: COMPLETE, ADDITIVE, SAFE_ADDITIVE, NONE.
Default value is ADDITIVE.</p>
</div>
</div>
<div class="sect5">
<h6 id="_ugr.tools.ruta.ae.basic.parameter.validateinternalindexing"><a class="anchor" href="#_ugr.tools.ruta.ae.basic.parameter.validateinternalindexing"></a>validateInternalIndexing</h6>
<div class="paragraph">
<p>Option to validate the internal indexing in RutaBasic with the current CAS after the indexing and reindexing is performed.
Annotations that are not correctly indexing in RutaBasics cause Exceptions.
Annotations of types listed in parameter 'indexSkipTypes' and 'reindexSkipTypes' are ignored.
Default value is false.</p>
</div>
</div>
<div class="sect5">
<h6 id="_ugr.tools.ruta.ae.basic.parameter.emptyisinvisible"><a class="anchor" href="#_ugr.tools.ruta.ae.basic.parameter.emptyisinvisible"></a>emptyIsInvisible</h6>
<div class="paragraph">
<p>This parameter determines positions as invisible if the internal indexing of the corresponding RutaBasic annotation is empty.
Default value is true.</p>
</div>
</div>
<div class="sect5">
<h6 id="_ugr.tools.ruta.ae.basic.parameter.modifydatapath"><a class="anchor" href="#_ugr.tools.ruta.ae.basic.parameter.modifydatapath"></a>modifyDataPath</h6>
<div class="paragraph">
<p>This parameter specifies whether the datapath of the ResourceManager is extended by the values of the configuration parameter <code>descriptorPaths</code>.
The default value is set to false.</p>
</div>
</div>
<div class="sect5">
<h6 id="_ugr.tools.ruta.ae.basic.parameter.strictimports"><a class="anchor" href="#_ugr.tools.ruta.ae.basic.parameter.strictimports"></a>strictImports</h6>
<div class="paragraph">
<p>This parameter specifies whether short type names should be resolved against the typesystems declared in the script (true) or at runtime in the CAS typesystem (false). The default value is set to false.</p>
</div>
</div>
<div class="sect5">
<h6 id="_ugr.tools.ruta.ae.basic.parameter.typeignorepattern"><a class="anchor" href="#_ugr.tools.ruta.ae.basic.parameter.typeignorepattern"></a>typeIgnorePattern</h6>
<div class="paragraph">
<p>An optional pattern (regular expression) which defined types that should be ignored.
These  types will not be resolved even if strictImports is set to false.
This parameter can be used to  ignore complete namespaces of type that could contain ambiguous short names.</p>
</div>
</div>
<div class="sect5">
<h6 id="_ugr.tools.ruta.ae.basic.parameter.dynamicanchoring"><a class="anchor" href="#_ugr.tools.ruta.ae.basic.parameter.dynamicanchoring"></a>dynamicAnchoring</h6>
<div class="paragraph">
<p>If this parameter is set to true, then the Ruta rules are not forced to start to match with the first rule element.
Rather, the rule element referring to the most rare type is chosen.
This option can be utilized to optimize the performance.
Please mind that the matching result can vary in some cases when greedy rule elements are applied.
The default value is set to false.</p>
</div>
</div>
<div class="sect5">
<h6 id="_ugr.tools.ruta.ae.basic.parameter.lowmemoryprofile"><a class="anchor" href="#_ugr.tools.ruta.ae.basic.parameter.lowmemoryprofile"></a>lowMemoryProfile</h6>
<div class="paragraph">
<p>This parameter specifies whether the memory consumption should be reduced.
This parameter should be set to true for  very large CAS documents (e.g., &gt; 500k tokens), but it also reduces the performance.
The default value is set to false.</p>
</div>
</div>
<div class="sect5">
<h6 id="_ugr.tools.ruta.ae.basic.parameter.simplegreedyforcomposed"><a class="anchor" href="#_ugr.tools.ruta.ae.basic.parameter.simplegreedyforcomposed"></a>simpleGreedyForComposed</h6>
<div class="paragraph">
<p>This parameter specifies whether a different inference strategy for composed rule elements should be applied.
This option is only necessary  when the composed rule element is expected to match very often, e.g., a rule element like (ANY ANY)+. The default value of this parameter is set to false.</p>
</div>
</div>
<div class="sect5">
<h6 id="_ugr.tools.ruta.ae.basic.parameter.debug"><a class="anchor" href="#_ugr.tools.ruta.ae.basic.parameter.debug"></a>debug</h6>
<div class="paragraph">
<p>If this parameter is set to true, then additional information about the execution of a rule script is added to the CAS.
The actual information is specified by the following parameters.
The default value of this parameter is set to false.</p>
</div>
</div>
<div class="sect5">
<h6 id="_ugr.tools.ruta.ae.basic.parameter.debugwithmatches"><a class="anchor" href="#_ugr.tools.ruta.ae.basic.parameter.debugwithmatches"></a>debugWithMatches</h6>
<div class="paragraph">
<p>This parameter specifies whether the match information (covered text) of the rules should be stored in the CAS.
The default value of this parameter is set to false.</p>
</div>
</div>
<div class="sect5">
<h6 id="_ugr.tools.ruta.ae.basic.parameter.debugaddtoindexes"><a class="anchor" href="#_ugr.tools.ruta.ae.basic.parameter.debugaddtoindexes"></a>debugAddToIndexes</h6>
<div class="paragraph">
<p>This parameter specifies whether all debug annotation should be added to the indexes.
By default this parameter is deactivated and only the root script apply is added.</p>
</div>
</div>
<div class="sect5">
<h6 id="_ugr.tools.ruta.ae.basic.parameter.debugonlyfor"><a class="anchor" href="#_ugr.tools.ruta.ae.basic.parameter.debugonlyfor"></a>debugOnlyFor</h6>
<div class="paragraph">
<p>This parameter specifies a list of rule-ids that enumerate the rule for which debug information should be created.
No specific ids are given by default.</p>
</div>
</div>
<div class="sect5">
<h6 id="_ugr.tools.ruta.ae.basic.parameter.profile"><a class="anchor" href="#_ugr.tools.ruta.ae.basic.parameter.profile"></a>profile</h6>
<div class="paragraph">
<p>If this parameter is set to true, then additional information about the runtime of applied rules is added to the CAS.
The default value of this parameter is set to false.</p>
</div>
</div>
<div class="sect5">
<h6 id="_ugr.tools.ruta.ae.basic.parameter.statistics"><a class="anchor" href="#_ugr.tools.ruta.ae.basic.parameter.statistics"></a>statistics</h6>
<div class="paragraph">
<p>If this parameter is set to true, then additional information about the runtime of UIMA Ruta language elements like conditions and actions is added to the CAS.
The default value of this parameter is set to false.</p>
</div>
</div>
<div class="sect5">
<h6 id="_ugr.tools.ruta.ae.basic.parameter.createdby"><a class="anchor" href="#_ugr.tools.ruta.ae.basic.parameter.createdby"></a>createdBy</h6>
<div class="paragraph">
<p>If this parameter is set to true, then additional information about what annotation was created by which rule is added to the CAS.
The default value of this parameter is set to false.</p>
</div>
</div>
<div class="sect5">
<h6 id="_ugr.tools.ruta.ae.basic.parameter.varnames"><a class="anchor" href="#_ugr.tools.ruta.ae.basic.parameter.varnames"></a>varNames</h6>
<div class="paragraph">
<p>This parameter specifies the names of variables and is used in combination with the parameter varValues, which contains the values of the corresponding variables.
The n-th entry of this string array specifies the variable of the n-th entry of the string array of the parameter varValues.
If the variables is defined in the root of a script, then the name of the variable suffices.
If the variable is defined in a BLOCK or imported script, then the the name must contain the namespaces of the blocks as a prefix, e.g., InnerBlock.varName or OtherScript.SomeBlock.varName.</p>
</div>
</div>
<div class="sect5">
<h6 id="_ugr.tools.ruta.ae.basic.parameter.varvalues"><a class="anchor" href="#_ugr.tools.ruta.ae.basic.parameter.varvalues"></a>varValues</h6>
<div class="paragraph">
<p>This parameter specifies the values of variables as string values in an string array.
It is used in combination with the parameter varNames, which contains the names of the corresponding variables.
The n-th entry of this string array specifies the value of the n-th entry of the string array of the parameter varNames.
The values for list variables are separated by the character <code>,</code>.
Thus, the usage of commas is not allowed if the variable is a list.</p>
</div>
</div>
<div class="sect5">
<h6 id="_ugr.tools.ruta.ae.basic.parameter.dictremovews"><a class="anchor" href="#_ugr.tools.ruta.ae.basic.parameter.dictremovews"></a>dictRemoveWS</h6>
<div class="paragraph">
<p>If this parameter is set to true, then whitespaces are removed when dictionaries are loaded.
The default is set to "true".</p>
</div>
</div>
<div class="sect5">
<h6 id="_ugr.tools.ruta.ae.basic.parameter.csvseparator"><a class="anchor" href="#_ugr.tools.ruta.ae.basic.parameter.csvseparator"></a>csvSeparator</h6>
<div class="paragraph">
<p>If this parameter is set to any String value then this String/token is used to split columns in CSV tables.
The default is set to ';'.</p>
</div>
</div>
<div class="sect5">
<h6 id="_ugr.tools.ruta.ae.basic.parameter.inferencevisitors"><a class="anchor" href="#_ugr.tools.ruta.ae.basic.parameter.inferencevisitors"></a>inferenceVisitors</h6>
<div class="paragraph">
<p>This parameter specifies optional class names implementing the interface <code>org.apache.uima.ruta.visitor.RutaInferenceVisitor</code>, which will be notified during applying the rules.</p>
</div>
</div>
<div class="sect5">
<h6 id="_ugr.tools.ruta.ae.basic.parameter.maxrulematches"><a class="anchor" href="#_ugr.tools.ruta.ae.basic.parameter.maxrulematches"></a>maxRuleMatches</h6>
<div class="paragraph">
<p>Maximum amount of allowed matches of a single rule.</p>
</div>
</div>
<div class="sect5">
<h6 id="_ugr.tools.ruta.ae.basic.parameter.maxruleelementmatches"><a class="anchor" href="#_ugr.tools.ruta.ae.basic.parameter.maxruleelementmatches"></a>maxRuleElementMatches</h6>
<div class="paragraph">
<p>Maximum amount of allowed matches of a single rule element.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.ae.annotationwriter"><a class="anchor" href="#_ugr.tools.ruta.ae.annotationwriter"></a>1.5.2. Annotation Writer</h4>
<div class="paragraph">
<p>This Analysis Engine can be utilized to write the covered text of annotations in a text file, whereas each covered text is put into a new line.
If the Analysis engine, for example, is configured for the type &#8220;uima.example.Person&#8221;, then all covered texts of all Person annotations are stored in a text file, one person in each line.
A descriptor file for this Analysis Engine is located in the folder &#8220;descriptor/utils&#8221; of a UIMA Ruta project.</p>
</div>
<div class="sect4">
<h5 id="_ugr.tools.ruta.ae.annotationwriter.parameter"><a class="anchor" href="#_ugr.tools.ruta.ae.annotationwriter.parameter"></a>Configuration Parameters</h5>
<div class="sect5">
<h6 id="_ugr.tools.ruta.ae.annotationwriter.parameter.output"><a class="anchor" href="#_ugr.tools.ruta.ae.annotationwriter.parameter.output"></a>Output</h6>
<div class="paragraph">
<p>This string parameter specifies the absolute path of the resulting file named &#8220;output.txt&#8221;.
However, if an annotation of the  type &#8220;org.apache.uima.examples.SourceDocumentInformation&#8221; is given, then the value of this parameter is interpreted to be relative to the URI stored in the annotation and the name of the file will be adapted to the name of the source file.
If this functionality is activated in the preferences,  then the UIMA Ruta Workbench adds the SourceDocumentInformation annotation when the user launches a script file.
The default value of this parameter is &#8220;/../output/&#8221;.</p>
</div>
</div>
<div class="sect5">
<h6 id="_ugr.tools.ruta.ae.annotationwriter.parameter.encoding"><a class="anchor" href="#_ugr.tools.ruta.ae.annotationwriter.parameter.encoding"></a>Encoding</h6>
<div class="paragraph">
<p>This string parameter specifies the encoding of the resulting file.
The default value of this parameter is &#8220;UTF-8&#8221;.</p>
</div>
</div>
<div class="sect5">
<h6 id="_ugr.tools.ruta.ae.annotationwriter.parameter.type"><a class="anchor" href="#_ugr.tools.ruta.ae.annotationwriter.parameter.type"></a>Type</h6>
<div class="paragraph">
<p>Only the covered texts of annotations of the type specified with this parameter are stored in the resulting file.
The default value of this parameter is &#8220;uima.tcas.DocumentAnnotation&#8221;, which will store the complete document in a new file.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.ae.plaintext"><a class="anchor" href="#_ugr.tools.ruta.ae.plaintext"></a>1.5.3. Plain Text Annotator</h4>
<div class="paragraph">
<p>This Analysis Engines adds annotations for lines and paragraphs.
A descriptor file for this Analysis Engine is located in the folder &#8220;descriptor/utils&#8221; of a UIMA Ruta project.
There are no configuration parameters.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.ae.modifier"><a class="anchor" href="#_ugr.tools.ruta.ae.modifier"></a>1.5.4. Modifier</h4>
<div class="paragraph">
<p>The Modifier Analysis Engine can be used to create an additional view, which contains all textual modifications and HTML highlightings that were specified by the executed rules.
This Analysis Engine can be applied, e.g.,  for anonymization where all annotations of persons are replaced by the string &#8220;Person&#8221;.
Furthermore, the content of the new view can optionally be stored in a new HTML file.
A descriptor file for this Analysis Engine is located in the folder &#8220;descriptor/utils&#8221; of a UIMA Ruta project.</p>
</div>
<div class="sect4">
<h5 id="_ugr.tools.ruta.ae.modifier.parameter"><a class="anchor" href="#_ugr.tools.ruta.ae.modifier.parameter"></a>Configuration Parameters</h5>
<div class="sect5">
<h6 id="_ugr.tools.ruta.ae.modifier.parameter.stylemap"><a class="anchor" href="#_ugr.tools.ruta.ae.modifier.parameter.stylemap"></a>styleMap</h6>
<div class="paragraph">
<p>This string parameter specifies the name of the style map file created by the Style Map Creator Analysis Engine, which stores the colors for additional highlightings in the modified view.</p>
</div>
</div>
<div class="sect5">
<h6 id="_ugr.tools.ruta.ae.modifier.parameter.descriptorpaths"><a class="anchor" href="#_ugr.tools.ruta.ae.modifier.parameter.descriptorpaths"></a>descriptorPaths</h6>
<div class="paragraph">
<p>This parameter can contain multiple string values and specifies the absolute paths where the style map file can be found.</p>
</div>
</div>
<div class="sect5">
<h6 id="_ugr.tools.ruta.ae.modifier.parameter.outputlocation"><a class="anchor" href="#_ugr.tools.ruta.ae.modifier.parameter.outputlocation"></a>outputLocation</h6>
<div class="paragraph">
<p>This optional string parameter specifies the absolute path of the resulting file named &#8220;output.modified.html&#8221;.
However, if an annotation of the  type &#8220;org.apache.uima.examples.SourceDocumentInformation&#8221; is given, then the value of this parameter is interpreted to be relative to the URI stored in the annotation and the name of the file will be adapted to the name of the source file.
If this functionality is activated in the preferences,  then the UIMA Ruta Workbench adds the SourceDocumentInformation annotation when the user launches a script file.
The default value of this parameter is empty.
In this case no additional html file will be created.</p>
</div>
</div>
<div class="sect5">
<h6 id="_ugr.tools.ruta.ae.modifier.parameter.outputview"><a class="anchor" href="#_ugr.tools.ruta.ae.modifier.parameter.outputview"></a>outputView</h6>
<div class="paragraph">
<p>This string parameter specifies the name of the view, which will contain the modified document.
A view of this name must not yet exist.
The default value of this parameter is &#8220;modified&#8221;.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.ae.html"><a class="anchor" href="#_ugr.tools.ruta.ae.html"></a>1.5.5. HTML Annotator</h4>
<div class="paragraph">
<p>This Analysis Engine provides support for HTML files by adding annotations for the HTML elements.
Using the default values, the HTML Annotator creates annotations for each HTML element spanning the content of the element, whereas the most common elements are represented by own types.
The document <code>This text is &lt;b&gt;bold&lt;/b&gt;.</code>, for example, would be annotated with an annotation of the type &#8220;org.apache.uima.ruta.type.html.B&#8221; for the word &#8220;bold&#8221;.
The HTML annotator can be configured  in order to include the start and end elements in the created annotations.
A descriptor file for this Analysis Engine is located in the folder &#8220;descriptor/utils&#8221; of a UIMA Ruta project.</p>
</div>
<div class="sect4">
<h5 id="_ugr.tools.ruta.ae.html.parameter"><a class="anchor" href="#_ugr.tools.ruta.ae.html.parameter"></a>Configuration Parameters</h5>
<div class="sect5">
<h6 id="_ugr.tools.ruta.ae.html.parameter.onlycontent"><a class="anchor" href="#_ugr.tools.ruta.ae.html.parameter.onlycontent"></a>onlyContent</h6>
<div class="paragraph">
<p>This parameter specifies whether created annotations should cover only the content of the HTML elements or also their start and end elements.
The default value is &#8220;true&#8221;.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.ae.htmlconverter"><a class="anchor" href="#_ugr.tools.ruta.ae.htmlconverter"></a>1.5.6. HTML Converter</h4>
<div class="paragraph">
<p>This Analysis Engine is able to convert html content from a source view into a plain string representation stored in an output view.
Especially, the Analysis Engine transfers annotations under consideration of the changed document text and annotation offsets in the new view.
The copy process also sets features, however, features of type annotation are currently not supported.
Note that if an annotation would have the same start and end positions in the new view, i.e.,  if it would be mapped to an annotation of length 0, it is not moved to the new view.
The HTML Converter also supports heuristic and explicit conversion patterns which default to html4 decoding,  e.g., <code>&nbsp;</code>, <code>&lt;</code>, etc.
Concepts like tables or lists are not supported.
Note that in general it is suggested to run an html cleaner before any further processing to avoid problems with malformed html.
A descriptor file for this Analysis Engine is located in the folder &#8220;descriptor/utils&#8221; of a UIMA Ruta project.</p>
</div>
<div class="sect4">
<h5 id="_ugr.tools.ruta.ae.htmlconverter.parameter"><a class="anchor" href="#_ugr.tools.ruta.ae.htmlconverter.parameter"></a>Configuration Parameters</h5>
<div class="sect5">
<h6 id="_ugr.tools.ruta.ae.htmlconverter.parameter.outputview"><a class="anchor" href="#_ugr.tools.ruta.ae.htmlconverter.parameter.outputview"></a>outputView</h6>
<div class="paragraph">
<p>This string parameter specifies the name of the new view.
The default value is &#8220;plaintext&#8221;.</p>
</div>
</div>
<div class="sect5">
<h6 id="_ugr.tools.ruta.ae.htmlconverter.parameter.inputview"><a class="anchor" href="#_ugr.tools.ruta.ae.htmlconverter.parameter.inputview"></a>inputView</h6>
<div class="paragraph">
<p>This string parameter can optionally be set to specify the name of the input view.</p>
</div>
</div>
<div class="sect5">
<h6 id="_ugr.tools.ruta.ae.htmlconverter.parameter.newlineinducingtags"><a class="anchor" href="#_ugr.tools.ruta.ae.htmlconverter.parameter.newlineinducingtags"></a>newlineInducingTags</h6>
<div class="paragraph">
<p>This string array parameter sets the names of the html tags that create linebreaks in the output view.
The default is &#8220;br, p, div, ul, ol, dl, li, h1, &#8230;&#8203;, h6, blockquote&#8221;.</p>
</div>
</div>
<div class="sect5">
<h6 id="_ugr.tools.ruta.ae.htmlconverter.parameter.replacelinebreaks"><a class="anchor" href="#_ugr.tools.ruta.ae.htmlconverter.parameter.replacelinebreaks"></a>replaceLinebreaks</h6>
<div class="paragraph">
<p>This boolean parameter determines if linebreaks inside the text nodes are kept or removed.
The default behavior is &#8220;true&#8221;.</p>
</div>
</div>
<div class="sect5">
<h6 id="_ugr.tools.ruta.ae.htmlconverter.parameter.linebreakreplacement"><a class="anchor" href="#_ugr.tools.ruta.ae.htmlconverter.parameter.linebreakreplacement"></a>replaceLinebreaks</h6>
<div class="paragraph">
<p>This string parameter determines the character sequence that replaces a linebreak.
The default behavior is the empty string.</p>
</div>
</div>
<div class="sect5">
<h6 id="_ugr.tools.ruta.ae.htmlconverter.parameter.conversionpolicy"><a class="anchor" href="#_ugr.tools.ruta.ae.htmlconverter.parameter.conversionpolicy"></a>conversionPolicy</h6>
<div class="paragraph">
<p>This string parameter determines the conversion policy used, either "heuristic", "explicit", or "none".  When the value is "explicit", the parameters &#8220;conversionPatterns&#8221; and optionally &#8220;conversionReplacements&#8221; are considered.
The "heuristic" conversion policy uses simple regular expressions to decode html4 entities such as <code>&nbsp;</code>. The default behavior is "heuristic".</p>
</div>
</div>
<div class="sect5">
<h6 id="_ugr.tools.ruta.ae.htmlconverter.parameter.conversionpatterns"><a class="anchor" href="#_ugr.tools.ruta.ae.htmlconverter.parameter.conversionpatterns"></a>conversionPatterns</h6>
<div class="paragraph">
<p>This string array parameter can be used to apply custom conversions.
It defaults to a list of commonly used codes, e.g., <code>&nbsp;</code>, which are converted using html 4 entity unescaping.
However, explicit conversion strings can also be passed via the parameter &#8220;conversionReplacements&#8221;.
Remember to enable explicit conversion via &#8220;conversionPolicy&#8221; first.</p>
</div>
</div>
<div class="sect5">
<h6 id="_ugr.tools.ruta.ae.htmlconverter.parameter.conversionreplacements"><a class="anchor" href="#_ugr.tools.ruta.ae.htmlconverter.parameter.conversionreplacements"></a>conversionReplacements</h6>
<div class="paragraph">
<p>This string array parameter corresponds to &#8220;conversionPatterns&#8221; such that &#8220;conversionPatterns[i]&#8221; will be replaced by &#8220;conversionReplacements[i]&#8221;;  replacements should be shorter than the source pattern.
Per default, the replacement strings are computed using Html4 decoding.
Remember to enable explicit conversion via &#8220;conversionPolicy&#8221; first.</p>
</div>
</div>
<div class="sect5">
<h6 id="_ugr.tools.ruta.ae.htmlconverter.parameter.skipwhitespaces"><a class="anchor" href="#_ugr.tools.ruta.ae.htmlconverter.parameter.skipwhitespaces"></a>skipWhitespaces</h6>
<div class="paragraph">
<p>This boolean parameter determines if the converter should skip whitespaces.
Html documents often contains whitespaces for indentation and formatting,  which should not be reproduced in the converted plain text document.
If the parameter is set to false, then the whitespaces are not removed.
This behavior is useful, if not Html documents are converted, but XMl files.
The default value is true.</p>
</div>
</div>
<div class="sect5">
<h6 id="_ugr.tools.ruta.ae.htmlconverter.parameter.processall"><a class="anchor" href="#_ugr.tools.ruta.ae.htmlconverter.parameter.processall"></a>processAll</h6>
<div class="paragraph">
<p>If this boolean parameter is set to true, then the tags of the complete document is processed and not only those within the body tag.</p>
</div>
</div>
<div class="sect5">
<h6 id="_ugr.tools.ruta.ae.htmlconverter.parameter.newlineinducingtagregexp"><a class="anchor" href="#_ugr.tools.ruta.ae.htmlconverter.parameter.newlineinducingtagregexp"></a>newlineInducingTagRegExp</h6>
<div class="paragraph">
<p>This string parameter contains a regular expression for HTML/XML elements.
If the pattern matches, then the element will introduce a new line break similar to the element of the parameter &#8220;newlineInducingTags&#8221;.</p>
</div>
</div>
<div class="sect5">
<h6 id="_ugr.tools.ruta.ae.htmlconverter.parameter.gapinducingtags"><a class="anchor" href="#_ugr.tools.ruta.ae.htmlconverter.parameter.gapinducingtags"></a>gapInducingTags</h6>
<div class="paragraph">
<p>This string array parameter sets the names of the html tags that create additional text in the output view.
The actual string of the gap is defined by the parameter &#8220;gapText&#8221;.</p>
</div>
</div>
<div class="sect5">
<h6 id="_ugr.tools.ruta.ae.htmlconverter.parameter.gaptext"><a class="anchor" href="#_ugr.tools.ruta.ae.htmlconverter.parameter.gaptext"></a>gapText</h6>
<div class="paragraph">
<p>This string parameter determines the character sequence that is introduced by the html tags specified in the &#8220;gapInducingTags&#8221;.</p>
</div>
</div>
<div class="sect5">
<h6 id="_ugr.tools.ruta.ae.htmlconverter.parameter.usespacegap"><a class="anchor" href="#_ugr.tools.ruta.ae.htmlconverter.parameter.usespacegap"></a>useSpaceGap</h6>
<div class="paragraph">
<p>This boolean parameter sets the value of the parameter &#8220;gapText&#8221; to a single space..</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.ae.stylemap"><a class="anchor" href="#_ugr.tools.ruta.ae.stylemap"></a>1.5.7. Style Map Creator</h4>
<div class="paragraph">
<p>This Analysis Engine can be utilized to create style map information, which is needed by the Modifier Analysis Engine in order to create highlighting for some annotations.
Style map information can be created using the <a href="#_ugr.tools.ruta.language.actions.color">COLOR</a> action.
A descriptor file for this Analysis Engine is located in the folder &#8220;descriptor/utils&#8221; of a UIMA Ruta project.</p>
</div>
<div class="sect4">
<h5 id="_ugr.tools.ruta.ae.stylemap.parameter"><a class="anchor" href="#_ugr.tools.ruta.ae.stylemap.parameter"></a>Configuration Parameters</h5>
<div class="sect5">
<h6 id="_ugr.tools.ruta.ae.stylemap.parameter.stylemap"><a class="anchor" href="#_ugr.tools.ruta.ae.stylemap.parameter.stylemap"></a>styleMap</h6>
<div class="paragraph">
<p>This string parameter specifies the name of the style map file created by the Style Map Creator Analysis Engine, which stores the colors for additional highlightings in the modified view.</p>
</div>
</div>
<div class="sect5">
<h6 id="_ugr.tools.ruta.ae.stylemap.parameter.descriptorpaths"><a class="anchor" href="#_ugr.tools.ruta.ae.stylemap.parameter.descriptorpaths"></a>descriptorPaths</h6>
<div class="paragraph">
<p>This parameter can contain multiple string values and specifies the absolute paths where the style map can be found.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.ae.cutter"><a class="anchor" href="#_ugr.tools.ruta.ae.cutter"></a>1.5.8. Cutter</h4>
<div class="paragraph">
<p>This Analysis Engine is able to cut the document of the CAS.
Only the text covered by annotations of the specified type will be retained and all other parts of the documents will be removed.
The offsets of annotations in the index will be updated, but not feature structures nested as feature values.</p>
</div>
<div class="sect4">
<h5 id="_ugr.tools.ruta.ae.cutter.parameter"><a class="anchor" href="#_ugr.tools.ruta.ae.cutter.parameter"></a>Configuration Parameters</h5>
<div class="sect5">
<h6 id="_ugr.tools.ruta.ae.cutter.parameter.keep"><a class="anchor" href="#_ugr.tools.ruta.ae.cutter.parameter.keep"></a>keep</h6>
<div class="paragraph">
<p>This string parameter specifies the complete name of a type.
Only the text covered by annotations of this type will be retained and all other parts of the documents will be removed.</p>
</div>
</div>
<div class="sect5">
<h6 id="_ugr.tools.ruta.ae.cutter.parameter.inputview"><a class="anchor" href="#_ugr.tools.ruta.ae.cutter.parameter.inputview"></a>inputView</h6>
<div class="paragraph">
<p>The name of the view that should be processed.</p>
</div>
</div>
<div class="sect5">
<h6 id="_ugr.tools.ruta.ae.cutter.parameter.outputview"><a class="anchor" href="#_ugr.tools.ruta.ae.cutter.parameter.outputview"></a>outputView</h6>
<div class="paragraph">
<p>The name of the view, which will contain the modified CAS.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.ae.view"><a class="anchor" href="#_ugr.tools.ruta.ae.view"></a>1.5.9. View Writer</h4>
<div class="paragraph">
<p>This Analysis Engine is able to serialize the processed CAS to an XMI file whereas the the source and destination view can be specified  A descriptor file for this Analysis Engine is located in the folder &#8220;descriptor/utils&#8221; of a UIMA Ruta project.</p>
</div>
<div class="sect4">
<h5 id="_ugr.tools.ruta.ae.view.parameter"><a class="anchor" href="#_ugr.tools.ruta.ae.view.parameter"></a>Configuration Parameters</h5>
<div class="sect5">
<h6 id="_ugr.tools.ruta.ae.view.parameter.output"><a class="anchor" href="#_ugr.tools.ruta.ae.view.parameter.output"></a>output</h6>
<div class="paragraph">
<p>This string parameter specifies the absolute path of the resulting file named &#8220;output.xmi&#8221;.
However, if an annotation of the  type &#8220;org.apache.uima.examples.SourceDocumentInformation&#8221; is given, then the value of this parameter is interpreted to be relative to the URI stored in the annotation and the name of the file will be adapted to the name of the source file.
If this functionality is activated in the preferences,  then the UIMA Ruta Workbench adds the SourceDocumentInformation annotation when the user launches a script file.</p>
</div>
</div>
<div class="sect5">
<h6 id="_ugr.tools.ruta.ae.view.parameter.inputview"><a class="anchor" href="#_ugr.tools.ruta.ae.view.parameter.inputview"></a>inputView</h6>
<div class="paragraph">
<p>The name of the view that should be stored in a file.</p>
</div>
</div>
<div class="sect5">
<h6 id="_ugr.tools.ruta.ae.view.parameter.outputview"><a class="anchor" href="#_ugr.tools.ruta.ae.view.parameter.outputview"></a>outputView</h6>
<div class="paragraph">
<p>The name, which should be used, to store the view in the file.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.ae.xmi"><a class="anchor" href="#_ugr.tools.ruta.ae.xmi"></a>1.5.10. XMI Writer</h4>
<div class="paragraph">
<p>This Analysis Engine is able to serialize the processed CAS to an XMI file.
One use case for the XMI Writer is, for example, a rule-based sort, which stores the processed XMI files in different folder, dependent on the execution of the rules, e.g., whether a pattern of annotations occurs or not.
A descriptor file for this Analysis Engine is located in the folder &#8220;descriptor/utils&#8221; of a UIMA Ruta project.</p>
</div>
<div class="sect4">
<h5 id="_ugr.tools.ruta.ae.xmi.parameter"><a class="anchor" href="#_ugr.tools.ruta.ae.xmi.parameter"></a>Configuration Parameters</h5>
<div class="sect5">
<h6 id="_ugr.tools.ruta.ae.xmi.parameter.output"><a class="anchor" href="#_ugr.tools.ruta.ae.xmi.parameter.output"></a>Output</h6>
<div class="paragraph">
<p>This string parameter specifies the absolute path of the resulting file named &#8220;output.xmi&#8221;.
However, if an annotation of the  type &#8220;org.apache.uima.examples.SourceDocumentInformation&#8221; is given, then the value of this parameter is interpreted to be relative to the URI stored in the annotation and the name of the file will be adapted to the name of the source file.
If this functionality is activated in the preferences,  then the UIMA Ruta Workbench adds the SourceDocumentInformation annotation when the user launches a script file.
The default value is &#8220;/../output/&#8221;</p>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_ugr.tools.ruta.language.language"><a class="anchor" href="#_ugr.tools.ruta.language.language"></a>2. Apache UIMA Ruta Language</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This chapter provides a complete description of the Apache UIMA Ruta language.</p>
</div>
<div class="sect2">
<h3 id="_ugr.tools.ruta.language.syntax"><a class="anchor" href="#_ugr.tools.ruta.language.syntax"></a>2.1. Syntax</h3>
<div class="paragraph">
<p>UIMA Ruta defines its own language for writing rules and rule scripts.
This section gives a formal overview of its syntax.</p>
</div>
<div class="paragraph">
<p>Structure: The overall structure of a UIMA Ruta script is defined by the following syntax.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>Script              -&gt; PackageDeclaration? GlobalStatements Statements
PackageDeclaration  -&gt; "PACKAGE" DottedIdentifier ";"
GlobalStatments     -&gt; GlobalStatement*
GlobalStatment      -&gt; ("SCRIPT" | "ENGINE")
                       DottedIdentifier2 ";"
                       | UimafitImport | ImportStatement
UimafitImport       -&gt; "UIMAFIT" DottedIdentifier2
                      ("(" DottedIdentifier2
                      (COMMA DottedIdentifier2)+ ")")?;
Statements          -&gt; Statement*
Statement           -&gt; Declaration | VariableDeclaration
                        | BlockDeclaration | SimpleStatement ";"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Comments are excluded from the syntax definition.
Comments start with "//" and always go to the end of the line.</p>
</div>
<div class="paragraph">
<p>Syntax of import statements:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>ImportStatement  -&gt; (ImportType | ImportPackage | ImportTypeSystem) ";"
ImportType       -&gt; "IMPORT" Type ("FROM" Typesystem)?
                    ("AS" Alias)?
ImportPackage    -&gt; "IMPORT" "PAKAGE" Package ("FROM" Typesystem)?
                    ("AS" Alias)?
ImportTypeSystem -&gt; "IMPORT" "PACKAGE" "*" "FROM" TypeSystem ("AS" Alias)?
                    | "IMPORT" "*" "FROM" Typesystem
                    | "TYPESYSTEM" Typesystem
Type             -&gt; DottedIdentifier
Package          -&gt; DottedIdentifier
TypeSystem       -&gt; DottedIdentifier2
Alias            -&gt; Identifier</code></pre>
</div>
</div>
<div class="paragraph">
<p>Example beginning of a UIMA Ruta file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>PACKAGE uima.ruta.example;

// import the types of this type system
// (located in the descriptor folder -&gt; types folder)
IMPORT * FROM types.BibtexTypeSystem;

SCRIPT uima.ruta.example.Author;
SCRIPT uima.ruta.example.Title;
SCRIPT uima.ruta.example.Year;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Syntax of declarations:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>Declaration -&gt; "DECLARE" (AnnotationType)? Identifier ("," Identifier )*
               | "DECLARE" AnnotationType? Identifier ( "("
               FeatureDeclaration ")" )?
FeatureDeclaration  -&gt; ( (AnnotationType | "STRING" | "INT" | "FLOAT"
                       "DOUBLE" | "BOOLEAN") Identifier) )+
VariableDeclaration -&gt; (("TYPE" Identifier ("," Identifier)*
                                                   ("=" AnnotationType)?)
                     | ("STRING" Identifier ("," Identifier)*
                                                 ("=" StringExpression)?)
                     | (("INT" | "DOUBLE" | "FLOAT") Identifier
                               ("," Identifier)* ("=" NumberExpression)?)
                     | ("BOOLEAN" Identifier ("," Identifier)*
                                                ("=" BooleanExpression)?)
                     | ("ANNOTATION" Identifier("="AnnotationExpression)?)
                     | ("WORDLIST" Identifier ("=" WordListExpression
                                                | StringExpression)?)
                     | ("WORDTABLE" Identifier ("=" WordTableExpression
                                                | StringExpression)?)
                     | ("TYPELIST" Identifier ("=" TypeListExpression)?)
                     | ("STRINGLIST" Identifier
                                             ("=" StringListExpression)?)
                     | (("INTLIST" | "DOUBLELIST" | "FLOATLIST")
                                  Identifier ("=" NumberListExpression)?)
                     | ("BOOLEANLIST" Identifier
                                           ("=" BooleanListExpression)?))
                     | ("ANNOTATIONLIST" Identifier
                                         ("=" AnnotationListExpression)?)
AnnotationType      -&gt;  BasicAnnotationType | declaredAnnotationType
BasicAnnotationType -&gt;  ('COLON'| 'SW' | 'MARKUP' | 'PERIOD' | 'CW'| 'NUM'
                      | 'QUESTION' | 'SPECIAL' | 'CAP' | 'COMMA'
                      | 'EXCLAMATION' | 'SEMICOLON' | 'NBSP'| 'AMP' | '_'
                      | 'SENTENCEEND' | 'W' | 'PM' | 'ANY' | 'ALL'
                      | 'SPACE' | 'BREAK')
BlockDeclaration    -&gt; "BLOCK" "(" Identifier ")" RuleElementWithCA
                                                       "{" Statements "}"
actionDeclaration   -&gt; "ACTION" Identifier "(" ("VAR"? VarType
                       Identifier)? ("," "VAR"? VarType Identifier)*")"
                      "=" Action ( "," Action)* ";"
conditionDeclaration-&gt; "CONDITION" Identifier "(" ("VAR"? VarType
                       Identifier)? ("," "VAR"? VarType Identifier)*")"
                      "=" Condition ( "," Condition)* ";"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Syntax of statements and rule elements:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>SimpleStatement        -&gt; SimpleRule | RegExpRule | ConjunctRules
                          | DocumentActionRule
SimpleRule             -&gt; RuleElements ";"
RegExpRule             -&gt; StringExpression "-&gt;" GroupAssignment
                          ("," GroupAssignment)* ";"
ConjunctRules          -&gt; RuleElements ("%" RuleElements)+ ";"
DocumentActionRule     -&gt; Actions ";"
GroupAssignment        -&gt; TypeExpression
                        | NumberEpxression "=" TypeExpression
RuleElements           -&gt; RuleElement+
RuleElement            -&gt; (Identifier ":")? "@"?
                        RuleElementType | RuleElementLiteral
                        | RuleElementComposed | RuleElementWildCard
                        | RuleElementOptional
RuleElementType        -&gt;  AnnotationTypeExpr OptionalRuleElementPart
RuleElementWithCA      -&gt;  AnnotationTypeExpr ("{" Conditions?
                           Actions? "}")?
AnnotationTypeExpr     -&gt; (TypeExpression | AnnotationExpression
						   TypeListExpression | AnnotationListExpression)
                          (Operator)? Expression ("{" Conditions "}")?
FeatureMatchExpression -&gt; TypeExpression ( "." Feature)+
                          ( Operator (Expression | "null"))?
RuleElementLiteral     -&gt;  SimpleStringExpression OptionalRuleElementPart
RuleElementComposed    -&gt; "(" RuleElement ("&amp;" RuleElement)+ ")"
                          | "(" RuleElement ("|" RuleElement)+ ")"
                          | "(" RuleElements ")"
                          OptionalRuleElementPart
OptionalRuleElementPart-&gt; QuantifierPart? ("{" Conditions?  Actions? "}")?
                          InlinedRules?
InlinedRules           -&gt;  ("&lt;-" "{" SimpleStatement+ "}")*
                           ("-&gt;"  "{" SimpleStatement+ "}")*
RuleElementWildCard    -&gt; "#"("{" Conditions?  Actions? }")? InlinedRules?
RuleElementOptional    -&gt; "_"("{" Conditions?  Actions? }")? InlinedRules?
QuantifierPart         -&gt; "*" | "*?" | "+" | "+?" | "?" | "??"
                        | "[" NumberExpression "," NumberExpression "]"
                        | "[" NumberExpression "," NumberExpression "]?"
Conditions             -&gt; Condition ( "," Condition )*
Actions                -&gt; "-&gt;" (Identifier ":")? Action
                         ( "," (Identifier ":")? Action)*</code></pre>
</div>
</div>
<div class="paragraph">
<p>Since each condition and each action has its own syntax, conditions and actions are described in their own section.
For conditions see <a href="#_ugr.tools.ruta.language.conditions">Section 2.7</a> , for actions see <a href="#_ugr.tools.ruta.language.actions">Section 2.8</a>.
The syntax of expressions is explained in <a href="#_ugr.tools.ruta.language.expressions">Section 2.6</a>.</p>
</div>
<div class="paragraph">
<p>It is also possible to use specific expression as implicit conditions or action additionally to the set of available conditions and actions.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>Condition -&gt; BooleanExpression | FeatureMatchExpression
Action    -&gt; TypeExpression | FeatureAssignmentExpression
              | VariableAssignmentExpression</code></pre>
</div>
</div>
<div class="paragraph">
<p>Identifier:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>DottedIdentifier    -&gt;  Identifier ("." Identifier)*
DottedIdentifier2   -&gt;  Identifier (("."|"-") Identifier)*
Identifier          -&gt;  letter (letter|digit)*</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_ugr.tools.ruta.language.anchoring"><a class="anchor" href="#_ugr.tools.ruta.language.anchoring"></a>2.2. Rule elements and their matching order</h3>
<div class="paragraph">
<p>If not specified otherwise, then the UIMA Ruta rules normally start the matching  process with their first rule element.
The first rule element searches for possible positions for its matching condition and then will advise the next rule element to continue the matching process.
For that reason, writing rules that contain a first rule element with an optional quantifier is discouraged  and will result in ignoring the optional attribute of the quantifier.</p>
</div>
<div class="paragraph">
<p>The starting rule element can also be manually specified by adding &#8220;@&#8221; directly in front of the matching condition.
In the following example, the rule first searches for capitalized words (CW) and then checks whether  there is a period in front of the matched word.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>PERIOD @CW;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This functionality can also be used for rules that start with an optional rule element by manually specifying a later rule element to start the matching process.</p>
</div>
<div class="paragraph">
<p>The choice of the starting rule element can greatly influence the performance speed of the rule execution.
This circumstance is illustrated with the following example that contains two rules, whereas already an annotation  of the type &#8220;LastToken&#8221; was added to the last token of the document:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>ANY LastToken;
ANY @LastToken;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The first rule matches on each token of the document and checks whether the next annotation is the last token of the document.
This will result in many index operations because all tokens of the document are considered.
The second rule, however, matches on the last token and then checks if there is any token in front of it.
This rule, therefore, considers only one token.</p>
</div>
<div class="paragraph">
<p>The UIMA Ruta language provides also a concept for automatically selecting the starting rule element called dynamic anchoring.
Here, a simple heuristic concerning the position of the rule element and the involved types is applied in order to identify the favorable rule element.
This functionality can be activated in the <a href="#_ugr.tools.ruta.ae.basic.parameter">configuration parameters</a> of the analysis engine or  directly in the script file with the <a href="#_ugr.tools.ruta.language.actions.dynamicanchoring">DYNAMICANCHORING</a> action.</p>
</div>
<div class="paragraph">
<p>A list of rule elements normally specifies a sequential pattern.
The rule is able to match if the first rule element successfully matches  and then the following rule element at the position after the match of the first rule element, and so on.
There are three language constructs that break up that sequential matching: <code>&amp;</code>, &#8220;|&#8221; and &#8220;%&#8221;.
A composed rule element where all inner rule elements are linked by the symbol <code>&amp;</code>
matches only if all inner rule elements successfully match at the given position.
A composed rule element with inner rule elements linked by the  symbol &#8220;|&#8221; matches if one of the inner rule element successfully matches.
These composed rule elements therefore specify a conjunction (&#8220;and&#8221;)  and a disjunction (&#8220;or&#8221;) of its rule element at the given position.
The symbol &#8220;%&#8221; specifies a different use case.
Here, rules themselves are linked and they are only able to fire if each one of the linked rules successfully matched.
In contrast to <code>&amp;</code>,  this linkage of rule elements does not introduce constraints for the matched positions.
In the following, a few examples of these three language constructs are given.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>(Token.posTag=="DET" &amp; Lemma.value=="the");</code></pre>
</div>
</div>
<div class="paragraph">
<p>This rule is fulfilled, if there is a token whose feature &#8220;posTag&#8221; has the value &#8220;DET&#8221; and an annotation of the type &#8220;Lemma&#8221; whose feature &#8220;value&#8221;  has the value &#8220;the&#8221;.
Both rule elements need to be fulfilled at the same position.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>NUM (W{REGEXP("Peter") -&gt; Name} &amp; (ANY CW{PARTOF(Name)}));</code></pre>
</div>
</div>
<div class="paragraph">
<p>This rule matches on a number and then validates if the next word is &#8220;Peter&#8221; and if next but one token is capitalized and part of an annotation of the type &#8220;Name&#8221;.
If all rule elements successfully matched, then a new annotation of the type &#8220;Name&#8221; will be created covering the largest match of the linked rule elements.
In this example, the new annotation covers also the token after the word &#8220;Peter&#8221; even if the actions was specified at the rule element with the smaller match.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>((W{REGEXP("Peter")} CW) | ("Mr" PERIOD CW)){-&gt; Name};</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this example, an annotation of the type &#8220;Name&#8221; will be created for the token &#8220;Peter&#8221; followed by a  capitalized word or the word &#8220;Mr&#8221; followed by a period and a capitalized word.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>(Animal ((COMMA | "and") Animal)+){-&gt; AnimalEnum};</code></pre>
</div>
</div>
<div class="paragraph">
<p>This rule annotates enumerations of animal annotations whereas each animal annotation is separated by either a comma or the word &#8220;and&#8221;.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>BLOCK(forEach) Sentence{}{
  CW NUM % SW NUM{-&gt; MARK(Found, 1, 2)};
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here, annotations of the type &#8220;Found&#8221; are created if a sentence contains a capitalized word followed by a number and a small written word followed by a number  regardless of where these annotations occur in the sentence.</p>
</div>
</div>
<div class="sect2">
<h3 id="_ugr.tools.ruta.language.seeding"><a class="anchor" href="#_ugr.tools.ruta.language.seeding"></a>2.3. Basic annotations and tokens</h3>
<div class="paragraph">
<p>The UIMA Ruta system uses a JFlex lexer to initially create a seed of basic token annotations.
These tokens build a hierarchy shown in <a href="#_figure.ugr.tools.ruta.language.seeding.basic_token">Figure 1</a>.
The &#8220;ALL&#8221; (green) annotation is the root of the hierarchy.
ALL and the red marked annotation types are abstract.
This means that they are actually not created by the lexer.
An overview of these abstract types can be found in <a href="#_table.ugr.tools.ruta.language.seeding.basic_token.abstract">Table 2</a>.
The leafs of the hierarchy (blue) are created by the lexer.
Each leaf is an own type, but also inherits the types of the abstract annotation types further up in the hierarchy.
The leaf types are described in more detail in <a href="#_table.ugr.tools.ruta.language.seeding.basic_token.created">Table 3</a>.
Each text unit within an input document belongs to exactly one of these annotation types.</p>
</div>
<div id="_figure.ugr.tools.ruta.language.seeding.basic_token" class="imageblock">
<div class="content">
<img src="./ruta/images/tools/ruta/language/basic_token/basic_token.png" alt="Basic token hierarchy.">
</div>
<div class="title">Figure 1. Basic token hierarchy</div>
</div>
<table id="_table.ugr.tools.ruta.language.seeding.basic_token.abstract" class="tableblock frame-all grid-all stretch">
<caption class="title">Table 2. Abstract annotations</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Annotation</th>
<th class="tableblock halign-left valign-top">Parent</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ALL</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">parent type of all tokens</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ANY</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ALL</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">all tokens except for markup</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">W</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ANY</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">all kinds of words</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">PM</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ANY</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">all kinds of punctuation marks</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">WS</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ANY</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">all kinds of white spaces</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SENTENCEEND</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">PM</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">all kinds of punctuation marks that indicate the end of a sentence</p></td>
</tr>
</tbody>
</table>
<table id="_table.ugr.tools.ruta.language.seeding.basic_token.created" class="tableblock frame-all grid-all stretch">
<caption class="title">Table 3. Annotations created by lexer</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Annotation</th>
<th class="tableblock halign-left valign-top">Parent</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">Example</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">MARKUP</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ALL</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">HTML and XML elements</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&lt;p class="Headline"&gt;</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">NBSP</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SPACE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">non breaking space</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">` `</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">AMP</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ANY</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ampersand expression</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&amp;</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">BREAK</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">WS</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">line break</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>\n</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SPACE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">WS</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">spaces</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">` `</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">COLON</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">PM</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">colon</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>:</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">COMMA</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">PM</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">comma</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>,</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">PERIOD</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SENTENCEEND</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">period</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>.</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">EXCLAMATION</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SENTENCEEND</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">exclamation mark</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>!</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SEMICOLON</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">PM</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">semicolon</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>;</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">QUESTION</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SENTENCEEND</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">question mark</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>?</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SW</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">W</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">lower case work</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>annotation</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">CW</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">W</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">work starting with one capitalized letter</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Annotation</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">CAP</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">W</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">word only containing capitalized letters</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ANNOTATION</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">NUM</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ANY</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">sequence of digits</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0123</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SPECIAL</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ANY</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">all other tokens and symbols</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>/</code></p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="_ugr.tools.ruta.language.quantifier"><a class="anchor" href="#_ugr.tools.ruta.language.quantifier"></a>2.4. Quantifiers</h3>
<div class="sect3">
<h4 id="_ugr.tools.ruta.language.quantifier.sg"><a class="anchor" href="#_ugr.tools.ruta.language.quantifier.sg"></a>2.4.1. * Star Greedy</h4>
<div class="paragraph">
<p>The Star Greedy quantifier matches on any amount of annotations and evaluates always true.
Please mind that a rule element with a Star Greedy quantifier needs to match on different annotations as the next rule element.
Examples:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>Input:    small Big Big Big small
Rule:     CW*
Matched:  Big Big Big
Matched:  Big Big
Matched:  Big</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.language.quantifier.sr"><a class="anchor" href="#_ugr.tools.ruta.language.quantifier.sr"></a>2.4.2. *? Star Reluctant</h4>
<div class="paragraph">
<p>The Star Reluctant quantifier matches on any amount of annotations and evaluates always true, but stops to match on new annotations, when the next rule element matches and evaluates true on this annotation.
Examples:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>Input:    123 456 small small Big
Rule:     W*? CW
Matched:  small small Big
Matched:  small Big
Matched:  Big</code></pre>
</div>
</div>
<div class="paragraph">
<p>The last match &#8220;Big&#8221; can be problematic using different types  if the rule starts matching with the first rule element.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.language.quantifier.pg"><a class="anchor" href="#_ugr.tools.ruta.language.quantifier.pg"></a>2.4.3. + Plus Greedy</h4>
<div class="paragraph">
<p>The Plus Greedy quantifier needs to match on at least one annotation.
Please mind that a rule element after a rule element with a Plus Greedy quantifier matches and evaluates on different conditions.
Examples:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>Input:    123 456 small small Big
Rule:     SW+
Matched:  small small
Matched:  small</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.language.quantifier.pr"><a class="anchor" href="#_ugr.tools.ruta.language.quantifier.pr"></a>2.4.4. +? Plus Reluctant</h4>
<div class="paragraph">
<p>The Plus Reluctant quantifier has to match on at least one annotation in order to evaluate true, but stops when the next rule element is able to match on this annotation.
Examples:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>Input:    123 456 small small Big
Rule:     W+? CW
Matched:  small small Big
Matched:  small Big</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.language.quantifier.qg"><a class="anchor" href="#_ugr.tools.ruta.language.quantifier.qg"></a>2.4.5. ? Question Greedy</h4>
<div class="paragraph">
<p>The Question Greedy quantifier matches optionally on an annotation and therefore always evaluates true.
Examples:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>Input:    123 456 small Big small Big
Rule:     SW CW? SW
Matched:  small Big small</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.language.quantifier.qr"><a class="anchor" href="#_ugr.tools.ruta.language.quantifier.qr"></a>2.4.6. ?? Question Reluctant</h4>
<div class="paragraph">
<p>The Question Reluctant quantifier matches optionally on an annotation, if the next rule element does not match on the same annotation and therefore always evaluates true.
Examples:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>Input:    123 456 small Big small Big
Rule:     SW CW?? SW
Matched:  small Big small</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.language.quantifier.mmg"><a class="anchor" href="#_ugr.tools.ruta.language.quantifier.mmg"></a>2.4.7. [x,y] Min Max Greedy</h4>
<div class="paragraph">
<p>The Min Max Greedy quantifier has to match at least x and at most y annotations of its rule element to evaluate true.
Examples:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>Input:    123 456 small Big small Big
Rule:     SW CW[1,2] SW
Matched:  small Big small</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.language.quantifier.mmr"><a class="anchor" href="#_ugr.tools.ruta.language.quantifier.mmr"></a>2.4.8. [x,y]? Min Max Reluctant</h4>
<div class="paragraph">
<p>The Min Max Greedy quantifier has to match at least x and at most y annotations of its rule element to evaluate true, but stops to match on additional annotations, if the next rule element is able to match on this annotation.
Examples:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>Input:    123 456 small Big Big Big small Big
Rule:     SW CW[2,100]? SW
Matched:  small Big Big Big small</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_ugr.tools.ruta.language.declarations"><a class="anchor" href="#_ugr.tools.ruta.language.declarations"></a>2.5. Declarations</h3>
<div class="paragraph">
<p>There are three different kinds of declarations in the UIMA Ruta system: Declarations of types with optional feature definitions, declarations of variables and declarations for importing external resources, further UIMA Ruta scripts and UIMA components such as type systems and analysis engines.</p>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.language.declarations.type"><a class="anchor" href="#_ugr.tools.ruta.language.declarations.type"></a>2.5.1. Types</h4>
<div class="paragraph">
<p>Type declarations define new kinds of annotation types and optionally their features.</p>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="highlight"><code>DECLARE SimpleType1, SimpleType2; // &lt;- two new types with the parent
                                  // type "Annotation"
DECLARE ParentType NewType (SomeType feature1, INT feature2);
  // a new type "NewType" with parent type "ParentType" and two features</code></pre>
</div>
</div>
<div class="paragraph">
<p>Attention: Types with features need a parent type in their declarations.
If no special parent type is requested, just use type Annotation as default parent type.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.language.declarations.variable"><a class="anchor" href="#_ugr.tools.ruta.language.declarations.variable"></a>2.5.2. Variables</h4>
<div class="paragraph">
<p>Variable declarations define new variables.
There are 12 kinds of variables:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Type variable: A variable that represents an annotation type.</p>
</li>
<li>
<p>Type list variable: A variable that represents a list of annotation types.</p>
</li>
<li>
<p>Integer variable: A variable that represents an integer.</p>
</li>
<li>
<p>Integer list variable: A variable that represents a list of integers.</p>
</li>
<li>
<p>Float variable: A variable that represents a floating-point number.</p>
</li>
<li>
<p>Float list variable: A variable that represents a list of floating-point numbers in single precision.</p>
</li>
<li>
<p>Double variable: A variable that represents a floating-point number.</p>
</li>
<li>
<p>Double list variable: A variable that represents a list of floating-point numbers in double precision.</p>
</li>
<li>
<p>String variable: A variable that represents a string.</p>
</li>
<li>
<p>String list: A variable that represents a list of strings.</p>
</li>
<li>
<p>Boolean variable: A variable that represents a boolean.</p>
</li>
<li>
<p>Boolean list variable: A variable that represents a list of booleans.</p>
</li>
<li>
<p>Annotation variable: A variable that represents an annotation.</p>
</li>
<li>
<p>Annotation list variable: A variable that represents a list of annotations.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="highlight"><code>TYPE newTypeVariable;
TYPELIST newTypeList;
INT newIntegerVariable;
INTLIST newIntList;
FLOAT newFloatVariable;
FLOATLIST newFloatList;
DOUBLE newDoubleVariable;
DOUBLELIST newDoubleList;
STRING newStringVariable;
STRINGLIST newStringList;
BOOLEAN newBooleanVariable;
BOOLEANLIST newBooleanList;
ANNOTATION newAnnotationVariable;
ANNOTATIONLIST newAnnotationList;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.language.declarations.ressource"><a class="anchor" href="#_ugr.tools.ruta.language.declarations.ressource"></a>2.5.3. Resources</h4>
<div class="paragraph">
<p>There are two kinds of resource declarations that make external resources available in the UIMA Ruta system:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>List: A list represents a normal text file with an entry per line or a compiled tree of a word list.</p>
</li>
<li>
<p>Table: A table represents a comma separated file.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="highlight"><code>WORDLIST listName = 'someWordList.txt';
WORDTABLE tableName = 'someTable.csv';</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.language.declarations.scripts"><a class="anchor" href="#_ugr.tools.ruta.language.declarations.scripts"></a>2.5.4. Scripts</h4>
<div class="paragraph">
<p>Additional scripts can be imported and reused with the CALL action.
The types of the imported rules are also available so that it is not necessary to import the Type System of the additional rule script.</p>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="highlight"><code>SCRIPT my.package.AnotherScript; // "AnotherScript.ruta" in the
                     //package "my.package"
Document{-&gt;CALL(AnotherScript)}; // &lt;- rule executes "AnotherScript.ruta"</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.language.declarations.components"><a class="anchor" href="#_ugr.tools.ruta.language.declarations.components"></a>2.5.5. Components</h4>
<div class="paragraph">
<p>There are three kinds of UIMA components that can be imported in a UIMA Ruta script:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Type System (IMPORT or TYPESYSTEM): includes the types defined in an external type system. You can select which types or packages to import from a type system and how to alias them. If use IMPORT statements, consider enabling <a href="#_ugr.tools.ruta.ae.basic.parameter.strictimports">strictImports</a>.</p>
</li>
<li>
<p>Analysis Engine (ENGINE): loads the given descriptor and creates an external analysis engine. The descriptor  must be located in the descriptor paths. The type system needed for the analysis engine has to be imported separately. Please mind the filtering setting when calling an external analysis engine.</p>
</li>
<li>
<p>Analysis Engine (UIMAFIT): loads the given class and creates an external analysis engine. Please mind that the implementation of the analysis engine needs to be available. The type system needed for the analysis engine has to be imported separately. Please mind the filtering setting when calling an external analysis engine.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Type System Example</div>
<div class="content">
<pre class="highlight"><code>// Imports all the types from "ExternalTypeSystem.xml"
TYPESYSTEM my.package.ExternalTypeSystem;
IMPORT * FROM my.package.ExternalTypeSystem;

// Import my.package.SomeType from "ExternalTypeSystem.xml"
IMPORT my.package.SomeType FROM my.package.ExternalTypeSystem;

// Import my.package.SomeType from the typesystem available to
// the CAS at runtime. This can be useful when typesystems are
// loaded by uimaFIT
IMPORT my.package.SomeType;

// Import my.package.SomeType from "ExternalTypeSystem.xml"
// and alias it to T1
IMPORT my.package.SomeType FROM my.package.ExternalTypeSystem AS T1;

// Import all types in my.package from "ExternalTypeSystem.xml"
IMPORT PACKAGE my.package FROM my.package.ExternalTypeSystem;

// Import package my.package from "ExternalTypeSystem.xml"
// and alias it to p1 (p1.SomeType can now be used)
IMPORT PACKAGE my.package FROM my.package.ExternalTypeSystem AS p1;

// Import all packages from "ExternalTypeSystem.xml" and alias them to p2
IMPORT PACKAGE * FROM my.package.ExternalTypeSystem AS p2;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Analysis Engine Example</div>
<div class="content">
<pre class="highlight"><code>ENGINE my.package.ExternalEngine; // &lt;- "ExternalEngine.xml" in the
// "my.package" package (in the descriptor folder)
UIMAFIT my.implementation.AnotherEngine;

Document{-&gt;RETAINTYPE(SPACE,BREAK),CALL(ExternalEngine)};
// calls ExternalEngine, but retains white spaces
Document{-&gt; EXEC(AnotherEngine, {SomeType})};</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_ugr.tools.ruta.language.expressions"><a class="anchor" href="#_ugr.tools.ruta.language.expressions"></a>2.6. Expressions</h3>
<div class="paragraph">
<p>UIMA Ruta provides six different kinds of expressions.
These are type expressions, annotations expressions, number expressions, string expressions, boolean expressions and list expressions.</p>
</div>
<div class="paragraph">
<p><strong>Definition:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>RutaExpression  -&gt;   TypeExpression | AnnotationExpression
                     | StringExpression | BooleanExpression
                     | NumberExpression | ListExpression</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.language.expressions.type"><a class="anchor" href="#_ugr.tools.ruta.language.expressions.type"></a>2.6.1. Type Expressions</h4>
<div class="paragraph">
<p>UIMA Ruta provides several kinds of type expressions.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><a href="#_ugr.tools.ruta.language.declarations.type">Section 2.5.1, &#8220;Types&#8221;</a></p>
</li>
<li>
<p><a href="#_ugr.tools.ruta.language.declarations.variable">Section 2.5.2, &#8220;Variables&#8221;</a></p>
</li>
<li>
<p><a href="#_ugr.tools.ruta.language.expressions.features">Section 2.6.7, &#8220;Feature Expressions&#8221;</a></p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="title">Definition</div>
<div class="content">
<pre class="highlight"><code>TypeExpression  -&gt;  AnnotationType | TypeVariable
                    | AnnotationExpression.type</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Examples</div>
<div class="content">
<pre class="highlight"><code>DECLARE Author;  // Author defines a type, therefore it is
                 // a type expression
TYPE typeVar;    // type variable typeVar is a type expression
Document{-&gt;ASSIGN(typeVar, Author)};</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>e:Entity{-&gt; e.type}; // the dot notation type refers to the type
          // of the anotation stored in the label a. In this example,
          // this type expression refers to the type Entity or a specific
          // subtype of Entity.</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.language.expressions.annotation"><a class="anchor" href="#_ugr.tools.ruta.language.expressions.annotation"></a>2.6.2. Annotation Expressions</h4>
<div class="paragraph">
<p>UIMA Ruta provides several kinds of annotation expressions.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><a href="#_ugr.tools.ruta.language.declarations.variable">Section 2.5.2, &#8220;Variables&#8221;</a></p>
</li>
<li>
<p><a href="#_ugr.tools.ruta.language.labels">Section 2.12, &#8220;Label expressions&#8221;</a></p>
</li>
<li>
<p><a href="#_ugr.tools.ruta.language.expressions.type">Section 2.6.1, &#8220;Type Expressions&#8221;</a></p>
</li>
<li>
<p><a href="#_ugr.tools.ruta.language.expressions.features">Section 2.6.7, &#8220;Feature Expressions&#8221;</a></p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="title">Definition</div>
<div class="content">
<pre class="highlight"><code>AnnotationExpression  -&gt;  AnnotationVariable | LabelExpression
                          | TypeExpression | FeatureExpression</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Examples</div>
<div class="content">
<pre class="highlight"><code>ANNOTATION anno; // a variable declaration for storing an annotation.
e:Entity; // label expression e stored the annotation matched by the
          // rule element with the matching condition Entity.
er:EmplRelation{-&gt; er.employer = Employer}; // the type expression
          // Employer implicitly refers to annotations of the
          // type Employer in the context of the EmplRelation match.
e:EmplRelation.employer; // this feature expression represents the
                         // annotation stored in the feature employer.</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.language.expressions.number"><a class="anchor" href="#_ugr.tools.ruta.language.expressions.number"></a>2.6.3. Number Expressions</h4>
<div class="paragraph">
<p>UIMA Ruta provides several possibilities to define number expressions.
As expected, every number expression evaluates to a number.
UIMA Ruta supports integer and floating-point numbers.
A floating-point number can be in single or in double precision.
To get a complete overview, have a look at the following syntax definition of number expressions.</p>
</div>
<div class="listingblock">
<div class="title">Definition</div>
<div class="content">
<pre class="highlight"><code>NumberExpression         -&gt; AdditiveExpression
AdditiveExpression       -&gt; MultiplicativeExpression ( ( "+" | "-" )
                            MultiplicativeExpression )*
MultiplicativeExpression -&gt; SimpleNumberExpression ( ( "*" | "/" | "%" )
                            SimpleNumberExpression )*
                            | ( "EXP" | "LOGN" | "SIN" | "COS" | "TAN" )
                            "(" NumberExpression ")"
SimpleNumberExpression   -&gt; "-"? ( DecimalLiteral | FloatingPointLiteral
                            | NumberVariable) | "(" NumberExpression ")"
DecimalLiteral        -&gt; ('0' | '1'..'9' Digit*) IntegerTypeSuffix?
IntegerTypeSuffix     -&gt;  ('l'|'L')
FloatingPointLiteral  -&gt; Digit+ '.' Digit* Exponent? FloatTypeSuffix?
                         |   '.' Digit+ Exponent? FloatTypeSuffix?
                         |   Digit+ Exponent FloatTypeSuffix?
                         |   Digit+ Exponent? FloatTypeSuffix
FloatTypeSuffix       -&gt;  ('f'|'F'|'d'|'D')
Exponent              -&gt; ('e'|'E') ('+'|'-')? Digit+
Digit                 -&gt; ('0'..'9')</code></pre>
</div>
</div>
<div class="paragraph">
<p>For more information on number variables, see <a href="#_ugr.tools.ruta.language.declarations.variable">Section 2.5.2</a> .</p>
</div>
<div class="listingblock">
<div class="title">Examples</div>
<div class="content">
<pre class="highlight"><code>98     // a integer number literal
104   // a integer number literal
170.02   // a floating-point number literal
1.0845 // a floating-point number literal</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>INT intVar1;
INT intVar2;
...
Document{-&gt;ASSIGN(intVar1, 12 * intVar1 - SIN(intVar2))};</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.language.expressions.string"><a class="anchor" href="#_ugr.tools.ruta.language.expressions.string"></a>2.6.4. String Expressions</h4>
<div class="paragraph">
<p>There are two kinds of string expressions in UIMA Ruta.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>String literals: String literals are defined by any sequence of characters within quotation marks.</p>
</li>
<li>
<p>String variables (see <a href="#_ugr.tools.ruta.language.declarations.variable">Section 2.5.2</a> )</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="title">Definition</div>
<div class="content">
<pre class="highlight"><code>StringExpression   -&gt;   SimpleStringExpression
SimpleStringExpression  -&gt;  StringLiteral ("+" StringExpression)*
                            | StringVariable</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="highlight"><code>STRING strVar; // define string variable
// add prefix "strLiteral" to variable strVar
Document{-&gt;ASSIGN(strVar, "strLiteral" + strVar)};</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.language.expressions.boolean"><a class="anchor" href="#_ugr.tools.ruta.language.expressions.boolean"></a>2.6.5. Boolean Expressions</h4>
<div class="paragraph">
<p>UIMA Ruta provides several possibilities to define boolean expressions.
As expected, every boolean expression evaluates to either true or false.
To get a complete overview, have a look at the following syntax definition of boolean expressions.</p>
</div>
<div class="listingblock">
<div class="title">Definition</div>
<div class="content">
<pre class="highlight"><code>BooleanExpression          -&gt;  ComposedBooleanExpression
                               | SimpleBooleanExpression
ComposedBooleanExpression  -&gt;  BooleanCompare | BooleanTypeExpression
                               | BooleanNumberExpression | BooleanFunction
SimpleBooleanExpression     -&gt;  BooleanLiteral | BooleanVariable
BooleanCompare           -&gt;  SimpleBooleanExpression ( "==" | "!=" )
                               BooleanExpression
BooleanTypeExpression    -&gt;  TypeExpression ( "==" | "!=" ) TypeExpression
BooleanNumberExpression  -&gt;  "(" NumberExpression ( "&lt;" | "&lt;=" | "&gt;"
                               | "&gt;=" | "==" | "!=" ) NumberExpression ")"
BooleanFunction   -&gt;  XOR "(" BooleanExpression "," BooleanExpression ")"
BooleanLiteral    -&gt;  "true" | "false"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Boolean variables are defined in <a href="#_ugr.tools.ruta.language.declarations.variable">Section 2.5.2</a> .</p>
</div>
<div class="listingblock">
<div class="title">Examples</div>
<div class="content">
<pre class="highlight"><code>Document{-&gt;ASSIGN(boolVar, false)};</code></pre>
</div>
</div>
<div class="paragraph">
<p>The boolean literal 'false' is assigned to boolean variable boolVar.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>Document{-&gt;ASSIGN(boolVar, typeVar == Author)};</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the type variable typeVar represents annotation type Author, the boolean type expression evaluates to true, otherwise it evaluates to false.
The result is assigned to boolean variable boolVar.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>Document{-&gt;ASSIGN(boolVar, (intVar == 10))};</code></pre>
</div>
</div>
<div class="paragraph">
<p>This rule shows a boolean number expression.
If the value in variable intVar is equal to 10, the boolean number expression evaluates to true, otherwise it evaluates to false.
The result is assigned to boolean variable boolVar.
The brackets surrounding the number expression are necessary.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>Document{-&gt;ASSIGN(booleanVar1, booleanVar2 == (10 &gt; intVar))};</code></pre>
</div>
</div>
<div class="paragraph">
<p>This rule shows a more complex boolean expression.
If the value in variable intVar is equal to 10, the boolean number expression evaluates to true, otherwise it evaluates to false.
The result of this evaluation is compared to booleanVar2.
The end result is assigned to boolean variable boolVar1.
Realize that the syntax definition defines exactly this order.
It is not possible to have the boolean number expression on the left side of the complex number expression.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.language.expressions.lists"><a class="anchor" href="#_ugr.tools.ruta.language.expressions.lists"></a>2.6.6. List Expressions</h4>
<div class="paragraph">
<p>List expression are a rather simple kind of expression.</p>
</div>
<div class="listingblock">
<div class="title">Definition</div>
<div class="content">
<pre class="highlight"><code>ListExpression  -&gt;   WordListExpression | WordTableExpression
                     | TypeListExpression | AnnotationListExpression
                     | NumberListExpression | StringListExpression
                     | BooleanListExpression
WordListExpression     -&gt;  RessourceLiteral | WordListVariable
WordTableExpression    -&gt;  RessourceLiteral | WordTableVariable
TypeListExpression     -&gt;  TypeListVariable
                           | "{" TypeExpression ("," TypeExpression)* "}"
NumberListExpression   -&gt;  IntListVariable | FloatListVariable
                           | DoubleListVariable
                           | "{" NumberExpression
                              ("," NumberExpression)* "}"
StringListExpression   -&gt;  StringListVariable
                           | "{" StringExpression
                              ("," StringExpression)* "}"
BooleanListExpression  -&gt;  BooleanListVariable
                           | "{" BooleanExpression
                              ("," BooleanExpression)* "}"
AnnotationListExpression  -&gt;  AnnotationListVariable
                           | "{" AnnotationExpression
                              ("," AnnotationExpression)* "}"</code></pre>
</div>
</div>
<div class="paragraph">
<p>A ResourceLiteral is something like 'folder/file.txt' (Attention: Use single quotes).</p>
</div>
<div class="paragraph">
<p>List variables are defined in <a href="#_ugr.tools.ruta.language.declarations.variable">Section 2.5.2</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.language.expressions.features"><a class="anchor" href="#_ugr.tools.ruta.language.expressions.features"></a>2.6.7. Feature Expressions</h4>
<div class="paragraph">
<p>Feature expression can be used in different situations, e.g., for restricting the match of a rule element,  as an implicit condition or as an implicit action.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>FeatureExpression           -&gt; TypeExpression "." DottedIdentifier
FeatureMatchExpression      -&gt; FeatureExpression
                               ("==" | "!=" | "&lt;=" | "&lt;" | "&gt;=" | "&gt;")
                               Expression
FeatureAssignmentExpression -&gt; FeatureExpression "=" Expression</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ruta allows the access of two special attributes of an annotation with the feature notation: The covered text of an annotation can be accessed as a string expression and the type of  an annotation can be accessed as an type expression.</p>
</div>
<div class="paragraph">
<p>The covered text of an annotation can be referred to with "coveredText" or "ct".  The latter one is an abbreviation and returns the covered text of an annotation only if the type of the annotation does not define a feature with the name "ct".  The following example creates an annotation of the type TypeA for each word with the  covered text "A".</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>W.ct == "A" {-&gt; TypeA};</code></pre>
</div>
</div>
<div class="paragraph">
<p>The type of an annotation can be referred to with "type".  The following example creates an annotation of the type TypeA for each pair of ANY annotation.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>(a1:ANY a2:ANY){a1.type == a2.type -&gt; TypeA};</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_ugr.tools.ruta.language.conditions"><a class="anchor" href="#_ugr.tools.ruta.language.conditions"></a>2.7. Conditions</h3>
<div class="sect3">
<h4 id="_ugr.tools.ruta.language.conditions.after"><a class="anchor" href="#_ugr.tools.ruta.language.conditions.after"></a>2.7.1. AFTER</h4>
<div class="paragraph">
<p>The AFTER condition evaluates true, if the matched annotation starts after the beginning of an arbitrary annotation of the passed type.
If a list of types is passed, this has to be true for at least one of them.</p>
</div>
<div class="listingblock">
<div class="title">Definition</div>
<div class="content">
<pre class="highlight"><code>AFTER(Type|TypeListExpression)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="highlight"><code>CW{AFTER(SW)};</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here, the rule matches on a capitalized word, if there is any small written word previously.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.language.conditions.and"><a class="anchor" href="#_ugr.tools.ruta.language.conditions.and"></a>2.7.2. AND</h4>
<div class="paragraph">
<p>The AND condition is a composed condition and evaluates true, if all contained conditions evaluate true.</p>
</div>
<div class="listingblock">
<div class="title">Definition</div>
<div class="content">
<pre class="highlight"><code>AND(Condition1,...,ConditionN)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="highlight"><code>Paragraph{AND(PARTOF(Headline),CONTAINS(Keyword))
          -&gt;MARK(ImportantHeadline)};</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this example, a paragraph is annotated with an ImportantHeadline annotation, if it is part of a Headline and contains a Keyword annotation.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.language.conditions.before"><a class="anchor" href="#_ugr.tools.ruta.language.conditions.before"></a>2.7.3. BEFORE</h4>
<div class="paragraph">
<p>The BEFORE condition evaluates true, if the matched annotation starts before the beginning of an arbitrary annotation of the passed type.
If a list of types is passed, this has to be true for at least one of them.</p>
</div>
<div class="listingblock">
<div class="title">Definition</div>
<div class="content">
<pre class="highlight"><code>BEFORE(Type|TypeListExpression)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="highlight"><code>CW{BEFORE(SW)};</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here, the rule matches on a capitalized word, if there is any small written word afterwards.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.language.conditions.contains"><a class="anchor" href="#_ugr.tools.ruta.language.conditions.contains"></a>2.7.4. CONTAINS</h4>
<div class="paragraph">
<p>The CONTAINS condition evaluates true on a matched annotation, if the frequency of the passed type lies within an optionally passed interval.
The limits of the passed interval are per default interpreted as absolute numeral values.
By passing a further boolean parameter set to true the limits are interpreted as percental values.
If no interval parameters are passed at all, then the condition checks whether the matched annotation contains at least one occurrence of the passed type.</p>
</div>
<div class="listingblock">
<div class="title">Definition</div>
<div class="content">
<pre class="highlight"><code>CONTAINS(Type(,NumberExpression,NumberExpression(,BooleanExpression)?)?)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="highlight"><code>Paragraph{CONTAINS(Keyword)-&gt;MARK(KeywordParagraph)};</code></pre>
</div>
</div>
<div class="paragraph">
<p>A Paragraph is annotated with a KeywordParagraph annotation, if it contains a Keyword annotation.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>Paragraph{CONTAINS(Keyword,2,4)-&gt;MARK(KeywordParagraph)};</code></pre>
</div>
</div>
<div class="paragraph">
<p>A Paragraph is annotated with a KeywordParagraph annotation, if it contains between two and four Keyword annotations.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>Paragraph{CONTAINS(Keyword,50,100,true)-&gt;MARK(KeywordParagraph)};</code></pre>
</div>
</div>
<div class="paragraph">
<p>A Paragraph is annotated with a KeywordParagraph annotation, if it contains between 50% and 100% Keyword annotations.
This is calculated based on the tokens of the Paragraph.
If the Paragraph contains six basic annotations (see <a href="#_ugr.tools.ruta.language.seeding">Section 2.3</a>), two of them are part of one Keyword annotation, and if one basic annotation is also annotated with a Keyword annotation, then the percentage of the contained Keywords is 50%.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.language.conditions.contextcount"><a class="anchor" href="#_ugr.tools.ruta.language.conditions.contextcount"></a>2.7.5. CONTEXTCOUNT</h4>
<div class="paragraph">
<p>The CONTEXTCOUNT condition numbers all occurrences of the matched type within the context of a passed type&#8217;s annotation consecutively, thus assigning an index to each occurrence.
Additionally it stores the index of the matched annotation in a numerical variable if one is passed.
The condition evaluates true if the index of the matched annotation is within a passed interval.
If no interval is passed, the condition always evaluates true.</p>
</div>
<div class="listingblock">
<div class="title">Definition</div>
<div class="content">
<pre class="highlight"><code>CONTEXTCOUNT(Type(,NumberExpression,NumberExpression)?(,Variable)?)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="highlight"><code>Keyword{CONTEXTCOUNT(Paragraph,2,3,var)
          -&gt;MARK(SecondOrThirdKeywordInParagraph)};</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here, the position of the matched Keyword annotation within a Paragraph annotation is calculated and stored in the variable 'var'. If the counted value lies within the interval [2,3], then the matched Keyword is annotated with the SecondOrThirdKeywordInParagraph annotation.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.language.conditions.count"><a class="anchor" href="#_ugr.tools.ruta.language.conditions.count"></a>2.7.6. COUNT</h4>
<div class="paragraph">
<p>The COUNT condition can be used in two different ways.
In the first case (see first definition), it counts the number of annotations of the passed type within the window of the matched annotation and stores the amount in a numerical variable, if such a variable is passed.
The condition evaluates true if the counted amount is within a specified interval.
If no interval is passed, the condition always evaluates true.
In the second case (see second definition), it counts the number of occurrences of the passed VariableExpression (second parameter) within the passed list (first parameter) and stores the amount in a numerical variable, if such a variable is passed.
Again, the condition evaluates true if the counted amount is within a specified interval.
If no interval is passed, the condition always evaluates true.</p>
</div>
<div class="listingblock">
<div class="title">Definition</div>
<div class="content">
<pre class="highlight"><code>COUNT(Type(,NumberExpression,NumberExpression)?(,NumberVariable)?)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>COUNT(ListExpression,VariableExpression
          (,NumberExpression,NumberExpression)?(,NumberVariable)?)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="highlight"><code>Paragraph{COUNT(Keyword,1,10,var)-&gt;MARK(KeywordParagraph)};</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here, the amount of Keyword annotations within a Paragraph is calculated and stored in the variable 'var'. If one to ten Keywords were counted, the paragraph is marked with a KeywordParagraph annotation.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>Paragraph{COUNT(list,"author",5,7,var)};</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here, the number of occurrences of STRING "author" within the STRINGLIST 'list' is counted and stored in the variable 'var'. If "author" occurs five to seven times within 'list', the condition evaluates true.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.language.conditions.currentcount"><a class="anchor" href="#_ugr.tools.ruta.language.conditions.currentcount"></a>2.7.7. CURRENTCOUNT</h4>
<div class="paragraph">
<p>The CURRENTCOUNT condition numbers all occurrences of the matched type within the whole document consecutively, thus assigning an index to each occurrence.
Additionally, it stores the index of the matched annotation in a numerical variable, if one is passed.
The condition evaluates true if the index of the matched annotation is within a specified interval.
If no interval is passed, the condition always evaluates true.</p>
</div>
<div class="listingblock">
<div class="title">Definition</div>
<div class="content">
<pre class="highlight"><code>CURRENTCOUNT(Type(,NumberExpression,NumberExpression)?(,Variable)?)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="highlight"><code>Paragraph{CURRENTCOUNT(Keyword,3,3,var)-&gt;MARK(ParagraphWithThirdKeyword)};</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here, the Paragraph, which contains the third Keyword of the whole document, is annotated with the ParagraphWithThirdKeyword annotation.
The index is stored in the variable 'var'.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.language.conditions.endswith"><a class="anchor" href="#_ugr.tools.ruta.language.conditions.endswith"></a>2.7.8. ENDSWITH</h4>
<div class="paragraph">
<p>The ENDSWITH condition evaluates true, if an annotation of the given type ends exactly at the same position as the matched annotation.
If a list of types is passed, this has to be true for at least one of them.</p>
</div>
<div class="listingblock">
<div class="title">Definition</div>
<div class="content">
<pre class="highlight"><code>ENDSWITH(Type|TypeListExpression)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="highlight"><code>Paragraph{ENDSWITH(SW)};</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here, the rule matches on a Paragraph annotation, if it ends with a small written word.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.language.conditions.feature"><a class="anchor" href="#_ugr.tools.ruta.language.conditions.feature"></a>2.7.9. FEATURE</h4>
<div class="paragraph">
<p>The FEATURE condition compares a feature of the matched annotation with the second argument.</p>
</div>
<div class="listingblock">
<div class="title">Definition</div>
<div class="content">
<pre class="highlight"><code>FEATURE(StringExpression,Expression)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="highlight"><code>Document{FEATURE("language",targetLanguage)}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This rule matches, if the feature named 'language' of the document annotation equals the value of the variable 'targetLanguage'.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.language.conditions.if"><a class="anchor" href="#_ugr.tools.ruta.language.conditions.if"></a>2.7.10. IF</h4>
<div class="paragraph">
<p>The IF condition evaluates true, if the contained boolean expression evaluates true.</p>
</div>
<div class="listingblock">
<div class="title">Definition</div>
<div class="content">
<pre class="highlight"><code>IF(BooleanExpression)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="highlight"><code>Paragraph{IF(keywordAmount &gt; 5)-&gt;MARK(KeywordParagraph)};</code></pre>
</div>
</div>
<div class="paragraph">
<p>A Paragraph annotation is annotated with a KeywordParagraph annotation, if the value of the variable 'keywordAmount' is greater than five.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.language.conditions.inlist"><a class="anchor" href="#_ugr.tools.ruta.language.conditions.inlist"></a>2.7.11. INLIST</h4>
<div class="paragraph">
<p>The INLIST condition is fulfilled, if the matched annotation is listed in a given word or string list.
If an optional agrument is given, then  the value of the argument is used instead of the covered text of the matched annotation</p>
</div>
<div class="listingblock">
<div class="title">Definition</div>
<div class="content">
<pre class="highlight"><code>INLIST(WordList(,StringExpression)?)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>INLIST(StringList(,StringExpression)?)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="highlight"><code>Keyword{INLIST(SpecialKeywordList)-&gt;MARK(SpecialKeyword)};</code></pre>
</div>
</div>
<div class="paragraph">
<p>A Keyword is annotated with the type SpecialKeyword, if the text of the Keyword annotation is listed in the word list or string list SpecialKeywordList.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>Token{INLIST(MyLemmaList, Token.lemma)-&gt;MARK(SpecialLemma)};</code></pre>
</div>
</div>
<div class="paragraph">
<p>This rule creates an annotation of the type SpecialLemma for each token that provides a feature value  of the feature "lemma" that is present in the string list or word list MyLemmaList.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.language.conditions.is"><a class="anchor" href="#_ugr.tools.ruta.language.conditions.is"></a>2.7.12. IS</h4>
<div class="paragraph">
<p>The IS condition evaluates true, if there is an annotation of the given type with the same beginning and ending offsets as the matched annotation.
If a list of types is given, the condition evaluates true, if at least one of them fulfills the former condition.</p>
</div>
<div class="listingblock">
<div class="title">Definition</div>
<div class="content">
<pre class="highlight"><code>IS(Type|TypeListExpression)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="highlight"><code>Author{IS(Englishman)-&gt;MARK(EnglishAuthor)};</code></pre>
</div>
</div>
<div class="paragraph">
<p>If an Author annotation is also annotated with an Englishman annotation, it is annotated with an EnglishAuthor annotation.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.language.conditions.last"><a class="anchor" href="#_ugr.tools.ruta.language.conditions.last"></a>2.7.13. LAST</h4>
<div class="paragraph">
<p>The LAST condition evaluates true, if the type of the last token within the window of the matched annotation is of the given type.</p>
</div>
<div class="listingblock">
<div class="title">Definition</div>
<div class="content">
<pre class="highlight"><code>LAST(TypeExpression)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="highlight"><code>Document{LAST(CW)};</code></pre>
</div>
</div>
<div class="paragraph">
<p>This rule fires, if the last token of the document is a capitalized word.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.language.conditions.mofn"><a class="anchor" href="#_ugr.tools.ruta.language.conditions.mofn"></a>2.7.14. MOFN</h4>
<div class="paragraph">
<p>The MOFN condition is a composed condition.
It evaluates true if the number of containing conditions evaluating true is within a given interval.</p>
</div>
<div class="listingblock">
<div class="title">Definition</div>
<div class="content">
<pre class="highlight"><code>MOFN(NumberExpression,NumberExpression,Condition1,...,ConditionN)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="highlight"><code>Paragraph{MOFN(1,1,PARTOF(Headline),CONTAINS(Keyword))
          -&gt;MARK(HeadlineXORKeywords)};</code></pre>
</div>
</div>
<div class="paragraph">
<p>A Paragraph is marked as a HeadlineXORKeywords, if the matched text is either part of a Headline annotation or contains Keyword annotations.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.language.conditions.near"><a class="anchor" href="#_ugr.tools.ruta.language.conditions.near"></a>2.7.15. NEAR</h4>
<div class="paragraph">
<p>The NEAR condition is fulfilled, if the distance of the matched annotation to an annotation of the given type is within a given interval.
The direction is defined by a boolean parameter, whose default value is set to true, therefore searching forward.
By default this condition works on an unfiltered index.
An optional fifth boolean parameter can be set to true to get the condition being evaluated on a filtered index.</p>
</div>
<div class="listingblock">
<div class="title">Definition</div>
<div class="content">
<pre class="highlight"><code>NEAR(TypeExpression,NumberExpression,NumberExpression
          (,BooleanExpression(,BooleanExpression)?)?)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="highlight"><code>Paragraph{NEAR(Headline,0,10,false)-&gt;MARK(NoHeadline)};</code></pre>
</div>
</div>
<div class="paragraph">
<p>A Paragraph that starts at most ten tokens after a Headline annotation is annotated with the NoHeadline annotation.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.language.conditions.not"><a class="anchor" href="#_ugr.tools.ruta.language.conditions.not"></a>2.7.16. NOT</h4>
<div class="paragraph">
<p>The NOT condition negates the result of its contained condition.</p>
</div>
<div class="listingblock">
<div class="title">Definition</div>
<div class="content">
<pre class="highlight"><code>"-"Condition</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="highlight"><code>Paragraph{-PARTOF(Headline)-&gt;MARK(Headline)};</code></pre>
</div>
</div>
<div class="paragraph">
<p>A Paragraph that is not part of a Headline annotation so far is annotated with a Headline annotation.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.language.conditions.or"><a class="anchor" href="#_ugr.tools.ruta.language.conditions.or"></a>2.7.17. OR</h4>
<div class="paragraph">
<p>The OR Condition is a composed condition and evaluates true, if at least one contained condition is evaluated true.</p>
</div>
<div class="listingblock">
<div class="title">Definition</div>
<div class="content">
<pre class="highlight"><code>OR(Condition1,...,ConditionN)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="highlight"><code>Paragraph{OR(PARTOF(Headline),CONTAINS(Keyword))
                                           -&gt;MARK(ImportantParagraph)};</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this example a Paragraph is annotated with the ImportantParagraph annotation, if it is a Headline or contains Keyword annotations.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.language.conditions.parse"><a class="anchor" href="#_ugr.tools.ruta.language.conditions.parse"></a>2.7.18. PARSE</h4>
<div class="paragraph">
<p>The PARSE condition is fulfilled, if the text covered by the matched annotation or the text defined by a optional first argument can be transformed into a value of the given variable&#8217;s type.
If this is possible, the parsed value is additionally assigned to the passed variable.
For numeric values, this conditions delegates to the NumberFormat of the locale given by the optional last argument.
Therefore, this condition parses the string &#8220;2,3&#8221; for the locale &#8220;en&#8221; to the value 23.</p>
</div>
<div class="listingblock">
<div class="title">Definition</div>
<div class="content">
<pre class="highlight"><code>PARSE((stringExpression,)? variable(, stringExpression)?)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="highlight"><code>NUM{PARSE(var,"de")};
n:NUM{PARSE(n.ct,var,"de")};</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the variable 'var' is of an appropriate numeric type for the locale "de", the value of NUM is parsed and subsequently stored in 'var'.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.language.conditions.partof"><a class="anchor" href="#_ugr.tools.ruta.language.conditions.partof"></a>2.7.19. PARTOF</h4>
<div class="paragraph">
<p>The PARTOF condition is fulfilled, if the matched annotation is part of an annotation of the given type.
However, it is not necessary that the matched annotation is smaller than the annotation of the given type.
Use the (much slower) PARTOFNEQ condition instead, if this is needed.
If a type list is given, the condition evaluates true, if the former described condition for a single type is fulfilled for at least one of the types in the list.</p>
</div>
<div class="listingblock">
<div class="title">Definition</div>
<div class="content">
<pre class="highlight"><code>PARTOF(Type|TypeListExpression)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="highlight"><code>Paragraph{PARTOF(Headline) -&gt; MARK(ImportantParagraph)};</code></pre>
</div>
</div>
<div class="paragraph">
<p>A Paragraph is an ImportantParagraph, if the matched text is part of a Headline annotation.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.language.conditions.partofneq"><a class="anchor" href="#_ugr.tools.ruta.language.conditions.partofneq"></a>2.7.20. PARTOFNEQ</h4>
<div class="paragraph">
<p>The PARTOFNEQ condition is fulfilled if the matched annotation is part of (smaller than and inside of) an annotation of the given type.
If also annotations of the same size should be acceptable, use the PARTOF condition.
If a type list is given, the condition evaluates true if the former described condition is fulfilled for at least one of the types in the list.</p>
</div>
<div class="listingblock">
<div class="title">Definition</div>
<div class="content">
<pre class="highlight"><code>PARTOFNEQ(Type|TypeListExpression)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="highlight"><code>W{PARTOFNEQ(Headline) -&gt; MARK(ImportantWord)};</code></pre>
</div>
</div>
<div class="paragraph">
<p>A word is an &#8220;ImportantWord&#8221;, if it is part of a headline.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.language.conditions.position"><a class="anchor" href="#_ugr.tools.ruta.language.conditions.position"></a>2.7.21. POSITION</h4>
<div class="paragraph">
<p>The POSITION condition is fulfilled, if the matched type is the k-th occurrence of this type within the window of an annotation of the passed type, whereby k is defined by the value of the passed NumberExpression.
If the additional boolean paramter is set to false, then k counts the occurrences of of the minimal annotations.</p>
</div>
<div class="listingblock">
<div class="title">Definition</div>
<div class="content">
<pre class="highlight"><code>POSITION(Type,NumberExpression(,BooleanExpression)?)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="highlight"><code>Keyword{POSITION(Paragraph,2)-&gt;MARK(SecondKeyword)};</code></pre>
</div>
</div>
<div class="paragraph">
<p>The second Keyword in a Paragraph is annotated with the type SecondKeyword.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>Keyword{POSITION(Paragraph,2,false)-&gt;MARK(SecondKeyword)};</code></pre>
</div>
</div>
<div class="paragraph">
<p>A Keyword in a Paragraph is annotated with the type SecondKeyword, if it starts at the same offset as the second (visible) RutaBasic annotation, which normally corresponds to the tokens.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.language.conditions.regexp"><a class="anchor" href="#_ugr.tools.ruta.language.conditions.regexp"></a>2.7.22. REGEXP</h4>
<div class="paragraph">
<p>The REGEXP condition is fulfilled, if the given pattern matches on the matched annotation.
However, if a string variable is given as the first argument, then the pattern is evaluated on the value of the variable.
For more details on the syntax of regular expressions, take a look at the <a href="http://docs.oracle.com/javase/1.4.2/docs/api/java/util/regex/Pattern.html">Java API</a>. By default the REGEXP condition is case-sensitive.
To change this, add an optional boolean parameter, which is set to true.
The regular expression is  initialized with the flags DOTALL and MULTILINE, and if the optional parameter is set to true,  then additionally with the flags CASE_INSENSITIVE and UNICODE_CASE.</p>
</div>
<div class="listingblock">
<div class="title">Definition</div>
<div class="content">
<pre class="highlight"><code>REGEXP((StringVariable,)? StringExpression(,BooleanExpression)?)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="highlight"><code>Keyword{REGEXP("..")-&gt;MARK(SmallKeyword)};</code></pre>
</div>
</div>
<div class="paragraph">
<p>A Keyword that only consists of two chars is annotated with a SmallKeyword annotation.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.language.conditions.score"><a class="anchor" href="#_ugr.tools.ruta.language.conditions.score"></a>2.7.23. SCORE</h4>
<div class="paragraph">
<p>The SCORE condition evaluates the heuristic score of the matched annotation.
This score is set or changed by the MARK action.
The condition is fulfilled, if the score of the matched annotation is in a given interval.
Optionally, the score can be stored in a variable.</p>
</div>
<div class="listingblock">
<div class="title">Definition</div>
<div class="content">
<pre class="highlight"><code>SCORE(NumberExpression,NumberExpression(,Variable)?)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="highlight"><code>MaybeHeadline{SCORE(40,100)-&gt;MARK(Headline)};</code></pre>
</div>
</div>
<div class="paragraph">
<p>An annotation of the type MaybeHeadline is annotated with Headline, if its score is between 40 and 100.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.language.conditions.size"><a class="anchor" href="#_ugr.tools.ruta.language.conditions.size"></a>2.7.24. SIZE</h4>
<div class="paragraph">
<p>The SIZE contition counts the number of elements in the given list.
By default, this condition always evaluates true.
When an interval is passed, it evaluates true, if the counted number of list elements is within the interval.
The counted number can be stored in an optionally passed numeral variable.</p>
</div>
<div class="listingblock">
<div class="title">Definition</div>
<div class="content">
<pre class="highlight"><code>SIZE(ListExpression(,NumberExpression,NumberExpression)?(,Variable)?)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="highlight"><code>Document{SIZE(list,4,10,var)};</code></pre>
</div>
</div>
<div class="paragraph">
<p>This rule fires, if the given list contains between 4 and 10 elements.
Additionally, the exact amount is stored in the variable &#8220;var&#8221;.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.language.conditions.startswith"><a class="anchor" href="#_ugr.tools.ruta.language.conditions.startswith"></a>2.7.25. STARTSWITH</h4>
<div class="paragraph">
<p>The STARTSWITH condition evaluates true, if an annotation of the given type starts exactly at the same position as the matched annotation.
If a type list is given, the condition evaluates true, if the former is true for at least one of the given types in the list.</p>
</div>
<div class="listingblock">
<div class="title">Definition</div>
<div class="content">
<pre class="highlight"><code>STARTSWITH(Type|TypeListExpression)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="highlight"><code>Paragraph{STARTSWITH(SW)};</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here, the rule matches on a Paragraph annotation, if it starts with small written word.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.language.conditions.totalcount"><a class="anchor" href="#_ugr.tools.ruta.language.conditions.totalcount"></a>2.7.26. TOTALCOUNT</h4>
<div class="paragraph">
<p>The TOTALCOUNT condition counts the annotations of the passed type within the whole document and stores the amount in an optionally passed numerical variable.
The condition evaluates true, if the amount is within the passed interval.
If no interval is passed, the condition always evaluates true.</p>
</div>
<div class="listingblock">
<div class="title">Definition</div>
<div class="content">
<pre class="highlight"><code>TOTALCOUNT(Type(,NumberExpression,NumberExpression)?(,NumberVariable)?)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="highlight"><code>Paragraph{TOTALCOUNT(Keyword,1,10,var)-&gt;MARK(KeywordParagraph)};</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here, the amount of Keyword annotations within the whole document is calculated and stored in the variable 'var'. If one to ten Keywords were counted, the Paragraph is marked with a KeywordParagraph annotation.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.language.conditions.vote"><a class="anchor" href="#_ugr.tools.ruta.language.conditions.vote"></a>2.7.27. VOTE</h4>
<div class="paragraph">
<p>The VOTE condition counts the annotations of the given two types within the window of the matched annotation and evaluates true, if it finds more annotations of the first type.</p>
</div>
<div class="listingblock">
<div class="title">Definition</div>
<div class="content">
<pre class="highlight"><code>VOTE(TypeExpression,TypeExpression)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="highlight"><code>Paragraph{VOTE(FirstName,LastName)};</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here, this rule fires, if a paragraph contains more firstnames than lastnames.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_ugr.tools.ruta.language.actions"><a class="anchor" href="#_ugr.tools.ruta.language.actions"></a>2.8. Actions</h3>
<div class="sect3">
<h4 id="_ugr.tools.ruta.language.actions.add"><a class="anchor" href="#_ugr.tools.ruta.language.actions.add"></a>2.8.1. ADD</h4>
<div class="paragraph">
<p>The ADD action adds all the elements of the passed RutaExpressions to a given list.
For example, this expressions could be a string, an integer variable or a list.
For a complete overview on UIMA Ruta expressions see <a href="#_ugr.tools.ruta.language.expressions">Section 2.6</a>.</p>
</div>
<div class="listingblock">
<div class="title">Definition</div>
<div class="content">
<pre class="highlight"><code>ADD(ListVariable,(RutaExpression)+)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="highlight"><code>Document{-&gt;ADD(list, var)};</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this example, the variable 'var' is added to the list 'list'.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.language.actions.addfiltertype"><a class="anchor" href="#_ugr.tools.ruta.language.actions.addfiltertype"></a>2.8.2. ADDFILTERTYPE</h4>
<div class="paragraph">
<p>The ADDFILTERTYPE action adds its arguments to the list of filtered types,  which restrict the visibility of the rules.</p>
</div>
<div class="listingblock">
<div class="title">Definition</div>
<div class="content">
<pre class="highlight"><code>ADDFILTERTYPE(TypeExpression(,TypeExpression)*)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="highlight"><code>Document{-&gt;ADDFILTERTYPE(CW)};</code></pre>
</div>
</div>
<div class="paragraph">
<p>After applying this rule, capitalized words are invisible additionally to the previously filtered types.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.language.actions.addretaintype"><a class="anchor" href="#_ugr.tools.ruta.language.actions.addretaintype"></a>2.8.3. ADDRETAINTYPE</h4>
<div class="paragraph">
<p>The ADDRETAINTYPE action adds its arguments to the list of retained types,  which extend the visibility of the rules.</p>
</div>
<div class="listingblock">
<div class="title">Definition</div>
<div class="content">
<pre class="highlight"><code>ADDRETAINTYPE(TypeExpression(,TypeExpression)*)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="highlight"><code>Document{-&gt;ADDRETAINTYPE(MARKUP)};</code></pre>
</div>
</div>
<div class="paragraph">
<p>After applying this rule, markup is visible additionally to the previously retained types.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.language.actions.assign"><a class="anchor" href="#_ugr.tools.ruta.language.actions.assign"></a>2.8.4. ASSIGN</h4>
<div class="paragraph">
<p>The ASSIGN action assigns the value of the passed expression to a variable of the same type.</p>
</div>
<div class="listingblock">
<div class="title">Definition</div>
<div class="content">
<pre class="highlight"><code>ASSIGN(BooleanVariable,BooleanExpression)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>ASSIGN(NumberVariable,NumberExpression)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>ASSIGN(StringVariable,StringExpression)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>ASSIGN(TypeVariable,TypeExpression)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="highlight"><code>Document{-&gt;ASSIGN(amount, (amount/2))};</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this example, the value of the variable 'amount' is divided in half.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.language.actions.call"><a class="anchor" href="#_ugr.tools.ruta.language.actions.call"></a>2.8.5. CALL</h4>
<div class="paragraph">
<p>The CALL action initiates the execution of a different script file or script block.
Currently, only complete script files are supported.</p>
</div>
<div class="listingblock">
<div class="title">Definition</div>
<div class="content">
<pre class="highlight"><code>CALL(DifferentFile)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>CALL(Block)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="highlight"><code>Document{-&gt;CALL(NamedEntities)};</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here, a script 'NamedEntities' for named entity recognition is executed.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.language.actions.clear"><a class="anchor" href="#_ugr.tools.ruta.language.actions.clear"></a>2.8.6. CLEAR</h4>
<div class="paragraph">
<p>The CLEAR action removes all elements of the given list.
If the list was initialized as it was declared,  then it is reset to its initial value.</p>
</div>
<div class="listingblock">
<div class="title">Definition</div>
<div class="content">
<pre class="highlight"><code>CLEAR(ListVariable)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="highlight"><code>Document{-&gt;CLEAR(SomeList)};</code></pre>
</div>
</div>
<div class="paragraph">
<p>This rule clears the list 'SomeList'.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.language.actions.color"><a class="anchor" href="#_ugr.tools.ruta.language.actions.color"></a>2.8.7. COLOR</h4>
<div class="paragraph">
<p>The COLOR action sets the color of an annotation type in the modified view, if the rule has fired.
The background color is passed as the second parameter.
The font color can be changed by passing a further color as a third parameter.
The supported colors are: black, silver, gray, white, maroon, red, purple, fuchsia, green, lime, olive, yellow, navy, blue, aqua, lightblue, lightgreen, orange, pink, salmon, cyan, violet, tan, brown, white and mediumpurple.</p>
</div>
<div class="listingblock">
<div class="title">Definition</div>
<div class="content">
<pre class="highlight"><code>COLOR(TypeExpression,StringExpression(, StringExpression
          (, BooleanExpression)?)?)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="highlight"><code>Document{-&gt;COLOR(Headline, "red", "green", true)};</code></pre>
</div>
</div>
<div class="paragraph">
<p>This rule colors all Headline annotations in the modified view.
Thereby, the background color is set to red, font color is set to green and all 'Headline' annotations are selected when opening the modified view.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.language.actions.configure"><a class="anchor" href="#_ugr.tools.ruta.language.actions.configure"></a>2.8.8. CONFIGURE</h4>
<div class="paragraph">
<p>The CONFIGURE action can be used to configure the analysis engine of the given namespace (first parameter). The parameters that should be configured with corresponding values are passed as name-value pairs.</p>
</div>
<div class="listingblock">
<div class="title">Definition</div>
<div class="content">
<pre class="highlight"><code>CONFIGURE(AnalysisEngine(,StringExpression = Expression)+)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="highlight"><code>ENGINE utils.HtmlAnnotator;
Document{-&gt;CONFIGURE(HtmlAnnotator, "onlyContent" = false)};</code></pre>
</div>
</div>
<div class="paragraph">
<p>The former rule changes the value of configuration parameter &#8220;onlyContent&#8221; to false and reconfigure the analysis engine.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.language.actions.create"><a class="anchor" href="#_ugr.tools.ruta.language.actions.create"></a>2.8.9. CREATE</h4>
<div class="paragraph">
<p>The CREATE action is similar to the MARK action.
It also annotates the matched text fragments with a type annotation, but additionally assigns values to a chosen subset of the type&#8217;s feature elements.</p>
</div>
<div class="listingblock">
<div class="title">Definition</div>
<div class="content">
<pre class="highlight"><code>CREATE(TypeExpression(,NumberExpression)*
                         (,StringExpression = Expression)+)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="highlight"><code>Paragraph{COUNT(ANY,0,10000,cnt)-&gt;CREATE(Headline,"size" = cnt)};</code></pre>
</div>
</div>
<div class="paragraph">
<p>This rule counts the number of tokens of type ANY in a Paragraph annotation and assigns the counted value to the int variable 'cnt'. If the counted number is between 0 and 10000, a Headline annotation is created for this Paragraph.
Moreover, the feature named 'size' of Headline is set to the value of 'cnt'.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.language.actions.del"><a class="anchor" href="#_ugr.tools.ruta.language.actions.del"></a>2.8.10. DEL</h4>
<div class="paragraph">
<p>The DEL action deletes the matched text fragments in the modified view.
For removing annotations see UNMARK.</p>
</div>
<div class="listingblock">
<div class="title">Definition</div>
<div class="content">
<pre class="highlight"><code>DEL</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="highlight"><code>Name{-&gt;DEL};</code></pre>
</div>
</div>
<div class="paragraph">
<p>This rule deletes all text fragments that are annotated with a Name annotation.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.language.actions.dynamicanchoring"><a class="anchor" href="#_ugr.tools.ruta.language.actions.dynamicanchoring"></a>2.8.11. DYNAMICANCHORING</h4>
<div class="paragraph">
<p>The DYNAMICANCHORING action turns dynamic anchoring on or off (first parameter) and assigns the anchoring parameters penalty (second parameter) and factor (third parameter).</p>
</div>
<div class="listingblock">
<div class="title">Definition</div>
<div class="content">
<pre class="highlight"><code>DYNAMICANCHORING(BooleanExpression
              (,NumberExpression(,NumberExpression)?)?)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="highlight"><code>Document{-&gt;DYNAMICANCHORING(true)};</code></pre>
</div>
</div>
<div class="paragraph">
<p>The above mentioned example activates dynamic anchoring.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.language.actions.exec"><a class="anchor" href="#_ugr.tools.ruta.language.actions.exec"></a>2.8.12. EXEC</h4>
<div class="paragraph">
<p>The EXEC action initiates the execution of a different script file or analysis engine on the complete input document, independent from the matched text and the current filtering settings.
If the imported component (DifferentFile) refers to another script file, it is applied on a new representation of the document: the complete text of the original CAS with the default filtering settings of the UIMA Ruta analysis engine.
If it refers to an  external analysis engine, then it is applied on the complete document.
The optional, first argument is is a string expression, which specifies the view the component should be applied on.
The optional, third argument is a list of types, which should be reindexed by Ruta (not UIMA itself).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>Annotations created by the external analysis engine are not accessible for UIMA Ruta rules in the same script.
The types of these annotations need to be provided in the second argument in order to be visible to the Ruta rules.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">Definition</div>
<div class="content">
<pre class="highlight"><code>EXEC((StringExpression,)? DifferentFile(, TypeListExpression)?)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="highlight"><code>ENGINE NamedEntities;
Document{-&gt;EXEC(NamedEntities, {Person, Location})};</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here, an analysis engine for named entity recognition is executed once on the complete document and the annotations of the types Person and Location (and all subtypes)  are reindexed in UIMA Ruta.
Without this list of types, the annotations are added to the CAS, but cannot be accessed by Ruta rules.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.language.actions.fill"><a class="anchor" href="#_ugr.tools.ruta.language.actions.fill"></a>2.8.13. FILL</h4>
<div class="paragraph">
<p>The FILL action fills a chosen subset of the given type&#8217;s feature elements.</p>
</div>
<div class="listingblock">
<div class="title">Definition</div>
<div class="content">
<pre class="highlight"><code>FILL(TypeExpression(,StringExpression = Expression)+)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="highlight"><code>Headline{COUNT(ANY,0,10000,tokenCount)
          -&gt;FILL(Headline,"size" = tokenCount)};</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here, the number of tokens within an Headline annotation is counted and stored in variable 'tokenCount'. If the number of tokens is within the interval [0;10000], the FILL action fills the Headline&#8217;s feature 'size' with the value of 'tokenCount'.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.language.actions.filtertype"><a class="anchor" href="#_ugr.tools.ruta.language.actions.filtertype"></a>2.8.14. FILTERTYPE</h4>
<div class="paragraph">
<p>This action filters the given types of annotations.
They are now ignored by rules.
Expressions are not yet supported.
This action is related to RETAINTYPE (see <a href="#_ugr.tools.ruta.language.actions.retaintype">Section 2.8.35</a>).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>The visibility of types is calculated using three lists:  A list &#8220;default&#8221; for the initially filtered types,  which is specified in the configuration parameters of the analysis engine, the list &#8220;filtered&#8221;, which is  specified by the FILTERTYPE action, and the list &#8220;retained&#8221;, which is specified by the RETAINTYPE action.
For determining the actual visibility of types, list &#8220;filtered&#8221; is added to list &#8220;default&#8221;  and then all elements of list &#8220;retained&#8221; are removed.
The annotations of the types in the resulting list are not visible.
Please note that the actions FILTERTYPE and RETAINTYPE replace all elements of the respective lists and that RETAINTYPE  overrides FILTERTYPE.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">Definition</div>
<div class="content">
<pre class="highlight"><code>FILTERTYPE((TypeExpression(,TypeExpression)*))?</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="highlight"><code>Document{-&gt;FILTERTYPE(SW)};</code></pre>
</div>
</div>
<div class="paragraph">
<p>This rule filters all small written words in the input document.
They are further ignored by every rule.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>Document{-&gt;FILTERTYPE};</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here, the the action (without parentheses) specifies that no additional types should be filtered.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.language.actions.gather"><a class="anchor" href="#_ugr.tools.ruta.language.actions.gather"></a>2.8.15. GATHER</h4>
<div class="paragraph">
<p>This action creates a complex structure: an annotation with features.
The optionally passed indexes (NumberExpressions after the TypeExpression) can be used to create an annotation that spans the matched information of several rule elements.
The features are collected using the indexes of the rule elements of the complete rule.</p>
</div>
<div class="listingblock">
<div class="title">Definition</div>
<div class="content">
<pre class="highlight"><code>GATHER(TypeExpression(,NumberExpression)*
          (,StringExpression = NumberExpression)+)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="highlight"><code>DECLARE Annotation A;
DECLARE Annotation B;
DECLARE Annotation C(Annotation a, Annotation b);
W{REGEXP("A")-&gt;MARK(A)};
W{REGEXP("B")-&gt;MARK(B)};
A B{-&gt; GATHER(C, 1, 2, "a" = 1, "b" = 2)};</code></pre>
</div>
</div>
<div class="paragraph">
<p>Two annotations A and B are declared and annotated.
The last rule creates an annotation C spanning the elements A (index 1 since it is the first rule element) and B (index 2) with its features 'a' set to annotation A (again index 1) and 'b' set to annotation B (again index 2).</p>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.language.actions.get"><a class="anchor" href="#_ugr.tools.ruta.language.actions.get"></a>2.8.16. GET</h4>
<div class="paragraph">
<p>The GET action retrieves an element of the given list dependent on a given strategy.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 4. Currently supported strategies</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Strategy</th>
<th class="tableblock halign-left valign-top">Functionality</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">dominant</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">finds the most occurring element</p></td>
</tr>
</tbody>
</table>
<div class="listingblock">
<div class="title">Definition</div>
<div class="content">
<pre class="highlight"><code>GET(ListExpression, Variable, StringExpression)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="highlight"><code>Document{-&gt;GET(list, var, "dominant")};</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this example, the element of the list 'list' that occurs most is stored in the variable 'var'.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.language.actions.getfeature"><a class="anchor" href="#_ugr.tools.ruta.language.actions.getfeature"></a>2.8.17. GETFEATURE</h4>
<div class="paragraph">
<p>The GETFEATURE action stores the value of the matched annotation&#8217;s feature (first paramter) in the given variable (second parameter).</p>
</div>
<div class="listingblock">
<div class="title">Definition</div>
<div class="content">
<pre class="highlight"><code>GETFEATURE(StringExpression, Variable)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="highlight"><code>Document{-&gt;GETFEATURE("language", stringVar)};</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this example, variable 'stringVar' will contain the value of the feature 'language'.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.language.actions.getlist"><a class="anchor" href="#_ugr.tools.ruta.language.actions.getlist"></a>2.8.18. GETLIST</h4>
<div class="paragraph">
<p>This action retrieves a list of types dependent on a given strategy.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 5. Currently supported strategies</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Strategy</th>
<th class="tableblock halign-left valign-top">Functionality</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Types</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">get all types within the matched annotation</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Types:End</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">get all types that end at the same offset as the matched
                annotation</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Types:Begin</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">get all types that start at the same offset as the
                matched
                annotation</p></td>
</tr>
</tbody>
</table>
<div class="listingblock">
<div class="title">Definition</div>
<div class="content">
<pre class="highlight"><code>GETLIST(ListVariable, StringExpression)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="highlight"><code>Document{-&gt;GETLIST(list, "Types")};</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here, a list of all types within the document is created and assigned to list variable 'list'.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.language.actions.greedyanchoring"><a class="anchor" href="#_ugr.tools.ruta.language.actions.greedyanchoring"></a>2.8.19. GREEDYANCHORING</h4>
<div class="paragraph">
<p>The GREEDYANCHORING action turns greedy anchoring on or off.
If the first parameter is set to true, then start positions already matched by the same rule element will be ignored.
This situation  occurs mostly for rules that start with a quantifier.
The second optional parameter activates greedy acnhoring for the complete rule.
Later rule matches are only possible after previous matches.</p>
</div>
<div class="listingblock">
<div class="title">Definition</div>
<div class="content">
<pre class="highlight"><code>GREEDYANCHORING(BooleanExpression(,BooleanExpression)?)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="highlight"><code>Document{-&gt;GREEDYANCHORING(true, true)};
        ANY+;
        CW CW;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The above mentioned example activates dynamic anchoring and the second rule will then only match once  since the next positions, e.g., the second token, are already covered by the first attempt.
The third rule will not match on capitalized word that have benn already considered by previous matches of the rule.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.language.actions.log"><a class="anchor" href="#_ugr.tools.ruta.language.actions.log"></a>2.8.20. LOG</h4>
<div class="paragraph">
<p>The LOG action writes a log message.</p>
</div>
<div class="listingblock">
<div class="title">Definition</div>
<div class="content">
<pre class="highlight"><code>LOG(StringExpression)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="highlight"><code>Document{-&gt;LOG("processed")};</code></pre>
</div>
</div>
<div class="paragraph">
<p>This rule writes a log message with the string "processed".</p>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.language.actions.mark"><a class="anchor" href="#_ugr.tools.ruta.language.actions.mark"></a>2.8.21. MARK</h4>
<div class="paragraph">
<p>The MARK action is the most important action in the UIMA Ruta system.
It creates a new annotation of the given type.
The optionally passed indexes (NumberExpressions after the TypeExpression) can be used to create an annotation that spanns the matched information of several rule elements.</p>
</div>
<div class="listingblock">
<div class="title">Definition</div>
<div class="content">
<pre class="highlight"><code>MARK(TypeExpression(,NumberExpression)*)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="highlight"><code>Freeline Paragraph{-&gt;MARK(ParagraphAfterFreeline,1,2)};</code></pre>
</div>
</div>
<div class="paragraph">
<p>This rule matches on a free line followed by a Paragraph annotation and annotates both in a single ParagraphAfterFreeline annotation.
The two numerical expressions at the end of the mark action state that the matched text of the first and the second rule elements are joined to create the boundaries of the new annotation.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.language.actions.markfast"><a class="anchor" href="#_ugr.tools.ruta.language.actions.markfast"></a>2.8.22. MARKFAST</h4>
<div class="paragraph">
<p>The MARKFAST action creates annotations of the given type (first parameter), if an element of the passed list (second parameter) occurs within the window of the matched annotation.
Thereby, the created annotation does not cover the whole matched annotation.
Instead, it only covers the text of the found occurrence.
The third parameter is optional.
It defines, whether the MARKFAST action should ignore the case, whereby its default value is false.
The optional fourth parameter specifies a character threshold for the ignorence of the case.
It is only relevant, if the ignore-case value is set to true.
The last parameter is set to true by default and specifies whether whitespaces in the entries of the dictionary should be ignored.
For more information on lists see <a href="#_ugr.tools.ruta.language.declarations.ressource">Section 2.5.3</a>.
Additionally to external word lists, string lists variables can be used.</p>
</div>
<div class="listingblock">
<div class="title">Definition</div>
<div class="content">
<pre class="highlight"><code>MARKFAST(TypeExpression,ListExpression(,BooleanExpression
          (,NumberExpression,(BooleanExpression)?)?)?)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>MARKFAST(TypeExpression,StringListExpression(,BooleanExpression
          (,NumberExpression,(BooleanExpression)?)?)?)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="highlight"><code>WORDLIST FirstNameList = 'FirstNames.txt';
DECLARE FirstName;
Document{-&gt; MARKFAST(FirstName, FirstNameList, true, 2)};</code></pre>
</div>
</div>
<div class="paragraph">
<p>This rule annotates all first names listed in the list 'FirstNameList' within the document and ignores the case, if the length of the word is greater than 2.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.language.actions.markfirst"><a class="anchor" href="#_ugr.tools.ruta.language.actions.markfirst"></a>2.8.23. MARKFIRST</h4>
<div class="paragraph">
<p>The MARKFIRST action annotates the first token (basic annotation) of the matched annotation with the given type.</p>
</div>
<div class="listingblock">
<div class="title">Definition</div>
<div class="content">
<pre class="highlight"><code>MARKFIRST(TypeExpression)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="highlight"><code>Document{-&gt;MARKFIRST(First)};</code></pre>
</div>
</div>
<div class="paragraph">
<p>This rule annotates the first token of the document with the annotation First.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.language.actions.marklast"><a class="anchor" href="#_ugr.tools.ruta.language.actions.marklast"></a>2.8.24. MARKLAST</h4>
<div class="paragraph">
<p>The MARKLAST action annotates the last token of the matched annotation with the given type.</p>
</div>
<div class="listingblock">
<div class="title">Definition</div>
<div class="content">
<pre class="highlight"><code>MARKLAST(TypeExpression)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="highlight"><code>Document{-&gt;MARKLAST(Last)};</code></pre>
</div>
</div>
<div class="paragraph">
<p>This rule annotates the last token of the document with the annotation Last.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.language.actions.markonce"><a class="anchor" href="#_ugr.tools.ruta.language.actions.markonce"></a>2.8.25. MARKONCE</h4>
<div class="paragraph">
<p>The MARKONCE action has the same functionality as the MARK action, but creates a new annotation only,  if each part of the matched annotation is not yet part of the given type.</p>
</div>
<div class="listingblock">
<div class="title">Definition</div>
<div class="content">
<pre class="highlight"><code>MARKONCE(NumberExpression,TypeExpression(,NumberExpression)*)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="highlight"><code>Freeline Paragraph{-&gt;MARKONCE(ParagraphAfterFreeline,1,2)};</code></pre>
</div>
</div>
<div class="paragraph">
<p>This rule matches on a free line followed by a Paragraph and annotates both in a single ParagraphAfterFreeline annotation, if no part  is not already annotated with ParagraphAfterFreeline annotation.
The two numerical expressions at the end of the MARKONCE action state that the matched text of the first and the second rule elements are joined to create the boundaries of the new annotation.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.language.actions.markscore"><a class="anchor" href="#_ugr.tools.ruta.language.actions.markscore"></a>2.8.26. MARKSCORE</h4>
<div class="paragraph">
<p>The MARKSCORE action is similar to the MARK action.
It also creates a new annotation of the given type, but only if it is not yet existing.
The optionally passed indexes (parameters after the TypeExpression) can be used to create an annotation that spanns the matched information of several rule elements.
Additionally, a score value (first parameter) is added to the heuristic score value of the annotation.
For more information on heuristic scores see <a href="#_ugr.tools.ruta.language.score">Section 2.16</a> .</p>
</div>
<div class="listingblock">
<div class="title">Definition</div>
<div class="content">
<pre class="highlight"><code>MARKSCORE(NumberExpression,TypeExpression(,NumberExpression)*)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="highlight"><code>Freeline Paragraph{-&gt;MARKSCORE(10,ParagraphAfterFreeline,1,2)};</code></pre>
</div>
</div>
<div class="paragraph">
<p>This rule matches on a free line followed by a paragraph and annotates both in a single ParagraphAfterFreeline annotation.
The two number expressions at the end of the mark action indicate that the matched text of the first and the second rule elements are joined to create the boundaries of the new annotation.
Additionally, the score '10' is added to the heuristic threshold of this annotation.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.language.actions.marktable"><a class="anchor" href="#_ugr.tools.ruta.language.actions.marktable"></a>2.8.27. MARKTABLE</h4>
<div class="paragraph">
<p>The MARKTABLE action creates annotations of the given type (first parameter), if an element of the given column (second parameter) of a passed table (third parameter) occures within the window of the matched annotation.
Thereby, the created annotation does not cover the whole matched annotation.
Instead, it only covers the text of the found occurrence.
Optionally the MARKTABLE action is able to assign entries of the given table to features of the created annotation.
For more information on tables see <a href="#_ugr.tools.ruta.language.declarations.ressource">Section 2.5.3</a>.
Additionally, several configuration parameters are possible.
(See example.)</p>
</div>
<div class="listingblock">
<div class="title">Definition</div>
<div class="content">
<pre class="highlight"><code>MARKTABLE(TypeExpression, NumberExpression, TableExpression
          (,BooleanExpression, NumberExpression,
          StringExpression, NumberExpression)?
          (,StringExpression = NumberExpression)+)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="highlight"><code>WORDTABLE TestTable = 'TestTable.csv';
DECLARE Annotation Struct(STRING first);
Document{-&gt; MARKTABLE(Struct, 1, TestTable,
    true, 4, ".,-", 2, "first" = 2)};</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this example, the whole document is searched for all occurrences of the entries of the first column of the given table 'TestTable'. For each occurrence, an annotation of the type Struct is created and its feature 'first' is filled with the entry of the second column.
Moreover, the case of the word is ignored if the length of the word exceeds 4.
Additionally, the chars '.', ',' and '-' are ignored, but maximally two of them.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.language.actions.matchedtext"><a class="anchor" href="#_ugr.tools.ruta.language.actions.matchedtext"></a>2.8.28. MATCHEDTEXT</h4>
<div class="paragraph">
<p>The MATCHEDTEXT action saves the text of the matched annotation in a passed String variable.
The optionally passed indexes can be used to match the text of several rule elements.</p>
</div>
<div class="listingblock">
<div class="title">Definition</div>
<div class="content">
<pre class="highlight"><code>MATCHEDTEXT(StringVariable(,NumberExpression)*)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="highlight"><code>Headline Paragraph{-&gt;MATCHEDTEXT(stringVariable,1,2)};</code></pre>
</div>
</div>
<div class="paragraph">
<p>The text covered by the Headline (rule element 1) and the Paragraph (rule element 2) annotation is saved in variable 'stringVariable'.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.language.actions.merge"><a class="anchor" href="#_ugr.tools.ruta.language.actions.merge"></a>2.8.29. MERGE</h4>
<div class="paragraph">
<p>The MERGE action merges a number of given lists.
The first parameter defines, if the merge is done as intersection (false) or as union (true). The second parameter is the list variable that will contain the result.</p>
</div>
<div class="listingblock">
<div class="title">Definition</div>
<div class="content">
<pre class="highlight"><code>MERGE(BooleanExpression, ListVariable, ListExpression, (ListExpression)+)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="highlight"><code>Document{-&gt;MERGE(false, listVar, list1, list2, list3)};</code></pre>
</div>
</div>
<div class="paragraph">
<p>The elements that occur in all three lists will be placed in the list 'listVar'.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.language.actions.remove"><a class="anchor" href="#_ugr.tools.ruta.language.actions.remove"></a>2.8.30. REMOVE</h4>
<div class="paragraph">
<p>The REMOVE action removes lists or single values from a given list.</p>
</div>
<div class="listingblock">
<div class="title">Definition</div>
<div class="content">
<pre class="highlight"><code>REMOVE(ListVariable,(Argument)+)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="highlight"><code>Document{-&gt;REMOVE(list, var)};</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this example, the variable 'var' is removed from the list 'list'.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.language.actions.removeduplicate"><a class="anchor" href="#_ugr.tools.ruta.language.actions.removeduplicate"></a>2.8.31. REMOVEDUPLICATE</h4>
<div class="paragraph">
<p>This action removes all duplicates within a given list.</p>
</div>
<div class="listingblock">
<div class="title">Definition</div>
<div class="content">
<pre class="highlight"><code>REMOVEDUPLICATE(ListVariable)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="highlight"><code>Document{-&gt;REMOVEDUPLICATE(list)};</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here, all duplicates within the list 'list' are removed.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.language.actions.removefiltertype"><a class="anchor" href="#_ugr.tools.ruta.language.actions.removefiltertype"></a>2.8.32. REMOVEFILTERTYPE</h4>
<div class="paragraph">
<p>The REMOVEFILTERTYPE action removes its arguments from the list of filtered types,  which restrict the visibility of the rules.</p>
</div>
<div class="listingblock">
<div class="title">Definition</div>
<div class="content">
<pre class="highlight"><code>REMOVEFILTERTYPE(TypeExpression(,TypeExpression)*)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="highlight"><code>Document{-&gt;REMOVEFILTERTYPE(W)};</code></pre>
</div>
</div>
<div class="paragraph">
<p>After applying this rule, words are possibly visible again depending on the current filtering settings.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.language.actions.removeretaintype"><a class="anchor" href="#_ugr.tools.ruta.language.actions.removeretaintype"></a>2.8.33. REMOVERETAINTYPE</h4>
<div class="paragraph">
<p>The REMOVEFILTERTYPE action removes its arguments from the list of retained types,  which extend the visibility of the rules.</p>
</div>
<div class="listingblock">
<div class="title">Definition</div>
<div class="content">
<pre class="highlight"><code>REMOVERETAINTYPE(TypeExpression(,TypeExpression)*)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="highlight"><code>Document{-&gt;REMOVERETAINTYPE(W)};</code></pre>
</div>
</div>
<div class="paragraph">
<p>After applying this rule, words are possibly not visible anymore depending on the current filtering settings.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.language.actions.replace"><a class="anchor" href="#_ugr.tools.ruta.language.actions.replace"></a>2.8.34. REPLACE</h4>
<div class="paragraph">
<p>The REPLACE action replaces the text of all matched annotations with the given StringExpression.
It remembers the modification for the matched annotations and shows them in the modified view (see <a href="#_ugr.tools.ruta.language.modification">Section 2.17</a>).</p>
</div>
<div class="listingblock">
<div class="title">Definition</div>
<div class="content">
<pre class="highlight"><code>REPLACE(StringExpression)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="highlight"><code>FirstName{-&gt;REPLACE("first name")};</code></pre>
</div>
</div>
<div class="paragraph">
<p>This rule replaces all first names with the string 'first name'.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.language.actions.retaintype"><a class="anchor" href="#_ugr.tools.ruta.language.actions.retaintype"></a>2.8.35. RETAINTYPE</h4>
<div class="paragraph">
<p>The RETAINTYPE action retains the given types.
This means that they are now not ignored by rules.
This action is related to FILTERTYPE (see <a href="#_ugr.tools.ruta.language.actions.filtertype">Section 2.8.14</a>).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>The visibility of types is calculated using three lists:  A list &#8220;default&#8221; for the initially filtered types,  which is specified in the configuration parameters of the analysis engine, the list &#8220;filtered&#8221;, which is  specified by the FILTERTYPE action, and the list &#8220;retained&#8221;, which is specified by the RETAINTYPE action.
For determining the actual visibility of types, list &#8220;filtered&#8221; is added to list &#8220;default&#8221;  and then all elements of list &#8220;retained&#8221; are removed.
The annotations of the types in the resulting list are not visible.
Please note that the actions FILTERTYPE and RETAINTYPE replace all elements of the respective lists and that RETAINTYPE  overrides FILTERTYPE.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">Definition</div>
<div class="content">
<pre class="highlight"><code>RETAINTYPE((TypeExpression(,TypeExpression)*))?</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="highlight"><code>Document{-&gt;RETAINTYPE(SPACE)};</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here, all spaces are retained and can be matched by rules.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>Document{-&gt;RETAINTYPE};</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here, the the action (without parentheses) specifies that no types should be retained.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.language.actions.setfeature"><a class="anchor" href="#_ugr.tools.ruta.language.actions.setfeature"></a>2.8.36. SETFEATURE</h4>
<div class="paragraph">
<p>The SETFEATURE action sets the value of a feature of the matched complex structure.</p>
</div>
<div class="listingblock">
<div class="title">Definition</div>
<div class="content">
<pre class="highlight"><code>SETFEATURE(StringExpression,Expression)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="highlight"><code>Document{-&gt;SETFEATURE("language","en")};</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here, the feature 'language' of the input document is set to English.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.language.actions.shift"><a class="anchor" href="#_ugr.tools.ruta.language.actions.shift"></a>2.8.37. SHIFT</h4>
<div class="paragraph">
<p>The SHIFT action can be used to change the offsets of an annotation.
The two number expressions, which point the rule elements of the rule, specify the new offsets of the annotation.
The annotations that will be modified have to start or end at the match of the rule element of the action if the boolean option is set to true.
By default, only the matched annotation of the given type will be modified.
In either way, this means that the action  has to be placed at a matching condition, which will be used to specify the annotations to be changed.</p>
</div>
<div class="listingblock">
<div class="title">Definition</div>
<div class="content">
<pre class="highlight"><code>SHIFT(TypeExpression,NumberExpression,NumberExpression,BooleanExpression?)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="highlight"><code>Author{-&gt; SHIFT(Author,1,2)} PM;</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this example, an annotation of the type &#8220;Author&#8221; is expanded  in order to cover the following punctuation mark.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>W{STARTSWITH(FS) -&gt; SHIFT(FS, 1, 2, true)} W+ MARKUP;</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this example, an annotation of the type &#8220;FS&#8221; that consists mostly of words  is shrinked by removing the last MARKUP annotation.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.language.actions.split"><a class="anchor" href="#_ugr.tools.ruta.language.actions.split"></a>2.8.38. SPLIT</h4>
<div class="paragraph">
<p>The SPLIT action is able to split the matched annotation for each occurrence of annotation  of the given type.
There are three additional parameters: The first one specifies if complete annotations of the given type  should be used to split the matched annotations.
If set to false, then even the boundary of an annotation will cause splitting.
The third (addToBegin) and fourth (addToEnd) argument specify if the complete annotation (for splitting)  will be added to the begin or end of the split annotation.
The latter two are only utilized if the first one is set to true.. If omitted, the first argument is true and the other two arguments are false by default.</p>
</div>
<div class="listingblock">
<div class="title">Definition</div>
<div class="content">
<pre class="highlight"><code>SPLIT(TypeExpression(,BooleanExpression,
          (BooleanExpression, BooleanExpression)? )?</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="highlight"><code>Sentence{-&gt; SPLIT(PERIOD, true, false, true)};</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this example, an annotation of the type &#8220;Sentence&#8221; is  split for each occurrence of a period, which is added to the end of the new sentence.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.language.actions.transfer"><a class="anchor" href="#_ugr.tools.ruta.language.actions.transfer"></a>2.8.39. TRANSFER</h4>
<div class="paragraph">
<p>The TRANSFER action creates a new feature structure and adds all compatible features of the matched annotation.</p>
</div>
<div class="listingblock">
<div class="title">Definition</div>
<div class="content">
<pre class="highlight"><code>TRANSFER(TypeExpression)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="highlight"><code>Document{-&gt;TRANSFER(LanguageStorage)};</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here, a new feature structure &#8220;LanguageStorage&#8221; is created and the compatible features of the Document annotation are copied.
E.g., if LanguageStorage defined a feature named 'language', then the feature value of the Document annotation is copied.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.language.actions.trie"><a class="anchor" href="#_ugr.tools.ruta.language.actions.trie"></a>2.8.40. TRIE</h4>
<div class="paragraph">
<p>The TRIE action uses an external multi tree word list to annotate the matched annotation and provides several configuration parameters.</p>
</div>
<div class="listingblock">
<div class="title">Definition</div>
<div class="content">
<pre class="highlight"><code>TRIE((String = (TypeExpression|{TypeExpression,StringExpression,
          Expression}))+,ListExpression,BooleanExpression,NumberExpression,
          BooleanExpression,NumberExpression,StringExpression)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="highlight"><code>Document{-&gt;TRIE("FirstNames.txt" = FirstName, "Companies.txt" = Company,
          'Dictionary.mtwl', true, 4, false, 0, ".,-/")};</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here, the dictionary 'Dictionary.mtwl' that contains word lists for first names and companies is used to annotate the document.
The words previously contained in the file 'FirstNames.txt' are annotated with the type FirstName and the words in the file 'Companies.txt' with the type Company.
The case of the word is ignored, if the length of the word exceeds 4.
The edit distance is deactivated.
The cost of an edit operation can currently not be configured by an argument.
The last argument additionally defines several chars that will be ignored.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>Document{-&gt;TRIE("FirstNames.txt" = {A, "a", "first"}, "LastNames.txt" =
          {B, "b", true}, "CompleteNames.txt" = {C, "c", 6},
          list1, true, 4, false, 0, ":")};</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here, the dictionary 'list1' is applied on the document.
Matches originated in dictionary 'FirstNames.txt' result in annotations of type A wheras their features 'a' are set to 'first'. The other two dictionaries  create annotations of type 'B' and 'C' for the corresponding dictionaries with a boolean feature value  and a integer feature value.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.language.actions.trim"><a class="anchor" href="#_ugr.tools.ruta.language.actions.trim"></a>2.8.41. TRIM</h4>
<div class="paragraph">
<p>The TRIM action changes the offsets on the matched annotations by removing annotations, whose types are specified by the given parameters.</p>
</div>
<div class="listingblock">
<div class="title">Definition</div>
<div class="content">
<pre class="highlight"><code>TRIM(TypeExpression ( , TypeExpression)*)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>TRIM(TypeListExpression)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="highlight"><code>Keyword{-&gt; TRIM(SPACE)};</code></pre>
</div>
</div>
<div class="paragraph">
<p>This rule removes all spaces at the beginning and at the end of Keyword annotations and thus changes the offsets of the matched annotations.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.language.actions.unmark"><a class="anchor" href="#_ugr.tools.ruta.language.actions.unmark"></a>2.8.42. UNMARK</h4>
<div class="paragraph">
<p>The UNMARK action removes the annotation of the given type overlapping the matched annotation.
There are two additional configurations: If additional indexes are given, then the span of the specified rule elements are applied, similar the the MARK action.
If instead a boolean is given as an additional argument, then all annotations of the given type are removed that start at the matched position.</p>
</div>
<div class="listingblock">
<div class="title">Definition</div>
<div class="content">
<pre class="highlight"><code>UNMARK(AnnotationExpression)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>UNMARK(TypeExpression)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>UNMARK(TypeExpression (,NumberExpression)*)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>UNMARK(TypeExpression, BooleanExpression)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="highlight"><code>Headline{-&gt;UNMARK(Headline)};</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here, the Headline annotation is removed.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>CW ANY+? QUESTION{-&gt;UNMARK(Headline,1,3)};</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here, all Headline annotations are removed that start with a capitalized word and end with a question mark.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>CW{-&gt;UNMARK(Headline,true)};</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here, all Headline annotations are removed that start with a capitalized word.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>Complex{-&gt;UNMARK(Complex.inner)};</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here, the annotation stored in the feature <code>inner</code> will be removed.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.language.actions.unmarkall"><a class="anchor" href="#_ugr.tools.ruta.language.actions.unmarkall"></a>2.8.43. UNMARKALL</h4>
<div class="paragraph">
<p>The UNMARKALL action removes all the annotations of the given type and all of its descendants overlapping the matched annotation, except the annotation is of at least one type in the passed list.</p>
</div>
<div class="listingblock">
<div class="title">Definition</div>
<div class="content">
<pre class="highlight"><code>UNMARKALL(TypeExpression, TypeListExpression)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="highlight"><code>Annotation{-&gt;UNMARKALL(Annotation, {Headline})};</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here, all annotations except from headlines are removed.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_ugr.tools.ruta.language.filtering"><a class="anchor" href="#_ugr.tools.ruta.language.filtering"></a>2.9. Robust extraction using filtering</h3>
<div class="paragraph">
<p>Rule based or pattern based information extraction systems often suffer from unimportant fill words, additional whitespace and unexpected markup.
The UIMA Ruta System enables the knowledge engineer to filter and to hide all possible combinations of predefined and new types of annotations.
The visibility of tokens and annotations is modified by the actions of rule elements and can be conditioned using the complete expressiveness of the language.
Therefore the UIMA Ruta system supports a robust approach to information extraction and simplifies the creation of new rules since the knowledge engineer can focus on important textual features.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>The visibility of types is calculated using three lists: A list &#8220;default&#8221; for the initially filtered types, which is specified in the configuration parameters of the analysis engine, the list &#8220;filtered&#8221; , which is specified by the FILTERTYPE action, and the list &#8220;retained&#8221; , which is specified by the RETAINTYPE action.
For determining the actual visibility of types, list &#8220;filtered&#8221; is added to list &#8220;default&#8221; and then all elements of list &#8220;retained&#8221; are removed.
The annotations of the types in the resulting list are not visible.
Please note that the actions FILTERTYPE and RETAINTYPE replace all elements of the respective lists and that RETAINTYPE overrides FILTERTYPE.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If no rule action changed the configuration of the filtering settings, then the default filtering configuration ignores whitespaces and markup.
Look at the following rule:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>"Dr" PERIOD CW CW;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Using the default setting, this rule matches on all four lines of this input document:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>Dr. Joachim Baumeister
Dr . Joachim      Baumeister
Dr. &lt;b&gt;&lt;i&gt;Joachim&lt;/i&gt; Baumeister&lt;/b&gt;
Dr.JoachimBaumeister</code></pre>
</div>
</div>
<div class="paragraph">
<p>To change the default setting, use the &#8220;FILTERTYPE&#8221; or &#8220;RETAINTYPE&#8221; action.
For example if markups should no longer be ignored, try the following example on the above mentioned input document:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>Document{-&gt;RETAINTYPE(MARKUP)};
"Dr" PERIOD CW CW;</code></pre>
</div>
</div>
<div class="paragraph">
<p>You will see that the third line of the previous input example will no longer be matched.</p>
</div>
<div class="paragraph">
<p>To filter types, try the following rules on the input document:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>Document{-&gt;FILTERTYPE(PERIOD)};
"Dr" CW CW;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Since periods are ignored here, the rule will match on all four lines of the example.</p>
</div>
<div class="paragraph">
<p>Notice that using a filtered annotation type within a rule prevents this rule from being executed.
Try the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>Document{-&gt;FILTERTYPE(PERIOD)};
"Dr" PERIOD CW CW;</code></pre>
</div>
</div>
<div class="paragraph">
<p>You will see that this matches on no line of the input document since the second rule uses the filtered type PERIOD and is therefore not executed.</p>
</div>
</div>
<div class="sect2">
<h3 id="_ugr.tools.ruta.language.wildcard"><a class="anchor" href="#_ugr.tools.ruta.language.wildcard"></a>2.10. Wildcard #</h3>
<div class="paragraph">
<p>The wildcard <code>\#</code> is a special matching condition of a rule element,  which does not match itself but uses the next rule element to determine its match.
It&#8217;s behavior is similar to a generic rule element with a reluctant, not restricted quantifier like <code>ANY+?</code> but it much more efficient since no additional annotations have to be matched.
The functionality of the wildcard is illustrated with following examples:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>PERIOD #{-&gt; Sentence} PERIOD;</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this example, everything in between two periods is annotated with an annotation of the type <code>Sentence</code>.
This rule is much more efficient than a rule like <code>PERIOD ANY+{-PARTOF(PERIOD)} PERIOD;</code> since it only navigated in the index of PERIOD annotations  and does not match on all tokens.
The wildcard is a normal matching condition and can be used as any other matching condition.
If the sentence  should include the period, the rule would look like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>PERIOD (# PERIOD){-&gt; Sentence};</code></pre>
</div>
</div>
<div class="paragraph">
<p>This rule creates only annotations after a period.
If the wildcard is used as an anchor of the rule,  e.g., is the first rule element and no manual anchor is specified, then it starts to match at the beginning  of the document or current window.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>(# PERIOD){-&gt; Sentence};</code></pre>
</div>
</div>
<div class="paragraph">
<p>This rule creates a Sentence annotation starting at the begin of the document ending with the first period.
If the rule elements are switched, the result is quite different because of the starting anchor of the rule:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>(PERIOD #){-&gt; Sentence};</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here, one annotation of the type Sentence is create for each PERIOD annotation starting with the period and  ending at the end of the document.
Currently, optional rule elements after wildcards are not optional.</p>
</div>
</div>
<div class="sect2">
<h3 id="_ugr.tools.ruta.language.optional"><a class="anchor" href="#_ugr.tools.ruta.language.optional"></a>2.11. Optional match _</h3>
<div class="paragraph">
<p>The optional match <code>\_</code> is a special matching condition of a rule element,  which does not require any annotations or a textual span in general to match.
The functionality of the optional match is illustrated with following examples:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>PERIOD{-&gt; SentenceEnd} _{-PARTOF(CW)};</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this example, an annotation of the type <code>SentenceEnd</code> is created for each <code>PERIOD</code> annotation,  if it is followed by something that is not part of a <code>CW</code>.
This is also fulfilled for the last <code>PERIOD</code> annotation in a document that ends with a period.</p>
</div>
</div>
<div class="sect2">
<h3 id="_ugr.tools.ruta.language.labels"><a class="anchor" href="#_ugr.tools.ruta.language.labels"></a>2.12. Label expressions</h3>
<div class="paragraph">
<p>Rule elements can be extended with labels, which introduce a new local variable storing one or  multiple annotations - the annotations matched by the matching condition of the rule element.
The name of the variable is the short identifier before the colon in front of the matching condition, e.g.,  in <code>sw:SW</code>, <code>SW</code> is the matching condition and <code>sw</code> is the name of the local variable.
The variable will be assigned when the rule element tries to match (also when it fails after all)  and can be utilized in all other language elements afterwards.
The functionality of the label expressions is illustrated with following examples:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>sw1:SW sw2:SW{sw1.end=sw2.begin};</code></pre>
</div>
</div>
<div class="paragraph">
<p>This rule matches on two consecutive small-written words, but matches only if there is no space in between them.
Label expression can also be used across <a href="#_ugr.tools.ruta.language.inlined">Section 2.14</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_ugr.tools.ruta.language.blocks"><a class="anchor" href="#_ugr.tools.ruta.language.blocks"></a>2.13. Blocks</h3>
<div class="paragraph">
<p>There are different types of blocks in UIMA Ruta.
Blocks aggregate rules or even other blocks and may serve as more complex control structures.
They are even able to change the rule behavior of the contained rules.</p>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.language.blocks.block"><a class="anchor" href="#_ugr.tools.ruta.language.blocks.block"></a>2.13.1. BLOCK</h4>
<div class="paragraph">
<p>BLOCK provides a simple control structure in the UIMA Ruta language:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Conditioned statements</p>
</li>
<li>
<p>Loops with restriction of the matching window</p>
</li>
<li>
<p>Procedures</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Declaration of a block:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>BlockDeclaration   -&gt; "BLOCK" "(" Identifier ")" RuleElementWithCA
                                            "{" Statements "}"
RuleElementWithCA      -&gt;  TypeExpression QuantifierPart?
                                            "{" Conditions?  Actions? "}"</code></pre>
</div>
</div>
<div class="paragraph">
<p>A block declaration always starts with the keyword &#8220;BLOCK&#8221; , followed by the identifier of the block within parentheses.
The &#8220;RuleElementType&#8221; -element is a UIMA Ruta rule that consists of exactly one rule element.
The rule element has to be a declared annotation type.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>The rule element in the definition of a block has to define a condition/action part, even if that part is empty ( &#8220;{}&#8221; ).</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Through the rule element a new local document is defined, whose scope is the related block.
So if you use <code>Document</code> within a block, this always refers to the locally limited document.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>BLOCK(ForEach) Paragraph{} {
    Document{COUNT(CW)}; // Here "Document" is limited to a Paragraph;
               // therefore the rule only counts the CW annotations
               // within the Paragraph
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>A block is always executed when the UIMA Ruta interpreter reaches its declaration.
But a block may also be called from another position of the script.
See <a href="#_ugr.tools.ruta.language.blocks.block.procedure">Section 2.13.1.3</a></p>
</div>
<div class="sect4">
<h5 id="_ugr.tools.ruta.language.blocks.block.condition"><a class="anchor" href="#_ugr.tools.ruta.language.blocks.block.condition"></a>Conditioned statements</h5>
<div class="paragraph">
<p>A block can use common UIMA Ruta conditions to condition the execution of its containing rules.</p>
</div>
<div class="paragraph">
<p>Examples:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>DECLARE Month;

BLOCK(EnglishDates) Document{FEATURE("language", "en")} {
    Document{-&gt;MARKFAST(Month,'englishMonthNames.txt')};
    //...
}

BLOCK(GermanDates) Document{FEATURE("language", "de")} {
    Document{-&gt;MARKFAST(Month,'germanMonthNames.txt')};
    //...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The example is explained in detail in <a href="#_ugr.tools.ruta.overview.examples">Section 1.4</a> .</p>
</div>
</div>
<div class="sect4">
<h5 id="_ugr.tools.ruta.language.blocks.block.foreach"><a class="anchor" href="#_ugr.tools.ruta.language.blocks.block.foreach"></a>Loops with restriction of the matching window</h5>
<div class="paragraph">
<p>A block can be used to execute the containing rules on a sequence of similar text passages, therefore representing a &#8220;foreach&#8221; like loop.</p>
</div>
<div class="paragraph">
<p>Examples:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>DECLARE SentenceWithNoLeadingNP;
BLOCK(ForEach) Sentence{} {
    Document{-STARTSWITH(NP) -&gt; MARK(SentenceWithNoLeadingNP)};
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The example is explained in detail in <a href="#_ugr.tools.ruta.overview.examples">Section 1.4</a>.</p>
</div>
<div class="paragraph">
<p>This construction is especially useful, if you have a set of rules, which has to be executed continuously on the same part of an input document.
Let us assume that you have already annotated your document with Paragraph annotations.
Now you want to count the number of words within each paragraph and, if the number of words exceeds 500, annotate it as BigParagraph.
Therefore, you wrote the following rules:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>DECLARE BigParagraph;
INT numberOfWords;
Paragraph{COUNT(W,numberOfWords)};
Paragraph{IF(numberOfWords &gt; 500) -&gt; MARK(BigParagraph)};</code></pre>
</div>
</div>
<div class="paragraph">
<p>This will not work.
The reason for this is that the rule, which counts the number of words within a Paragraph is executed on all Paragraphs before the last rule which marks the Paragraph as BigParagraph is even executed once.
When reaching the last rule in this example, the variable <code>numberOfWords</code> holds the number of words of the last Paragraph in the input document, thus, annotating all Paragraphs either as BigParagraph or not.</p>
</div>
<div class="paragraph">
<p>To solve this problem, use a block to tie the execution of this rules together for each Paragraph:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>DECLARE BigParagraph;
INT numberOfWords;
BLOCK(IsBig) Paragraph{} {
  Document{COUNT(W,numberOfWords)};
  Document{IF(numberOfWords &gt; 500) -&gt; MARK(BigParagraph)};
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Since the scope of the Document is limited to a Paragraph within the block, the rule, which counts the words is only executed once before the second rule decides, if the Paragraph is a BigParagraph.
Of course, this is done for every Paragraph in the whole document.</p>
</div>
</div>
<div class="sect4">
<h5 id="_ugr.tools.ruta.language.blocks.block.procedure"><a class="anchor" href="#_ugr.tools.ruta.language.blocks.block.procedure"></a>Procedures</h5>
<div class="paragraph">
<p>Blocks can be used to introduce procedures to the UIMA Ruta scripts.
To do this, declare a block as before.
Let us assume, you want to simulate a procedure</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>public int countAmountOfTypesInDocument(Type type){
    int amount = 0;
    for(Token token : Document) {
      if(token.isType(type)){
        amount++;
      }
    }
    return amount;
}

public static void main() {
  int amount = countAmountOfTypesInDocument(Paragraph));
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>which counts the number of the passed type within the document and returns the counted number.
This can be done in the following way:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>BOOLEAN executeProcedure = false;
TYPE type;
INT amount;

BLOCK(countNumberOfTypesInDocument) Document{IF(executeProcedure)} {
    Document{COUNT(type, amount)};
}

Document{-&gt;ASSIGN(executeProcedure, true)};
Document{-&gt;ASSIGN(type, Paragraph)};
Document{-&gt;CALL(MyScript.countNumberOfTypesInDocument)};</code></pre>
</div>
</div>
<div class="paragraph">
<p>The boolean variable <code>executeProcedure</code> is used to prohibit the execution of the block when the interpreter first reaches the block since this is no procedure call.
The block can be called by referring to it with its name, preceded by the name of the script the block is defined in.
In this example, the script is called MyScript.ruta.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.language.blocks.foreach"><a class="anchor" href="#_ugr.tools.ruta.language.blocks.foreach"></a>2.13.2. FOREACH</h4>
<div class="paragraph">
<p>The syntax of the FOREACH block is very similar to the common BLOCK construct,  but the execution of the contained rules can lead to other results.
the execution of the rules is, however, different.
Here, all contained rules are applied on each matched annotation consecutively.
In a BLOCK construct, each rule is applied within the window of each matched annotation.
The differences can be summarized with:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The FOREACH does not restrict the window for the contained rules. The rules are able to match on the complete document, or at least  within the window defined by previous BLOCK definitions.</p>
</li>
<li>
<p>The Identifier of the FORACH block (the part within the parentheses) declares a new local annotation variable. The match annotations of the head rule are assign to this variable for each loop.</p>
</li>
<li>
<p>It is expected that the local variable is part of each rule within the FOREACH block. The start anchor of each rule is set to the rule element that contains the annotation as a matching condition. If not another start anchor is defined before the variable.</p>
</li>
<li>
<p>An additional optional boolean parameter specifies the direction of the matching process. With the default value <code>true</code>, the loop will start with the first annotation continuing with the following annotations. If set to false, the loop will start with the last annotation continuing with the previous annotations.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The following example illustrates the syntax and semantic of the FOREACH block:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>FOREACH(num, true) NUM{}{
    num{-&gt; SpecialNum} CW;
    SW{-&gt; T5} num{-&gt; SpecialNum};
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The first line specifies that the FOREACH block iterates over all annotations of the type NUM and assigns each matched annotation to a new local variable named <code>num</code>.
The block contains two rules.
Both rules start their matching process with the rule element with the matching condition <code>num</code>,  meaning that they match directly on the annotation match by the head rule.
While the first rule validates  if there is a capitalized word following the number, the second rule validates that the is a small written word before the number.
Thus, this construct annotates number efficiently with annotations of the type <code>SpecialNum</code> dependent on their surrounding.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_ugr.tools.ruta.language.inlined"><a class="anchor" href="#_ugr.tools.ruta.language.inlined"></a>2.14. Inlined rules</h3>
<div class="paragraph">
<p>A rule element can have a few optional parts, e.g., the quantifier or the curly brackets with conditions and actions.
After the part with the conditions and actions, the rule element can also contain an optional part with inlined rules.
These rules are applied in the context of the rule element similar to the rules within a block construct: The rules will try to match within the window specified by the current match of the rule element.
There are two types of inlined rules.
If the curly brackets start with the symbol &#8220;&#8594;&#8221; , the inlined rules will only be applied for successful matches of the surrounding rule.
This behavior is very similar to the block construct.
However, there are also some differences, e.g., inlined rules do not specify a namespace, may not contain declarations and cannot be called by other rules.
If the curly brackets start with the symbol &#8220;&#8592;&#8221; , then the inlined rules are interpreted as some sort of condition.
The surrounding rules will only match, if one of the inlined rules was successfully applied.
A rule element may be extended with several inlined rule blocks of the same type.
The functionality introduced by inlined rules is illustrated with a few examples:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>Sentence{} -&gt; {NUM{-&gt; NumBeforeWord} W;};
Sentence{-&gt; SentenceWithNumBeforeWord} &lt;- {NUM W;};</code></pre>
</div>
</div>
<div class="paragraph">
<p>The first rule in this example matches on each &#8220;Sentence&#8221; annotation and applies the inlined rule within each matched sentence.
The inlined rule matches on numbers followed by a word and annotates the number with an annotation of the type &#8220;NumBeforeWord&#8221; . The second rule matches on each sentence and applies the inlined rule within each sentence.
Note that the inlined rule contains no actions.
The rule matches only successfully on a sentence if one of the inlined rules was successfully applied.
In this case, the sentence is only annotated with an annotation of the type &#8220;SentenceWithNumBeforeWord&#8221; , if the sentence contains a number followed by a word.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>Document.language == "en"{} -&gt; {
  PERIOD #{} &lt;- {
      COLON COLON % COMMA COMMA;
    }
    PERIOD{-&gt; SpecialPeriod};
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This examples combines both types of inlined rules.
First, the rule matches on document annotations with the language feature set to &#8220;en&#8221; . Only for those documents, the first inner rule is applied.
The inner rule matches on everything between two period, but only if the text span between the period fulfills two conditions: There must be two successive colons and two successive commas within the window of the matched part of the wildcard.
Only if these constraints are fulfilled, then the last period is annotated with the type &#8220;SpecialPeriod&#8221; .</p>
</div>
</div>
<div class="sect2">
<h3 id="_ugr.tools.ruta.language.macro"><a class="anchor" href="#_ugr.tools.ruta.language.macro"></a>2.15. Macros for conditions and actions</h3>
<div class="paragraph">
<p>UIMA Ruta supports the specification of macros for conditions and action.
Macros allow the aggregation of these elements.
Rule can then refer to the name of the macro in order to include the aggregated conditions or actions.
The syntax of macros is specified in <a href="#_ugr.tools.ruta.language.syntax">Section 2.1</a> . The functionality is illustrated with the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>CONDITION CWorPERIODor(TYPE t) = OR(IS(CW),IS(PERIOD),IS(t));
ACTION INC(VAR INT i, INT inc) = ASSIGN(i,i+inc);
INT counter = 0;
ANY{CWorPERIODor(Bold)-&gt;INC(counter,1)};</code></pre>
</div>
</div>
<div class="paragraph">
<p>The first line in this example declares a new macro condition with the name &#8220;CWorPERIODor&#8221; with one annotation type argument named &#8220;t&#8221; . The condition is fulfilled if the matched text is either a CW annotation, a PERIOD annotation or an annotation of the given type t.
The second line declares a new macro action with the name &#8220;INC&#8221; and two integer arguments &#8220;i&#8221; and &#8220;inc&#8221; . The keyword &#8220;VAR&#8221; indicated that the first argument should be treated as a variable meaning that the actions of the macro can assign new values to the given argument.
Else only the value of the argument would be accessible to the actions.
The action itself just contains an ASSIGN action, which add the second argument to the variable given in the first argument.
The rule in line 4 finally matches on each annotation of the type ANY and validates if the matched position is either a CW, a PERIOD or an annotation of the type Bold.
If this is the case, then value of the variable counter defined in line 3 is incremented by 1.</p>
</div>
</div>
<div class="sect2">
<h3 id="_ugr.tools.ruta.language.score"><a class="anchor" href="#_ugr.tools.ruta.language.score"></a>2.16. Heuristic extraction using scoring rules</h3>
<div class="paragraph">
<p>Diagnostic scores are a well known and successfully applied knowledge formalization pattern for diagnostic problems.
Single known findings valuate a possible solution by adding or subtracting points on an account of that solution.
If the sum exceeds a given threshold, then the solution is derived.
One of the advantages of this pattern is the robustness against missing or false findings, since a high number of findings is used to derive a solution.
The UIMA Ruta system tries to transfer this diagnostic problem solution strategy to the information extraction problem.
In addition to a normal creation of a new annotation, a MARKSCORE action can add positive or negative scoring points to the text fragments matched by the rule elements.
The current value of heuristic points of an annotation can be evaluated by the SCORE condition, which can be used in an additional rule to create another annotation.
In the following, the heuristic extraction using scoring rules is demonstrated by a short example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>Paragraph{CONTAINS(W,1,5)-&gt;MARKSCORE(5,Headline)};
Paragraph{CONTAINS(W,6,10)-&gt;MARKSCORE(2,Headline)};
Paragraph{CONTAINS(Emph,80,100,true)-&gt;MARKSCORE(7,Headline)};
Paragraph{CONTAINS(Emph,30,80,true)-&gt;MARKSCORE(3,Headline)};
Paragraph{CONTAINS(CW,50,100,true)-&gt;MARKSCORE(7,Headline)};
Paragraph{CONTAINS(W,0,0)-&gt;MARKSCORE(-50,Headline)};
Headline{SCORE(10)-&gt;MARK(Realhl)};
Headline{SCORE(5,10)-&gt;LOG("Maybe a headline")};</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the first part of this rule set, annotations of the type paragraph receive scoring points for a headline annotation, if they fulfill certain CONTAINS conditions.
The first condition, for example, evaluates to true, if the paragraph contains one word up to five words, whereas the fourth conditions is fulfilled, if the paragraph contains thirty up to eighty percent of emph annotations.
The last two rules finally execute their actions, if the score of a headline annotation exceeds ten points, or lies in the interval of five to ten points, respectively.</p>
</div>
</div>
<div class="sect2">
<h3 id="_ugr.tools.ruta.language.modification"><a class="anchor" href="#_ugr.tools.ruta.language.modification"></a>2.17. Modification</h3>
<div class="paragraph">
<p>There are different actions that can modify the input document, like DEL, COLOR and REPLACE.
However, the input document itself can not be modified directly.
A separate engine, the Modifier.xml, has to be called in order to create another CAS view with the (default) name "modified". In that document, all modifications are executed.</p>
</div>
<div class="paragraph">
<p>The following example shows how to import and call the Modifier.xml engine.
The example is explained in detail in <a href="#_ugr.tools.ruta.overview.examples">Section 1.4</a> .</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>ENGINE utils.Modifier;
Date{-&gt; DEL};
MoneyAmount{-&gt; REPLACE("&lt;MoneyAmount/&gt;")};
Document{-&gt; COLOR(Headline, "green")};
Document{-&gt; EXEC(Modifier)};</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_ugr.tools.ruta.language.external_resources"><a class="anchor" href="#_ugr.tools.ruta.language.external_resources"></a>2.18. External resources</h3>
<div class="paragraph">
<p>Imagine you have a set of documents containing many different first names.
(as example we use a short list, containing the first names &#8220;Frank&#8221; , &#8220;Peter&#8221; , &#8220;Jochen&#8221; and &#8220;Martin&#8221; ) If you like to annotate all of them with a &#8220;FirstName&#8221; annotation, then you could write a script using the rule <code>("Frank" | "Peter" | "Jochen" | "Martin"){&#8594;MARK(FirstName)};</code>. This does exactly what you want, but not very handy.
If you like to add new first names to the list of recognized first names you have to change the rule itself every time.
Moreover, writing rules with possibly hundreds of first names is not really practically realizable and definitely not efficient, if you have the list of first names already as a simple text file.
Using this text file directly would reduce the effort.</p>
</div>
<div class="paragraph">
<p>UIMA Ruta provides, therefore, two kinds of external resources to solve such tasks more easily: WORDLISTs and WORDTABLEs.</p>
</div>
<div class="sect3">
<h4 id="_wordlists"><a class="anchor" href="#_wordlists"></a>2.18.1. WORDLISTs</h4>
<div class="paragraph">
<p>A WORDLIST is a list of text items.
There are three different possibilities of how to provide a WORDLIST to the UIMA Ruta system.</p>
</div>
<div class="paragraph">
<p>The first possibility is the use of simple text files, which contain exactly one list item per line.
For example, a list "FirstNames.txt" of first names could look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>Frank
Peter
Jochen
Martin</code></pre>
</div>
</div>
<div class="paragraph">
<p>First names within a document containing any number of these listed names, could be annotated by using <code>Document{&#8594;MARKFAST(FirstName, 'FirstNames.txt')};</code> , assuming an already declared type FirstName.
To make this rule recognizing more first names, add them to the external list.
You could also use a WORLIST variable to do the same thing as follows, which is preferable:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>WORDLIST FirstNameList = 'FirstNames.txt';
DECLARE FirstName;
Document{-&gt;MARKFAST(FirstName, FirstNameList)};</code></pre>
</div>
</div>
<div class="paragraph">
<p>Another possibility compared to the plain text files to provide WORDLISTs is the use of compiled &#8220;tree word list&#8221; s.
The file ending for this is &#8220;.twl&#8221; A tree word list is similar to a trie.
It is a XML-file that contains a tree-like structure with a node for each character.
The nodes themselves refer to child nodes that represent all characters that succeed the character of the parent node.
For single word entries the resulting complexity is O(m*log(n)) instead of O(m*n) for simple text files.
Here m is the amount of basic annotations in the document and n is the amount of entries in the dictionary.
To generate a tree word list, see <a href="#_section.ugr.tools.ruta.workbench.create_dictionaries">Section 3.11</a> . A tree word list is used in the same way as simple word lists, for example <code>Document{&#8594;MARKFAST(FirstName, 'FirstNames.twl')};</code> .</p>
</div>
<div class="paragraph">
<p>A third kind of usable WORDLISTs are &#8220;multi tree word list&#8221; s.
The file ending for this is &#8220;.mtwl&#8221; . It is generated from several ordinary WORDLISTs given as simple text files.
It contains special nodes that provide additional information about the original file.
These kind of WORDLIST is useful, if several different WORDLISTs are used within a UIMA Ruta script.
Using five different lists results in five rules using the MARKFAST action.
The documents to annotate are thus searched five times resulting in a complexity of 5*O(m*log(n)) With a multi tree word list this can be reduced to about O(m*log(5*n)). To generate a multi tree word list, see <a href="#_section.ugr.tools.ruta.workbench.create_dictionaries">Section 3.11</a> To use a multi tree word list UIMA Ruta provides the action TRIE.
If for example two word lists &#8220;FirstNames.txt&#8221; and &#8220;LastNames.txt&#8221; have been merged in the multi tree word list &#8220;Names.mtwl&#8221; , then the following rule annotates all first names and last names in the whole document:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>WORDLIST Names = 'Names.mtwl';
Declare FirstName, LastName;
Document{-&gt;TRIE("FirstNames.txt" = FirstName, "LastNames.txt" = LastName,
    Names, false, 0, false, 0, "")};</code></pre>
</div>
</div>
<div class="paragraph">
<p>Only if the wordlist is explicitly declared with WORDLIST, then also a StringExpression including variables can be applied to specify the file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>STRING package ="my/package/";
WORDLIST FirstNameList = "" + package + "FirstNames.txt';
DECLARE FirstName;
Document{-&gt;MARKFAST(FirstName, FirstNameList)};</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_wordtables"><a class="anchor" href="#_wordtables"></a>2.18.2. WORDTABLEs</h4>
<div class="paragraph">
<p>WORDLISTs have been used to annotate all occurrences of any list item in a document with a certain type.
Imagine now that each annotation has features that should be filled with values dependent on the list item that matched.
This can be achieved with WORDTABLEs.
Let us, for example, assume we want to annotate all US presidents within a document.
Moreover, each annotation should contain the party of the president as well as the year of his inauguration.
Therefore we use an annotation type <code>DECLARE Annotation PresidentOfUSA(STRING party, INT yearOfInauguration)</code>. To achieve this, it is recommended to use WORDTABLEs.</p>
</div>
<div class="paragraph">
<p>A WORDTABLE is simply a comma-separated file (.csv), which actually uses semicolons for separation of the entries.
For our example, such a file named &#8220;presidentsOfUSA.csv&#8221; could look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>Bill Clinton;democrats;1993
George W. Bush;republicans;2001
Barack Obama;democrats;2009</code></pre>
</div>
</div>
<div class="paragraph">
<p>To annotate our documents we could use the following set of rules:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>WORDTABLE presidentsOfUSA = 'presidentsOfUSA.csv';
DECLARE Annotation PresidentOfUSA(STRING party, INT yearOfInauguration);
Document{-&gt;MARKTABLE(PresidentOfUSA, 1, presidentsOfUSA, "party" = 2,
		"yearOfInauguration" = 3)};</code></pre>
</div>
</div>
<div class="paragraph">
<p>Only if the wordtable is explicitly declared with WORDTABLE, then also a StringExpression including variables can be applied to specify the file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>STRING package ="my/package/";
WORDTABLE presidentsOfUSA = "" + package + "presidentsOfUSA.csv";</code></pre>
</div>
</div>
<div class="paragraph">
<p>By default, whitespaces are removed by activating the parameter &#8220;dictRemoveWS&#8221;  for WORDLIST and WORDTABLE when the dictionary is loaded.
In the special case when whitespace are relevant, e.g.,  specific patterns of whitespaces need to be detected by the dictionary lookup,  then the analysis engine needs to be configured differently.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_ugr.tools.ruta.language.regexprule"><a class="anchor" href="#_ugr.tools.ruta.language.regexprule"></a>2.19. Simple Rules based on Regular Expressions</h3>
<div class="paragraph">
<p>The UIMA Ruta language includes, additionally to the normal rules, a simplified rule syntax for processing regular expressions.
These simple rules consist of two parts separated by &#8220;&#8594;&#8221; : The left part is the regular expression (flags: DOTALL and MULTILINE), which may contain capturing groups.
The right part defines, which kind of annotations should be created for each match of the regular expression.
If a type is given without a group index, then an annotation of that type is created for the complete regular expression match, which corresponds to group 0.
Each type can be extended with additional feature assignments, which store the value of the given expression in the feature specified by the given StringExpression.
However, if the expression refers to a number (NumberExpression), then the match of the corresponding capturing group is applied.
These simple rules can be restricted to match only within certain annotations using the BLOCK construct, and ignore all filtering settings.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>RegExpRule        -&gt; StringExpression "-&gt;" GroupAssignment
                     ("," GroupAssignment)* ";"
GroupAssignment   -&gt; TypeExpression FeatureAssignment?
                     | NumberEpxression "=" TypeExpression
                       FeatureAssignment?
FeatureAssignment -&gt; "(" StringExpression "=" Expression
                      ("," StringExpression "=" Expression)* ")"</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example contains a simple rule, which is able to create annotations of two different types.
It creates an annotation of the type &#8220;T1&#8221; for each match of the complete regular expression and an annotation of the type &#8220;T2&#8221; for each match of the first capturing group.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>"A(.*?)C" -&gt; T1, 1 = T2;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_ugr.tools.ruta.language.extensions"><a class="anchor" href="#_ugr.tools.ruta.language.extensions"></a>2.20. Language Extensions</h3>
<div class="paragraph">
<p>The UIMA Ruta language can be extended with external blocks, actions, conditions, type functions, boolean functions, string functions and number functions.
The block constructs are able to introduce new rule matching paradigms.
The other extensions provide atomic elements to the language, e.g., a condition that evaluates project-specific properties.
An exemplary implementation of each kind of extension can be found in the project &#8220;ruta-ep-example-extensions&#8221; and a simple UIMA Ruta project, which uses these extensions, is located at &#8220;ExtensionsExample&#8221; . Both projects are part of the source release of UIMA ruta and are located in the &#8220;example-projects&#8221; folder.</p>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.language.extensions.core_ext"><a class="anchor" href="#_ugr.tools.ruta.language.extensions.core_ext"></a>2.20.1. Provided Extensions</h4>
<div class="paragraph">
<p>The UIMA Ruta language already provides extensions besides the exemplary elements.
The project ruta-core-ext contains the implementation for the analysis engine and the project ruta-ep-core-ext contains the integration in the UIMA Ruta Workbench.</p>
</div>
<div class="sect4">
<h5 id="_ugr.tools.ruta.language.extensions.core_ext.documentblock"><a class="anchor" href="#_ugr.tools.ruta.language.extensions.core_ext.documentblock"></a>DOCUMENTBLOCK</h5>
<div class="paragraph">
<p>This additional block construct applies the contained statements/rules on the complete document independent of previous windows and restrictions.
It resets the matching context, but otherwise behaves like a normal BLOCK.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>BLOCK(ex) NUM{}{
  DOCUMENTBLOCK W{}{
    // do something with the words
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The example contains two blocks.
The first block iterates over all numbers (NUM). The second block resets the match context and matches on all words (W), for every previously matched number.</p>
</div>
</div>
<div class="sect4">
<h5 id="_ugr.tools.ruta.language.extensions.core_ext.onlyfirst"><a class="anchor" href="#_ugr.tools.ruta.language.extensions.core_ext.onlyfirst"></a>ONLYFIRST</h5>
<div class="paragraph">
<p>This additional block construct applies the contained statements/rules only until the first one was successfully applied.
The following example provides an overview of the syntax:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>ONLYFIRST Document{}{
  Document{CONTAINS(Keyword1) -&gt; Doc1};
  Document{CONTAINS(Keyword2) -&gt; Doc2};
  Document{CONTAINS(Keyword3) -&gt; Doc3};
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The block contains three rules each evaluating if the document contains a specific annotation of the type Keyword1/2/3.
If the first rule is able to match, then the other two rules will not try to apply.
Straightforwardly, if the first rule failed to match and the second rules is able to match, then the third rule will not try to be applied.</p>
</div>
</div>
<div class="sect4">
<h5 id="_ugr.tools.ruta.language.extensions.core_ext.onlyonce"><a class="anchor" href="#_ugr.tools.ruta.language.extensions.core_ext.onlyonce"></a>ONLYONCE</h5>
<div class="paragraph">
<p>Rules within this block construct will stop after the first successful match.
The following example provides an overview of the syntax:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>ONLYONCE Document{}{
  CW{-&gt; FirstCW};
  NUM+{-&gt; FirstNumList};
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The block contains two rules.
The first rule will annotate the first capitalized word of the document with the type FirstCW.
All further possible matches will be skipped.
The second rule will annotate the first sequence of numbers with the type FirstNumList.
The greedy behavior of the quantifiers is not changed by the ONLYONCE block.</p>
</div>
</div>
<div class="sect4">
<h5 id="_ugr.tools.ruta.language.extensions.core_ext.stringfunctions"><a class="anchor" href="#_ugr.tools.ruta.language.extensions.core_ext.stringfunctions"></a>Stringfunctions</h5>
<div class="paragraph">
<p>In order to manipulate Strings in variables a bunch of Stringfunctions have been added.
They will all be presented with a short example demonstrating their use.</p>
</div>
<div class="sect5">
<h6 id="_firstchartouppercaseistringexpression_expr"><a class="anchor" href="#_firstchartouppercaseistringexpression_expr"></a>firstCharToUpperCase(IStringExpression expr)</h6>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>STRING s;
STRINGLIST sl;
SW{-&gt; MATCHEDTEXT(s), ADD(sl, firstCharToUpperCase(s))};
CW{INLIST(sl) -&gt; Test};</code></pre>
</div>
</div>
<div class="paragraph">
<p>This example declares a STRING and a STRINGLIST.
Afterwards for every small-written word, the according word with a capital first Character is added to the STRINGLIST.
This might be helpful in German Named-Entity-Recognition where you will encounter "der blonde Junge&#8230;&#8203;" and "der Blonde", both map to the same entity.
Applied to the word "blonde" you can then also track the second appearance of that Person.
In the last line a rule marks all words in the STRINGLIST as a Test Annotation.</p>
</div>
</div>
<div class="sect5">
<h6 id="_replacefirstistringexpression_expr_istringexpressionsearchtermistringexpressionreplacement"><a class="anchor" href="#_replacefirstistringexpression_expr_istringexpressionsearchtermistringexpressionreplacement"></a>replaceFirst(IStringExpression expr, IStringExpressionsearchTerm,IStringExpressionreplacement)</h6>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>STRING s;
STRINGLIST sl;
CW{-&gt; MATCHEDTEXT(s), ADD(sl, replaceFirst(s,"e","o"))};
CW{INLIST(sl) -&gt; Test};</code></pre>
</div>
</div>
<div class="paragraph">
<p>This example declares a STRING and a STRINGLIST.
Next every capital Word CW is added to the STRINGLIST, however the first "e" is going to be replaced by "o". Afterwards all instances of the STRINGLIST are matched with all present CWs and annotated as a Test Annotation if a match occurs.</p>
</div>
</div>
<div class="sect5">
<h6 id="_replaceallistringexpression_expr_istringexpressionsearchtermistringexpressionreplacement"><a class="anchor" href="#_replaceallistringexpression_expr_istringexpressionsearchtermistringexpressionreplacement"></a>replaceAll(IStringExpression expr, IStringExpressionsearchTerm,IStringExpressionreplacement)</h6>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>STRING s;
STRINGLIST sl;
CW{-&gt; MATCHEDTEXT(s), ADD(sl, replaceAll(s,"e","o"))};
CW{INLIST(sl) -&gt; Test};</code></pre>
</div>
</div>
<div class="paragraph">
<p>This example declares a STRING and a STRINGLIST.
Next every capital Word CW is added to the STRINGLIST, however similar to the above example at first there is going to be a replacement.
This time all "e"`s are going to be replaced by "o"`s.
Afterwards all instances of the STRINGLIST are matched with all present CWs and annotated as a Test Annotation if a match occurs.</p>
</div>
</div>
<div class="sect5">
<h6 id="_substringistringexpression_expr_inumberexpression_frominumberexpression_to"><a class="anchor" href="#_substringistringexpression_expr_inumberexpression_frominumberexpression_to"></a>substring(IStringExpression expr, INumberExpression from,INumberExpression to)</h6>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>STRING s;
STRINGLIST sl;
CW{-&gt; MATCHEDTEXT(s), ADD(sl, substring(s,0,9))};
SW{INLIST(sl) -&gt; Test};</code></pre>
</div>
</div>
<div class="paragraph">
<p>This example declares a STRING and a STRINGLIST.
Imagine you found the word "Alexanderplatz" but you only want to continue with the word "Alexander". This snippet shows how this can be done by using the Stringfunctions in RUTA.
If a word has less character than specified in the arguments, nothing will be executed.</p>
</div>
</div>
<div class="sect5">
<h6 id="_tolowercaseistringexpression_expr"><a class="anchor" href="#_tolowercaseistringexpression_expr"></a>toLowerCase(IStringExpression expr)</h6>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>STRING s;
STRINGLIST sl;
CW{-&gt; MATCHEDTEXT(s), ADD(sl, toLowerCase(s))};
SW{INLIST(sl) -&gt; Test};</code></pre>
</div>
</div>
<div class="paragraph">
<p>This example declares a STRING and a STRINGLIST.
A problem you might encounter is that you want to know whether the first word of a sentence is really a noun.(Again more or less german related) By using this function you could add all words that start a sentence(which usually means a capitalized word) to a list as in this example.
Then test if it also appears within the text but this time as lowercase.
As a result you could change its POS-Tag.</p>
</div>
</div>
<div class="sect5">
<h6 id="_touppercaseistringexpression_expr"><a class="anchor" href="#_touppercaseistringexpression_expr"></a>toUpperCase(IStringExpression expr)</h6>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>STRING s;
STRINGLIST sl;
CW{-&gt; MATCHEDTEXT(s), ADD(sl, toUpperCase(s))};
SW{INLIST(sl) -&gt; T1};</code></pre>
</div>
</div>
<div class="paragraph">
<p>This example declares a STRING and a STRINGLIST.
A typical scenario for its use might be Named-Entity-Recognition.
This time you want to find all organizations given an input document.
At first you might track-down all fully capitalized words.
As a second step you can use this function and iterate over all CW insances and compare the found instance with all the uppercase organizations that were found before.</p>
</div>
</div>
<div class="sect5">
<h6 id="_containsistringexpression_expristringexpression_contains"><a class="anchor" href="#_containsistringexpression_expristringexpression_contains"></a>contains(IStringExpression expr,IStringExpression contains)</h6>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>w:W{contains(w.ct, "er")-&gt; Test};</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you want to find all words that contain a given charactersequence.
Assume again you are in a NER-Task you found the token "Alexanderplatz" using this function you can track down the names that are part of a given token.
This example uses a BLOCK to iterate over each word and then assigns whether the text of that word contains the given char-sequence.
If so it is annotated as a Test annotation.</p>
</div>
</div>
<div class="sect5">
<h6 id="_endswithistringexpression_expristringexpression_expr"><a class="anchor" href="#_endswithistringexpression_expristringexpression_expr"></a>endsWith(IStringExpression expr,IStringExpression expr)</h6>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>w:W{endsWith(w.ct, "str")-&gt; Test};</code></pre>
</div>
</div>
<div class="paragraph">
<p>Assume you found the suffix "str" as a strong indicator whether a given token represents location (a street) by using this function you can now easily identify all of those words, given a valid suffix.</p>
</div>
</div>
<div class="sect5">
<h6 id="_startswithistringexpression_expristringexpression_expr"><a class="anchor" href="#_startswithistringexpression_expristringexpression_expr"></a>startsWith(IStringExpression expr,IStringExpression expr)</h6>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>w:W{startsWith(w.ct, "sprech")-&gt; Test};</code></pre>
</div>
</div>
<div class="paragraph">
<p>Given a stem of a word you want to mark every instance that was possibly derived from that stem.
If you decide to use that function you can detect all those words in 1 line and in a next step mark all of them as an Annotationtype of choice.</p>
</div>
</div>
<div class="sect5">
<h6 id="_equalsistringexpression_expristringexpression_expr_and_equalsignorecaseexprexpr"><a class="anchor" href="#_equalsistringexpression_expristringexpression_expr_and_equalsignorecaseexprexpr"></a>equals(IStringExpression expr,IStringExpression expr) and equalsIgnoreCase(expr,expr)</h6>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>STRING s;
STRING s2 = "Kenny";
BOOLEAN a;
BLOCK(forEACH) W{}{
    W{-&gt;MATCHEDTEXT(s), ASSIGN(a,equals(s,s2))};
    W{-&gt;MATCHEDTEXT(s), ASSIGN(a,equalsIgnoreCase(s,s2))};
    W{a -&gt;Test};
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>These functions check whether both arguments are equal in terms of the text of the token that they contain.</p>
</div>
</div>
<div class="sect5">
<h6 id="_isemptyistringexpression_expr_and_equalsignorecaseexprexpr"><a class="anchor" href="#_isemptyistringexpression_expr_and_equalsignorecaseexprexpr"></a>isEmpty(IStringExpression expr) and equalsIgnoreCase(expr,expr)</h6>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>STRING s;
BOOLEAN a;
BLOCK(forEACH) W{}{
    W{-&gt;MATCHEDTEXT(s), ASSIGN(a,isEmpty(s))};
    W{a -&gt;Test};
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>An equivalent function to the Java Stringlibrary.
It checks whether or not a given variable contains an empty Stringliteral "" or not.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_ugr.tools.ruta.language.extensions.core_ext.typefunctions"><a class="anchor" href="#_ugr.tools.ruta.language.extensions.core_ext.typefunctions"></a>typeFromString</h5>
<div class="paragraph">
<p>This function takes a string expression and tries to find the corresponding type.
Short names are supported but need to be unambiguous.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>CW{-&gt; typeFromString("Person")}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this example, each <code>CW</code> annotation is  annotated with an annotation of the type <code>Person</code>.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.language.extensions.new"><a class="anchor" href="#_ugr.tools.ruta.language.extensions.new"></a>2.20.2. Adding new Language Elements</h4>
<div class="paragraph">
<p>The extension of the UIMA Ruta language is illustrated using an example on how to add a new condition.
Other language elements can be specified straightforwardly by using the corresponding interfaces and extensions.</p>
</div>
<div class="paragraph">
<p>Three classes need to be implemented for adding a new condition that also is resolved in the UIMA Ruta Workbench:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>An implementation of the condition extending AbstractRutaCondition.</p>
</li>
<li>
<p>An implementation of IRutaConditionExtension, which provides the condition implementation to the engine.</p>
</li>
<li>
<p>An implementation of IIDEConditionExtension, which provides the condition for the UIMA Ruta Workench.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The exemplary project provides implementation of all possible language elements.
This project contains the implementations for the analysis engine and also the implementation for the UIMA Ruta Workbench, and is therefore an Eclipse plugin (mind the pom file).</p>
</div>
<div class="paragraph">
<p>Concerning the ExampleCondition condition extension, there are four important spots/classes:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>ExampleCondition.java provides the implementation of the new condition, which evaluates dates.</p>
</li>
<li>
<p>ExampleConditionExtension.java provides the extension for the analysis engine. It knows the name of the condition, its implementation, can create new instances of that condition, and is able to verbalize the condition for the explanation components.</p>
</li>
<li>
<p>ExampleConditionIDEExtension provides the syntax check for the editor and the keyword for syntax coloring.</p>
</li>
<li>
<p>The plugin.xml defines the extension for the Workbench:</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>&lt;extension point="org.apache.uima.ruta.ide.conditionExtension"&gt;
  &lt;condition
    class="org.apache.uima.ruta.example.extensions.
      ExampleConditionIDEExtension"
    engine="org.apache.uima.ruta.example.extensions.
      ExampleConditionExtension"&gt;
  &lt;/condition&gt;
&lt;/extension&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the UIMA Ruta Workbench is not used or the rules are only applied in UIMA pipelines, only the ExampleCondition and ExampleConditionExtension are needed, and org.apache.uima.ruta.example.extensions.ExampleConditionExtension needs to be added to the additionalExtensions parameter of your UIMA Ruta analysis engine (descriptor).</p>
</div>
<div class="paragraph">
<p>Adding new conditions using Java projects in the same workspace has not been tested yet, but at least the Workbench support will be missing due to the inclusion of extensions using the extension point mechanism of Eclipse.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_ugr.tools.ruta.language.internal_indxexing"><a class="anchor" href="#_ugr.tools.ruta.language.internal_indxexing"></a>2.21. Internal indexing and reindexing</h3>
<div class="paragraph">
<p>UIMA Ruta, or to be more precise the main analysis engine RutaEngine, creates,  stores and updates additional indexing information directly in the CAS.
This indexing is not related to the annotation indexes of UIMA itself.
The internal indexing provides additional information, which is only utilized  by the Ruta rules.
This section provides an overview on why and how it is integrated in UIMA Ruta, and how Ruta can be configured in order to optimize its performance.</p>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.language.internal_indxexing.why"><a class="anchor" href="#_ugr.tools.ruta.language.internal_indxexing.why"></a>2.21.1. Why additional indexing?</h4>
<div class="paragraph">
<p>The internal indexing plays a an essential role in different parts of functionality within Ruta.
The need for the indexing is motivated by two main and important features.</p>
</div>
<div class="paragraph">
<p>Ruta provides different language elements like conditions, which are fulfilled  depending on some investigation of the CAS annotation indexes.
There are several  conditions like PARTOF, which require many index operations in the worst case.
Here, potentially the complete index needs to be iterated in order to validate if a specific annotation  is part of another annotation of a specific type.
This check needs to be performed  for each considered annotation, for each rule match and for each rule where a PARTOF  condition is used.
Without additional internal indexing, Ruta would be too slow to  actually be useful.
With this feature, the process is just a fast lookup.
This situation applies also for many other language elements and  conditions like STARTSWITH and ENDSWITH.</p>
</div>
<div class="paragraph">
<p>A second necessity is the coverage-based visibility concept of Ruta.
Annotations and any text spans are invisible if their begin or end is covered by some  invisible annotation, i.e., an annotation of a type that is configured to be invisible.
This is a powerful feature that enables many different engineering approaches and makes the rules more maintainable as well.
For a (reasonably fast) implementation of this feature,  it is necessary to know for each position, if it is covered by annotations of specific types.</p>
</div>
<div class="paragraph">
<p>The internal indexing comes, however, at some costs.
The indexing requires time and memory.
The information needs to be collected and/or updated for every Ruta script (RutaEngine)  in a pipeline.
This may be expensive operation-wise, if the scripts consist of many annotations to be checked.
Straightforward, the storage of this information at potentially all text positions  requires a lot memory.
Nevertheless, the advantages outweigh the disadvantages considerably.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.language.internal_indxexing.how"><a class="anchor" href="#_ugr.tools.ruta.language.internal_indxexing.how"></a>2.21.2. How is it stored, created and updated?</h4>
<div class="paragraph">
<p>The internal indexing refers to three types of information that is additionally stored:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>All annotations of all relevant types that begin at a position.</p>
</li>
<li>
<p>All annotations of all relevant types that end at a position.</p>
</li>
<li>
<p>All types of annotations that cover a position.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The information is stored in additional annotations of the type RutaBasic,  which provides by implementation, and not by features, additional fields for these three kinds of information.
RutaBasic types provide a complete disjunct  partitioning of the document.
They begin and end at every position where an  annotation starts and ends.
This also includes, for examples, one RutaBasic for each  SPACE annotation, registering which annotation start and end at these offsets.
They are automatically created and also extended if new smaller annotations are added.
Their initial creation is called &#8220;indexing&#8221; and their updating, if RutaBasics are available, while other Java analysis engines potentially added or removed annotations, is called &#8220;reindexing&#8221;.</p>
</div>
<div class="paragraph">
<p>There are several configuration  parameters (see parameters with INDEX and REINDEX in their name) that can influence what types and annotations are indexed and reindexed.
In the default configuration, all annotations are indexed, but only new annotations  are reindexed (ReindexUpdateMode ADDITIVE). This means that if an analysis engine in between two RutaEngine removes some annotations, the second RutaEngine will not be up to date.
A rule which relies on the internal indexing will match differently for these annotations, e.g., a PARTOF condition is still fulfilled although the annotation is not present in the  UIMA indexes anymore.
This problem can be avoided (if necessary) either by switching to a more costly ReindexUpdateMode COMPLETE, or by updating the internal indexing directly in the Java analysis engine by using the class RutaBasicUtils.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.language.internal_indxexing.optimize"><a class="anchor" href="#_ugr.tools.ruta.language.internal_indxexing.optimize"></a>2.21.3. How to optimize the performance?</h4>
<div class="paragraph">
<p>The are many different options and possibilities to optimize the runtime performance and memory footprint of a Ruta script, by configuring the RutaEngine.
The most useful configuration,  however, depends on the actual situation: How much information is available about the pipeline and the types of annotations and their update operations? In the following, a selection  of optimizations are discussed.</p>
</div>
<div class="paragraph">
<p>If there is a RutaEngine in a pipeline, and either the previous analysis engine was also  a RutaEngine or it is known that the analysis engines before (until the last RutaEngine) did not modify any (relevant) annotations, then the ReindexUpdateMode NONE can be applied, which simply  skips the internal reindexing.
This can improve the runtime performance.</p>
</div>
<div class="paragraph">
<p>The configuration parameters indexOnly can be restricted to relevant types.
The parameter indexSkipTypes can be utilized to specify types of annotations that are not relevant.
These types can include more technical annotations for metadata, logging or debug information.
Thus, the set of types that need to be considered for internal indexing can be restricted, which makes the indexing faster and requires less memory.</p>
</div>
<div class="paragraph">
<p>An extension to this is the parameter indexOnlyMentionedTypes/reindexOnlyMentionedTypes.
Here, the relevant types are collected using the actual script:  the types that are actually used in the rules and thus their internal indexing needs to be up to date.
This can increase the indexing speed.
This feature is highlighted in the following example: Considering a larger pipeline with many annotations of different types, and also with many  modifications since the last RutaEngine, a script with one rule does not require much reindexing, except the exclusive types used in this rule.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_ugr.tools.ruta.workbench"><a class="anchor" href="#_ugr.tools.ruta.workbench"></a>3. Apache UIMA Ruta Workbench</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The Apache UIMA Ruta Workbench, which is made available as an Eclipse-plugin, offers a powerful environment for creating and working on UIMA Ruta projects.
It provides two main perspectives and several views to develop, run, debug, test and evaluate UIMA Ruta rules in a comfortable way, supporting many of the known Eclipse features, e.g., auto-completion.
Moreover, it makes the creation of dictionaries like tree word lists easy and supports machine learning methods, which can be used within a knowledge engineering process.
The following chapter starts with the installation of the workbench, followed by a description of all its features.</p>
</div>
<div class="sect2">
<h3 id="_section.ugr.tools.ruta.workbench.install"><a class="anchor" href="#_section.ugr.tools.ruta.workbench.install"></a>3.1. Installation</h3>
<div class="paragraph">
<p>Do the installation of the UIMA Ruta Workbench as follows:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Download, install and start Eclipse. The Eclipse version currently supported by UIMA Ruta is given  on the webpage of the <a href="https://uima.apache.org/ruta.html">project</a>. This is normally the latest version of Eclipse, which can be obtained from the <a href="https://eclipse.org/">eclipse.org</a> download site.</p>
</li>
<li>
<p>Add the Apache UIMA update site ( <a href="http://www.apache.org/dist/uima/eclipse-update-site/">http://www.apache.org/dist/uima/eclipse-update-site/ </a>) to the available software sites in your Eclipse installation. Click on &#8220;Help &#8594; Install New Software&#8221;. This opens the install wizard, which can be seen in <a href="#_figure.ugr.tools.ruta.workbench.install.update">[_figure.ugr.tools.ruta.workbench.install.update]</a></p>
</li>
<li>
<p>Select or enter the Apache UIMA update site (<a href="http://www.apache.org/dist/uima/eclipse-update-site/">http://www.apache.org/dist/uima/eclipse-update-site/ </a>)in field &#8220;Work with:&#8221; and press &#8220;Enter&#8221;.</p>
</li>
<li>
<p>Select &#8220;Apache UIMA Ruta&#8221; and (if not yet installed) &#8220;Apache UIMA Eclipse tooling and runtime support&#8221; by clicking into the related checkbox.</p>
</li>
<li>
<p>Also select &#8220;Contact all update sites during install to find required software `" and click on "`Next&#8221;.</p>
</li>
<li>
<p>On the next page, click &#8220;Next&#8221; again. Now, the license agreement site is displayed. To install UIMA Ruta read the license and choose &#8220;I accept the &#8230;&#8203;&#8221; if you agree to it. Then, click on &#8220;Finish&#8221;</p>
</li>
</ol>
</div>
<div id="_figure.ugr.tools.ruta.workbench.install.update" class="olist arabic">
<ol class="arabic">
<li>
<p>Eclipse update site
image::images/tools/ruta/workbench/install/update.png[Eclipse update site.]</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Now, UIMA Ruta is going to be installed.
After the successful installation, switch to the UIMA Ruta perspective.
To get an overview, see <a href="#_section.ugr.tools.ruta.workbench.overview">Section 3.2</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>It is sometimes necessary to increase to available PermGenSpace by adding <code>-XX:PermSize=64M -XX:MaxPermSize=228M</code> to the config.ini file of your Eclipse installation.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Several times within this chapter we use a UIMA Ruta example project to illustrate the use of the UIMA Ruta Workbench.
The &#8220;ExampleProject&#8221; project is part of the source release of UIMA Ruta (example-projects folder).</p>
</div>
<div class="paragraph">
<p>To import this project into the workbench do &#8220;File &#8594; Import&#8230;&#8203; `" . Select "`Existing Projects into Workspace&#8221; under &#8220;General&#8221; . Select the &#8220;ExampleProject&#8221; directory in your file system as root directory and click on &#8220;Finish&#8221; . The example project is now available in your workspace.</p>
</div>
</div>
<div class="sect2">
<h3 id="_section.ugr.tools.ruta.workbench.overview"><a class="anchor" href="#_section.ugr.tools.ruta.workbench.overview"></a>3.2. UIMA Ruta Workbench Overview</h3>
<div class="paragraph">
<p>The UIMA Ruta Workbench provides two main perspectives.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The &#8220;UIMA Ruta perspective&#8221;, which provides the main functionality for working on UIMA Ruta projects. See <a href="#_section.ugr.tools.ruta.workbench.ruta_perspective">Section 3.4</a>.</p>
</li>
<li>
<p>The &#8220;Explain perspective&#8221;, which provides functionality primarily used to explain how a set of rules are executed on input documents. See <a href="#_section.ugr.tools.ruta.workbench.explain_perspective">Section 3.5</a>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The following image shows the UIMA Ruta perspective.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The UIMA Ruta perspective.
image::images/tools/ruta/workbench/overview/screenshot_ruta_perspective_.png[The UIMA Ruta perspective.]</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>As you can see, the UIMA Ruta perspective provides an editor for editing documents, e.g., UIMA Ruta scripts, and several views for different other tasks.
The Script Explorer, for example, helps to manage your UIMA Ruta projects.</p>
</div>
<div class="paragraph">
<p>The following <a href="#_table.ugr.tools.ruta.workbench.overview.views">Table 6</a> lists all available UIMA Ruta views:</p>
</div>
<table id="_table.ugr.tools.ruta.workbench.overview.views" class="tableblock frame-all grid-all stretch">
<caption class="title">Table 6. UIMA Ruta views</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">View</th>
<th class="tableblock halign-left valign-top">Detailed description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Annotation Test</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">See <a href="#_section.ugr.tools.ruta.workbench.testing.usage">Section 3.8.1</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Applied Rules</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">See <a href="#_section.ugr.tools.ruta.workbench.explain_perspective.applied_rules">Section 3.5.1</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Check Annotations</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">See <a href="#_section.tools.ruta.workbench.check">Section 3.10</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Covering Rules</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">See <a href="#_section.ugr.tools.ruta.workbench.explain_perspective.covering_rules">Section 3.5.5</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Created By</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">See <a href="#_section.ugr.tools.ruta.workbench.explain_perspective.created_by">Section 3.5.7</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Failed Rules</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">See <a href="#_section.ugr.tools.ruta.workbench.explain_perspective.matched_and_failed_rules">Section 3.5.2</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">False Negative</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">See <a href="#_section.ugr.tools.ruta.workbench.testing.usage">Section 3.8.1</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">False Positive</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">See <a href="#_section.ugr.tools.ruta.workbench.testing.usage">Section 3.8.1</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Matched Rules</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">See <a href="#_figure.ugr.tools.ruta.workbench.explain_perspective.matched_and_failed_rules">[_figure.ugr.tools.ruta.workbench.explain_perspective.matched_and_failed_rules]</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Rule Elements</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">See <a href="#_section.ugr.tools.ruta.workbench.explain_perspective.rule_elements">Section 3.5.3</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Rule List</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">See <a href="#_section.ugr.tools.ruta.workbench.explain_perspective.rule_list">Section 3.5.6</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Statistics</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">See <a href="#_section.ugr.tools.ruta.workbench.explain_perspective.statistics">Section 3.5.8</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Ruta Query</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">See <a href="#_section.ugr.tools.ruta.workbench.ruta_query">Section 3.7</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">TextRuler</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">See <a href="#_section.tools.ruta.workbench.textruler">Section 3.9</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">TextRuler Results</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">See <a href="#_section.tools.ruta.workbench.textruler">Section 3.9</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">True Positive</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">See <a href="#_section.ugr.tools.ruta.workbench.testing.usage">Section 3.8.1</a></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The following <a href="#_table.ugr.tools.ruta.workbench.overview.wizards">Table 7</a> lists all UIMA Ruta wizards:</p>
</div>
<table id="_table.ugr.tools.ruta.workbench.overview.wizards" class="tableblock frame-all grid-all stretch">
<caption class="title">Table 7. UIMA Ruta wizards</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Wizard</th>
<th class="tableblock halign-left valign-top">Detailed description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Create UIMA Ruta project</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">See <a href="#_section.ugr.tools.ruta.workbench.projects.create_projects">Section 3.3.1</a></p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="_section.ugr.tools.ruta.workbench.projects"><a class="anchor" href="#_section.ugr.tools.ruta.workbench.projects"></a>3.3. UIMA Ruta Projects</h3>
<div class="paragraph">
<p>UIMA Ruta projects used within the UIMA Ruta Workbench need to have a certain folder structure.
The parts of this folder structure are explained in <a href="#_table.ugr.tools.ruta.workbench.create_project.folder_strucutre">Table 8</a>.
To create a UIMA Ruta project it is recommended to use the provided wizard, explained in <a href="#_section.ugr.tools.ruta.workbench.projects.create_projects">Section 3.3.1</a>.
If this wizard is used, the required folder structure is automatically created.</p>
</div>
<table id="_table.ugr.tools.ruta.workbench.create_project.folder_strucutre" class="tableblock frame-all grid-all stretch">
<caption class="title">Table 8. Project folder structure</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Folder</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>script</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Source folder for UIMA Ruta scripts and packages.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>descriptor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Build folder for UIMA components. Analysis engines and type systems are created automatically from the related script files.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>input</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Folder that contains the files that will be processed when launching a UIMA Ruta script. Such input files could be plain text, HTML or xmiCAS files.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>output</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Folder that contains the resulting xmiCAS files. One xmiCAS file is generated for each associated document in the input folder.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>resources</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Default folder for word lists, dictionaries and tables.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>test</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Folder for test-driven development.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><a href="#_figure.ugr.tools.ruta.workbench.projects.test_project">Figure 2</a> shows a project, newly created with the wizard.</p>
</div>
<div id="_figure.ugr.tools.ruta.workbench.projects.test_project" class="imageblock">
<div class="content">
<img src="./ruta/images/tools/ruta/workbench/projects/test_project.PNG" alt="A newly created UIMA Ruta project.">
</div>
<div class="title">Figure 2. A newly created UIMA Ruta project</div>
</div>
<div class="sect3">
<h4 id="_section.ugr.tools.ruta.workbench.projects.create_projects"><a class="anchor" href="#_section.ugr.tools.ruta.workbench.projects.create_projects"></a>3.3.1. UIMA Ruta create project wizard</h4>
<div class="paragraph">
<p>To create a new UIMA Ruta project, switch to UIMA Ruta perspective and click &#8220;File &#8594; New &#8594; UIMA Ruta Project&#8221;.
This opens the corresponding wizard.</p>
</div>
<div class="paragraph">
<p><a href="#_figure.ugr.tools.ruta.workbench.projects.create_projects.wizard1">Figure 3</a> shows the start page of the wizard.</p>
</div>
<div id="_figure.ugr.tools.ruta.workbench.projects.create_projects.wizard1" class="imageblock">
<div class="content">
<img src="./ruta/images/tools/ruta/workbench/projects/wizard1.PNG" alt="Wizard start page.">
</div>
<div class="title">Figure 3. Wizard start page</div>
</div>
<div class="paragraph">
<p>To create a simple UIMA Ruta project, enter a project name for your project and click &#8220;Finish&#8221;.
This will create everything you need to start.</p>
</div>
<div class="paragraph">
<p>Other possible settings on this page are the desired location of the project, the interpreter to use and the working set you wish to work on, all of them are self-explaining.</p>
</div>
<div class="paragraph">
<p><a href="#_figure.ugr.tools.ruta.workbench.projects.create_projects.wizard2">Figure 4</a> shows the second page of the wizard.</p>
</div>
<div id="_figure.ugr.tools.ruta.workbench.projects.create_projects.wizard2" class="imageblock">
<div class="content">
<img src="./ruta/images/tools/ruta/workbench/projects/wizard2.PNG" alt="Wizard second page.">
</div>
<div class="title">Figure 4. Wizard second page</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_section.ugr.tools.ruta.workbench.ruta_perspective"><a class="anchor" href="#_section.ugr.tools.ruta.workbench.ruta_perspective"></a>3.4. UIMA Ruta Perspective</h3>
<div class="paragraph">
<p>The UIMA Ruta perspective is the main view to manage UIMA Ruta projects.
There are several views associated with the UIMA Ruta perspective: Annotation Test, Annotation Browser, Selection, TextRuler and Ruta Query.
Since Annotation Test, TextRuler and Ruta Query have a stand-alone functionality.
They are explained in separate sections.</p>
</div>
<div class="paragraph">
<p>To make it possible to reproduce all of the examples used below, switch to the UIMA Ruta Explain perspective within your Eclipse workbench.
Import the UIMA Ruta example project and open the main UIMA Ruta script file 'Main.ruta'. Now press the 'Run' button (green arrow) and wait for the end of execution.
Open the resulting xmiCAS file 'Test1.txt.xmi', which you can find in the output folder.</p>
</div>
<div class="sect3">
<h4 id="_section.ugr.tools.ruta.workbench.ruta_perspective.annotation_browser"><a class="anchor" href="#_section.ugr.tools.ruta.workbench.ruta_perspective.annotation_browser"></a>3.4.1. Annotation Browser</h4>
<div class="paragraph">
<p>The Annotation Browser can be used to view the annotations created by the execution of a UIMA Ruta project.
If an xmiCAS file is opened and active in the editor, the related annotations are shown in this view.</p>
</div>
<div class="paragraph">
<p>The result of the execution of the UIMA Ruta example project is shown in <a href="#_figure.ugr.tools.ruta.workbench.ruta_perspective.annotation_browser">Figure 5</a>.
You can see that there are 5 annotations of 5 different types in the document.
Highlighting of certain types can be controlled by the checkboxes in the tree view.
The names of the types are abbreviated by their package constituents.
Full type names are provided by tooltips and can be copied into the clipboard by hitting 'ctrl + c'.  This can be especially useful to paste a type name into the Query View.</p>
</div>
<div id="_figure.ugr.tools.ruta.workbench.ruta_perspective.annotation_browser" class="imageblock">
<div class="content">
<img src="./ruta/images/tools/ruta/workbench/ruta/AnnotationBrowser_2.2.0.png" alt="Annotation Browser view.">
</div>
<div class="title">Figure 5. Annotation Browser view</div>
</div>
<div class="paragraph">
<p>Moreover, this view has two possible filters.
Using the &#8220;Only types with&#8230;&#8203;&#8221;-filter leads to a list containing only those types that contain the entered text.
The &#8220;Only annotations with&#8230;&#8203;&#8221;-filter leads to an analogous list.
Both list filters can be quickly activated by hitting the return key.</p>
</div>
<div class="paragraph">
<p>Type highlighting can be reset by the action represented by a switched-off light bulb at the top of the view.
The light bulb that is turned on sets all types visible in the tree view of the page highlighted in the CAS editor.</p>
</div>
<div class="paragraph">
<p>The offsets of selected annotations can be modified with ctrl + u (reduce begin), ctrl + i (increase begin), ctrl + o (reduce end), and ctrl + p (increase end).</p>
</div>
<div class="paragraph">
<p>The user can choose whether parent types are displayed using the preference page &#8220;UIMA Cas Editor &#8594; Cas Editor Views&#8221;.</p>
</div>
</div>
<div class="sect3">
<h4 id="_section.ugr.tools.ruta.workbench.ruta_perspective.selection"><a class="anchor" href="#_section.ugr.tools.ruta.workbench.ruta_perspective.selection"></a>3.4.2. Selection</h4>
<div class="paragraph">
<p>The Selection view is very similar to the Annotation Browser view, but only shows annotations that affect a specific text passage.
To get such a list, click on any position in the opened xmiCAS document or select a certain text passage.</p>
</div>
<div class="paragraph">
<p>If you select the text passage <code>2008</code>, the Selection view will be generated as shown in <a href="#_figure.ugr.tools.ruta.workbench.ruta_perspective.selection">Figure 6</a>.</p>
</div>
<div id="_figure.ugr.tools.ruta.workbench.ruta_perspective.selection" class="imageblock">
<div class="content">
<img src="./ruta/images/tools/ruta/workbench/ruta/selection.png" alt="Selection view.">
</div>
<div class="title">Figure 6. Selection view</div>
</div>
<div class="paragraph">
<p>The Selection view has the same filtering and modification options as described in Annotation Browser view.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_section.ugr.tools.ruta.workbench.explain_perspective"><a class="anchor" href="#_section.ugr.tools.ruta.workbench.explain_perspective"></a>3.5. UIMA Ruta Explain Perspective</h3>
<div class="paragraph">
<p>Writing new rules is laborious, especially if the newly written rules do not behave as expected.
The UIMA Ruta system is able to record the application of each single rule and block in order to provide an explanation of the rule inference and a minimal debugging functionality.
The information about the application of the rules itself is stored in the resulting xmiCAS output file, if the parameters of the executed engine are configured correctly.
The simplest way to generate these explanation information is to click on the common 'Debug' button (looks like a green bug) while having the UIMA Ruta script file you want to debug active in your editor.
The current UIMA Ruta file will then be executed on the text files in the input directory and xmiCAS are created in the output directory containing the additional UIMA feature structures describing the rule inference.
To show the newly created execution information, you can either open the Explain perspective or open the necessary views separately and arrange them as you like.
There are eight views that display information about the execution of the rules: Applied Rules, Covering Rules, Created By, Failed Rules, Matched Rules, Rule Elements, Rule List and Statistics.
All of theses views are further explained in detail, using the UIMA Ruta example project for examples.</p>
</div>
<div class="paragraph">
<p>To make it possible to reproduce all of the examples used below, switch to the UIMA Ruta Explain perspective within your Eclipse workbench.
Import the UIMA Ruta example project and open the main Ruta script file 'Main.ruta'. Now press the 'Debug' button and wait for the end of execution.
Open the resulting xmiCAS file 'Test1.txt.xmi', which you can find in the output folder.</p>
</div>
<div class="sect3">
<h4 id="_section.ugr.tools.ruta.workbench.explain_perspective.applied_rules"><a class="anchor" href="#_section.ugr.tools.ruta.workbench.explain_perspective.applied_rules"></a>3.5.1. Applied Rules</h4>
<div class="paragraph">
<p>The Applied Rules view displays structured information about all rules that tried to apply to the input documents.</p>
</div>
<div class="paragraph">
<p>The structure is as follows: if BLOCK constructs were used in the executed Ruta file, the rules contained in that block will be represented as child node in the tree of the view.
Each Ruta file is a BLOCK construct itself and named after the file.
The root node of the view is, therefore, always a BLOCK containing the rules of the executed UIMA Ruta script.
Additionally, if a rule calls a different Ruta file, then the root block of that file is the child of the calling rule.</p>
</div>
<div class="paragraph">
<p>If you double-click on one of the rules, the related script file is opened within the editor and the rule itself is selected.</p>
</div>
<div class="paragraph">
<p><a href="#_section.ugr.tools.ruta.workbench.explain_perspective">Section 3.5</a> shows the whole rule hierarchy resulting from the UIMA Ruta example project.
The root of the whole hierarchy is the BLOCK associated to the 'Main.ruta' script.
On the next level, the rules called by the 'Main.ruta' script are listed.
Since there is a call to each of the script files 'Year.ruta', 'Author.ruta' and 'Title.ruta', these are included into the hierarchy, each forming their own block.</p>
</div>
<div class="paragraph">
<p>The following image shows the UIMA Ruta Applied Rules view.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Applied Rules view
image::images/tools/ruta/workbench/explain/applied_rules_view.png[Applied Rules view.]</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Besides the hierarchy, the view shows how often a rule tried to match in total and how often it succeeded.
This is shown in brackets at the beginning of each rule entry.
The Applied Rules view tells us that the rule <code>NUM{REGEXP("19..|20..") &#8594; MARK(Year)};</code> within script 'Year.ruta' tried to match twice but only succeeded once.</p>
</div>
<div class="paragraph">
<p>After this information, the rule itself is given.
Notice that each rule is given with all the parameters it has been executed.
Have a look at rule entry `[1/1]Document{&#8594;MARKFAST(FirstName,FirstNameList,false,0,true)} ` within BLOCK Author.
The rule obviously has been executed with five parameters.
If you double-click on this rule, you will get to the rule in the script file 'Author.ruta'. It shows the rule as follows: <code>Document{&#8594; MARKFAST(FirstName, FirstNameList)};</code>.
This means the last three parameters have been default values used to execute the rule.</p>
</div>
<div class="paragraph">
<p>Additionally, some profiling information, giving details about the absolute time and the percentage of total execution time the rule needed, is added at the end of each rule entry.</p>
</div>
<div class="paragraph">
<p>The selection (single-click) of a rule in this view will directly change the information visualized in the views Failed Rules and Matched Rules.</p>
</div>
</div>
<div class="sect3">
<h4 id="_section.ugr.tools.ruta.workbench.explain_perspective.matched_and_failed_rules"><a class="anchor" href="#_section.ugr.tools.ruta.workbench.explain_perspective.matched_and_failed_rules"></a>3.5.2. Matched Rules and Failed Rules</h4>
<div class="paragraph">
<p>If a rule is selected (single-click) in the Applied Rules view, then the Matched Rules view displays all instances (text passages) on which the rule matched.
On the contrary, the Failed Rules view shows the instances on which the rule tried but failed to match.</p>
</div>
<div class="paragraph">
<p>Select rule <code>[2/3]Name{-PARTOF(NameListPart)} NameLinker[1,2]{&#8594; MARK(NameListPart,1,2)};</code> within BLOCK Author. <a href="#_figure.ugr.tools.ruta.workbench.explain_perspective.matched_and_failed_rules">[_figure.ugr.tools.ruta.workbench.explain_perspective.matched_and_failed_rules]</a> shows the text passages this rule tried to match on.
One did not succeed.
It is displayed within the Failed Rules view.
Two succeeded and are shown in the Matched Rules view.</p>
</div>
<div class="paragraph">
<p>The following image shows the UIMA Ruta Applied Rules view.</p>
</div>
<div id="_figure.ugr.tools.ruta.workbench.explain_perspective.matched_and_failed_rules" class="olist arabic">
<ol class="arabic">
<li>
<p>The views Matched Rules and Failed Rules
image::images/tools/ruta/workbench/explain/matched_and_failed.png[The views Matched Rules and Failed Rules.]</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The selection (single-click) of one of the text passages in either Matched Rules view or Failed Rules view will directly change the information visualized in the Rule Elements view.</p>
</div>
</div>
<div class="sect3">
<h4 id="_section.ugr.tools.ruta.workbench.explain_perspective.rule_elements"><a class="anchor" href="#_section.ugr.tools.ruta.workbench.explain_perspective.rule_elements"></a>3.5.3. Rule Elements</h4>
<div class="paragraph">
<p>If you select one of the listed instances in the Matched or Failed Rules view, then the Rule Elements view contains a listing of the rule elements and their conditions belonging to the related rule used on the specific text passage.
There is detailed information available on what text passage each rule element did or did not match and which condition did or did not evaluate true.</p>
</div>
<div class="paragraph">
<p>Within the Rule Elements view, each rule element generates its own explanation hierarchy.
On the root level, the rule element itself is given.
An apostrophe at the beginning of the rule element indicates that this rule was the anchor for the rule execution.
On the next level, the text passage on which the rule element tried to match on is given.
The last level explains, why the rule element did or did not match.
The first entry on this level tells, if the text passage is of the requested annotation type.
If it is, a green hook is shown in front of the requested type.
Otherwise, a red cross is shown.
In the following the rule conditions and their evaluation on the given text passage are shown.</p>
</div>
<div class="paragraph">
<p>In the previous example, select the listed instance <code>Bethard, S.</code>.
The Rule Elements view shows the related explanation displayed in <a href="#_figure.ugr.tools.ruta.workbench.explain_perspective.rule_elements">Figure 7</a>.</p>
</div>
<div class="paragraph">
<p>The following image shows the UIMA Ruta Rule Elements view.</p>
</div>
<div id="_figure.ugr.tools.ruta.workbench.explain_perspective.rule_elements" class="imageblock">
<div class="content">
<img src="./ruta/images/tools/ruta/workbench/explain/rule_elements.png" alt="The Rule Elements view.">
</div>
<div class="title">Figure 7. The views Matched Rules and Failed Rules</div>
</div>
<div class="paragraph">
<p>As you can see, the first rule element <code>Name{-PARTOF(NameListPart)}</code> matched on the text passage <code>Bethard, S.</code> since it is firstly annotated with a &#8220;Name&#8221; annotation and secondly it is not part of an annotation &#8220;NameListPart&#8221;.
However, as this first text passage is not followed by a &#8220;NameLinker&#8221; annotation the whole rule fails.</p>
</div>
</div>
<div class="sect3">
<h4 id="_section.ugr.tools.ruta.workbench.explain_perspective.inlined_rules"><a class="anchor" href="#_section.ugr.tools.ruta.workbench.explain_perspective.inlined_rules"></a>3.5.4. Inlined Rules</h4>
<div class="paragraph">
<p>The Inlined Rules view provides additional information about the blocks of rules  that are inlined as condition or as actions.
The view is automatically updated  if a element in a different view is selected, which contains inlined rules.
This includes the Rule Elements view, the Matched View and the Failed View.
If a rule apply in the Applied Rules View contains only a single rule match  and this match, then the Inlined Rules View is also updated.
If a rule apply in the Inlined Rules View is selected, then  the Matched Rules View and the Failed Rules View is updated with the matched  of this inlined rule.</p>
</div>
<div class="paragraph">
<p>This view is not by default included in the perspective, but needs to be added manually, e.g., by using the Quick Access near the perspectives.</p>
</div>
</div>
<div class="sect3">
<h4 id="_section.ugr.tools.ruta.workbench.explain_perspective.covering_rules"><a class="anchor" href="#_section.ugr.tools.ruta.workbench.explain_perspective.covering_rules"></a>3.5.5. Covering Rules</h4>
<div class="paragraph">
<p>This views is very similar to the Applied Rules view, but displays only rules and blocks under a given selection.
If the user clicks on any position in the xmiCAS document, a Covering Rules view is generated containing only rule elements that affect that position in the document.
The Matched Rules, Failed Rules and Rule Elements views only contain match information of that position.</p>
</div>
</div>
<div class="sect3">
<h4 id="_section.ugr.tools.ruta.workbench.explain_perspective.rule_list"><a class="anchor" href="#_section.ugr.tools.ruta.workbench.explain_perspective.rule_list"></a>3.5.6. Rule List</h4>
<div class="paragraph">
<p>This views is very similar to the Applied Rules view and the Covering Rules view, but displays only rules and NO blocks under a given selection.
If the user clicks on any position in the xmiCAS document, a list of rules that matched or tried to match on that position in the document is generated within the Rule List view.
The Matched Rules, Failed Rules and Rule Elements views only contain match information of that position.
Additionally, this view provides a text field for filtering the rules.
Only those rules remain that contain the entered text.</p>
</div>
</div>
<div class="sect3">
<h4 id="_section.ugr.tools.ruta.workbench.explain_perspective.created_by"><a class="anchor" href="#_section.ugr.tools.ruta.workbench.explain_perspective.created_by"></a>3.5.7. Created By</h4>
<div class="paragraph">
<p>The Created By view tells you which rule created a specific annotation.
To get this information, select an annotation in the Annotation Browser.
After doing this, the Created By view shows the related information.</p>
</div>
<div class="paragraph">
<p>To see how this works, use the example project and go to the Annotation view.
Select the &#8220;d.u.e.Year&#8221; annotation &#8220;(2008)&#8221;.
The Created By view displays the information, shown in <a href="#_figure.ugr.tools.ruta.workbench.explain_perspective.created_by">Figure 8</a>.
You can double-click on the shown rule to jump to the related document &#8220;Year.ruta&#8221;.</p>
</div>
<div class="paragraph">
<p>The following image shows the UIMA Ruta Created By view.</p>
</div>
<div id="_figure.ugr.tools.ruta.workbench.explain_perspective.created_by" class="imageblock">
<div class="content">
<img src="./ruta/images/tools/ruta/workbench/explain/created_by.png" alt="The Created By view.">
</div>
<div class="title">Figure 8. The Created By view</div>
</div>
</div>
<div class="sect3">
<h4 id="_section.ugr.tools.ruta.workbench.explain_perspective.statistics"><a class="anchor" href="#_section.ugr.tools.ruta.workbench.explain_perspective.statistics"></a>3.5.8. Statistics</h4>
<div class="paragraph">
<p>The Statistics view displays profiling information for the used conditions and actions of the UIMA Ruta language.
Three numbers are given for each element: The total time of execution, the amount of executions and the average time per execution.</p>
</div>
<div class="paragraph">
<p>The following image shows the UIMA Ruta Statistics view generated form the UIMA Ruta example project.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The Statistics view
image::images/tools/ruta/workbench/explain/statistics.png[The Statistics view.]</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_section.tools.ruta.workbench.cde"><a class="anchor" href="#_section.tools.ruta.workbench.cde"></a>3.6. UIMA Ruta CDE perspective</h3>
<div class="paragraph">
<p>The UIMA Ruta CDE (Constraint-Driven Evaluation) provides some views and functionality to investigate and evaluate a set of annotated documents using domain and background knowledge formalized as constraints and UIMA Ruta rules. <a href="#_figure.tools.ruta.workbench.cde">Figure 9</a> provides an overview of the perspective.
Its views are described in the following.</p>
</div>
<div id="_figure.tools.ruta.workbench.cde" class="imageblock">
<div class="content">
<img src="./ruta/images/tools/ruta/workbench/cde/cde.png" alt="UIMA Ruta CDE perspective">
</div>
<div class="title">Figure 9. The UIMA Ruta cde framework</div>
</div>
<div class="sect3">
<h4 id="_section.tools.ruta.workbench.cde.documents"><a class="anchor" href="#_section.tools.ruta.workbench.cde.documents"></a>3.6.1. CDE Documents view</h4>
<div class="paragraph">
<p>This view provides the general functionality to specify, which set of documents should be evaluated.
The green start button in the toolbar  starts the evaluation process with the given configuration specified in the different views.
The text field &#8220;Documents&#8221; specifies the set of documents that have been annotated by an arbitrary model or set of rules.
These xmiCAS documents can contain additional annotations, which are used by the simple rule-based constraints.
The text field &#8220;Test Data&#8221; specifies an optional folder with gold standard documents.
These documents can be applied for comparing the resulting CDE value to an F1 score.
The text field &#8220;Type System&#8221; refers to a type system descriptor, which defines all types that are needed for the evaluation.
Each text field is sensitive to drag and drop.
The use can select a folder in the script explorer and drag and drop it on the text field.
Directly below the text fields, the values of different evaluation measures are given comparing the resulting CDE value to the F1 score.
These values are of course only available, if annotated gold standard data is specified in the text field &#8220;Test Data&#8221;.</p>
</div>
<div class="paragraph">
<p>The table at the bottom of the view contains all documents that are inspected.
The intervals specifying the color of the icon of each documents dependent of the CDE result can be set in the preference page.
If the evaluation has finished, then the CDE value is displayed and additionally the F1 score, if available.
The table is sortable.
A double-click on a documents opens it in the CAS Editor.</p>
</div>
</div>
<div class="sect3">
<h4 id="_section.tools.ruta.workbench.cde.constraints"><a class="anchor" href="#_section.tools.ruta.workbench.cde.constraints"></a>3.6.2. CDE Constraints view</h4>
<div class="paragraph">
<p>This view specifies the currently applied constraints and their weights.
This list is used to calculate the overall CDE value of one document: the average of the weighted sum.
The buttons in the toolbar of the view export and import the constraint using a simple xml format.
The buttons in the right part of the view can modify the list of the constraints.
Currently, three types of constraints are supported:  Simple UIMA Ruta rules, a list of simple UIMA Ruta rules and word distribution constraints.
All constraints return a value between 0 and 1.
The constraints based on UIMA Ruta rules return the ratio how often the rule was applied to how often the rules tried to apply.
The rule &#8220;Author{STARTSWITH(Reference)};&#8221;, for example, returns 1, if all author annotations start with a reference annotation.
The word distribution  constraints refer to a txt file in which each line has the format &#8220;"Proceedings":Booktitle 0.95, Journal 0.05&#8221; specifying the distribution of the word proceedings concerning the interesting annotations.
If no quotes are given for the first term, then the term is interpreted as an annotation type.
The result value is currently calculated by using the cosine similarity of the expected and observed frequencies.</p>
</div>
</div>
<div class="sect3">
<h4 id="_section.tools.ruta.workbench.cde.result"><a class="anchor" href="#_section.tools.ruta.workbench.cde.result"></a>3.6.3. CDE Result view</h4>
<div class="paragraph">
<p>The result view displays the result values of each constraint for the document that is selected in the CDE Documents view.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_section.ugr.tools.ruta.workbench.ruta_query"><a class="anchor" href="#_section.ugr.tools.ruta.workbench.ruta_query"></a>3.7. Ruta Query View</h3>
<div class="paragraph">
<p>With the Query View, the UIMA Ruta language can be used to write queries on a set of documents.
A query is simply a set of UIMA Ruta rules.
Each query returns a list of all text passages the query applies to.
For example, if you have a set of annotated documents containing a number of Author annotations, you could use the Query View to get a list of all the author names associated with these annotations.
The set of relevant files can be restricted by a regular expression over the file names, e.g., "files_0[0-9]\\.xmi".</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./ruta/images/tools/ruta/workbench/query/Query2.2.0.png" alt="Query View">
</div>
<div class="title">Figure 10. The Query View. *(1)*Start Button; *(2)*Export Button</div>
</div>
<div class="paragraph">
<p>Use the Query view as follows:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The field &#8220;Query Data&#8221; specifies the folder containing the documents on which the query should be executed. You can either click on the button next to the field to specify the folder by browsing through the file system or you can drag and drop a folder directly into the field. If the checkbox is activated, all subfolders are included.</p>
</li>
<li>
<p>The field &#8220;Type System&#8221; has to contain a type system or a UIMA Ruta script that specifies all types that are used in the query. You can either click on the button next to the field to specify the type system by browsing through the file system or you can drag and drop a type system directly into the field.</p>
</li>
<li>
<p>The query in form of one or more UIMA Ruta rules is specified in the text field in the middle of the view.</p>
</li>
<li>
<p>After pressing the start button, the query is started. The results are subsequently displayed in the bottom text field.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The resulting list consists of all text passages the query applied to.
Above the text field, information about the entire number of matches and the number of different documents the query applied to is given.
Each item in the list shows both the matched text passage and in brackets the document related to the text passage.
By double-clicking on one of the listed items, the related document is opened in the editor and the matched text passage is selected.
If the related document is already open you can jump to another matched text passage within the the same document with one click on the listed item.
Of course, this text passage is selected.
By clicking on the export button, a list of all matched text passaged is showed in a separate window.
For further usage, e.g.
as a list of authors in another UIMA Ruta project, copy the content of this window to another text file.</p>
</div>
<div class="paragraph">
<p>The screenshot shows an example where a rule is used to find occurrences of years within brackets in the input file of the UIMA Ruta example.
After pressing the run button the result list contains all occurrences.
Recognize that the rule does not create any annotation.
The list lists all rule matches, not the created annotations.</p>
</div>
</div>
<div class="sect2">
<h3 id="_section.ugr.tools.ruta.workbench.testing"><a class="anchor" href="#_section.ugr.tools.ruta.workbench.testing"></a>3.8. Testing</h3>
<div class="paragraph">
<p>The UIMA Ruta Workbench comes bundled with its own testing environment that allows you to test and evaluate UIMA Ruta scripts.
It provides full back-end testing capabilities and allows you to examine test results in detail.</p>
</div>
<div class="paragraph">
<p>To test the quality of a written UIMA Ruta script, the testing procedure compares a previously annotated gold standard file with the resulting xmiCAS file created by the selected UIMA Ruta script.
As a product of the testing operation a new xmiCAS file will be created, containing detailed information about the test results.
The evaluators compare the offsets of annotations and, depending on the selected evaluator, add true positive, false positive or false negative annotations for each tested annotation to the resulting xmiCAS file.
Afterwards precision, recall and f1-score are calculated for each test file and each type in the test file.
The f1-score is also calculated for the whole test set.
The testing environment consists of four views: Annotation Test, True Positive, False Positive and False Negative.
The Annotation Test view is by default associated with the UIMA Ruta perspective.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>There are two options for choosing the types that should be evaluated, which is specified by the preference &#8220;Use all types&#8221;.
If this preference is activated (by default), then the user has to selected the types using the toolbar in the view.
There are button for selecting the included and excluded types.
If this preference is deactivated,  then only the types present in the current test document are evaluated.
This can result in missing false positive, if  the an annotation of a specific type was created by the rules and no annotation of this type is present in the test document.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><a href="#_figure.ugr.tools.ruta.workbench.testing.script_explorer">Figure 11</a> shows the script explorer.
Every UIMA Ruta project contains a folder called &#8220;test&#8221;.
This folder is the default location for the test-files.
In the folder each script file has its own subfolder with a relative path equal to the scripts package path in the &#8220;script&#8221; folder.
This folder contains the test files.
In every scripts test folder, you will also find a result folder where the results of the tests are saved.
If you like to use test files from another location in the file system, the results will be saved in the &#8220;temp&#8221; subfolder of the project&#8217;s test folder.
All files in the temp folder will be deleted once Eclipse is closed.</p>
</div>
<div id="_figure.ugr.tools.ruta.workbench.testing.script_explorer" class="imageblock">
<div class="content">
<img src="./ruta/images/tools/ruta/workbench/testing/script_explorer.png" alt="The test folder structure.">
</div>
<div class="title">Figure 11. Test folder structure.</div>
</div>
<div class="sect3">
<h4 id="_section.ugr.tools.ruta.workbench.testing.usage"><a class="anchor" href="#_section.ugr.tools.ruta.workbench.testing.usage"></a>3.8.1. Usage</h4>
<div class="paragraph">
<p>This section describes the general proceeding when using the testing environment.</p>
</div>
<div class="paragraph">
<p>Currently, the testing environment has no own perspective associated to it.
It is recommended to start within the UIMA Ruta perspective.
There, the Annotation Test view is open by default.
The True Positive, False Positive and False Negative views have to be opened manually: "`Window &#8594; Show View &#8594; True Positive/False Positive/False Negative `".</p>
</div>
<div class="paragraph">
<p>To explain the usage of the UIMA Ruta testing environment, the UIMA Ruta example project is used again.
Open this project.
Firstly, one has to select a script for testing: UIMA Ruta will always test the script, that is currently open and active in the script editor.
So, open the &#8220;Main.ruta&#8221; script file of the UIMA Ruta example project.
The next <a href="#_figure.ugr.tools.ruta.workbench.testing.annotation_test_initial_view">figure</a>.
shows the Annotation Test view after doing this.</p>
</div>
<div id="_figure.ugr.tools.ruta.workbench.testing.annotation_test_initial_view" class="imageblock">
<div class="content">
<img src="./ruta/images/tools/ruta/workbench/testing/annotation_test_initial_view_2_2_0.png" alt="The Annotation Test view.">
</div>
<div class="title">Figure 12. The Annotation Test view. Button from left to right:Start Test; Select excluded type; Select included type; Select evaluator/preferences; Export to CSV; Extend Classpath</div>
</div>
<div class="paragraph">
<p>All control elements that are needed for the interaction with the testing environment are located here.
At the top right, there is the buttons bar.
At the top left of the view the name of the script that is going to be tested is shown.
It is always equal to the script active in the editor.
Below this, the test list is located.
This list contains the different files for testing.
Right next to the name of the script file you can select the desired view.
Right to this you get statistics over all ran tests: the number of all true positives (TP), false positives (FP) and false negatives (FN). In the field below, you will find a table with statistic information for a single selected test file.
To change this view, select a file in the test list field.
The table shows a total TP, FP and FN information, as well as precision, recall and f1-score for every type as well as for the whole file.</p>
</div>
<div class="paragraph">
<p>There is also an experimental feature to extend the classpath during testing, which allows to  evaluate scripts that call analysis engines in the same workspace.
Therefore, you have to toggle the button in the toolbar of the view.</p>
</div>
<div class="paragraph">
<p>Next, you have to add test files to your project.
A test file is a previously annotated xmiCAS file that can be used as a golden standard for the test.
You can use any xmiCAS file.
The UIMA Ruta example project already contains such test files.
These files are listed in the Annotation Test view.
Try do delete these files by selecting them and clicking on <code>Del</code>.
Add these files again by simply dragging them from the Script Explorer into the test file list.
A different way to add test-files is to use the &#8220;Load all test files from selected folder&#8221; button (green plus). It can be used to add all xmiCAS files from a selected folder.</p>
</div>
<div class="paragraph">
<p>Sometimes it is necessary to create some annotations manually: To create annotations manually, use the &#8220;Cas Editor&#8221; perspective delivered with the UIMA workbench.</p>
</div>
<div class="paragraph">
<p>The testing environment supports different evaluators that allow a sophisticated analysis of the behavior of a UIMA Ruta script.
The evaluator can be chosen in the testing environment&#8217;s preference page.
The preference page can be opened either through the menu or by clicking on the &#8220;Select evaluator&#8221; button (blue gear wheels) in the testing view&#8217;s toolbar.
Clicking the button will open a filtered version of the UIMA Ruta preference page.
The default evaluator is the "Exact CAS Evaluator", which compares the offsets of the annotations between the test file and the file annotated by the tested script.
To get an overview of all available evaluators, see <a href="#_section.ugr.tools.ruta.workbench.testing.evaluators">Section 3.8.2</a></p>
</div>
<div class="paragraph">
<p>This preference page (see <a href="#_figure.ugr.tools.ruta.workbench.testing.preference">Figure 13</a>)  offers a few options that will modify the plug-ins general behavior.
For example, the preloading of previously collected result data can be turned off.
An important option in the preference page is the evaluator you can select.
On default the "exact evaluator" is selected, which compares the offsets of the annotations, that are contained in the file produced by the selected script with the annotations in the test file.
Other evaluators will compare annotations in a different way.</p>
</div>
<div id="_figure.ugr.tools.ruta.workbench.testing.preference" class="imageblock">
<div class="content">
<img src="./ruta/images/tools/ruta/workbench/testing/preference_2_2_0.png" alt="The testing preference page view.">
</div>
<div class="title">Figure 13. The testing preference page view</div>
</div>
<div class="paragraph">
<p>During a test-run it might be convenient to disable testing for specific types like punctuation or tags.
The &#8220;Select excluded types&#8221; button (white exclamation in a red disk) will open a dialog (see <a href="#_figure.ugr.tools.ruta.workbench.testing.excluded_types">Figure 14</a>)  where all types can be selected that should not be considered in the test.</p>
</div>
<div id="_figure.ugr.tools.ruta.workbench.testing.excluded_types" class="imageblock">
<div class="content">
<img src="./ruta/images/tools/ruta/workbench/testing/excluded_types.png" alt="Excluded types window.">
</div>
<div class="title">Figure 14. Excluded types window</div>
</div>
<div class="paragraph">
<p>A test-run can be started by clicking on the start button.
Do this for the UIMA Ruta example project. <a href="#_figure.ugr.tools.ruta.workbench.testing.annotation_test_test_run">Figure 15</a> shows the results.</p>
</div>
<div id="_figure.ugr.tools.ruta.workbench.testing.annotation_test_test_run" class="imageblock">
<div class="content">
<img src="./ruta/images/tools/ruta/workbench/testing/annotation_test_test_run_2_2_0.png" alt="The Annotation Test view.">
</div>
<div class="title">Figure 15. The Annotation Test view.</div>
</div>
<div class="paragraph">
<p>The testing main view displays some information on how well the script did after every test run.
It will display an overall number of true positive, false positive and false negatives annotations of all result files as well as an overall f1-score.
Furthermore, a table will be displayed that contains the overall statistics of the selected test file as well as statistics for every single type in the test file.
The information displayed are true positives, false positives, false negatives, precision, recall and f1-measure.</p>
</div>
<div class="paragraph">
<p>The testing environment also supports the export of the overall data in form of a comma-separated table.
Clicking the &#8220;export data&#8221; button will open a dialog window that contains this table.
The text in this table can be copied and easily imported into other applications.</p>
</div>
<div class="paragraph">
<p>When running a test, the evaluator will create a new result xmiCAS file and will add new true positive, false positive and false negative annotations.
By clicking on a file in the test-file list, you can open the corresponding result xmiCAS file in the CAS Editor.
While displaying the result xmiCAS file in the CAS Editor, the True Positive, False Positive and False Negative views allow easy navigation through the new tp, fp and fn annotations.
The corresponding annotations are displayed in a hierarchic tree structure.
This allows an easy tracing of the results within the testing document.
Clicking on one of the annotations in those views will highlight the annotation in the CAS Editor.
Opening &#8220;test1.result.xmi&#8221; in the UIMA Ruta example project changes the True Positive view as shown in <a href="#_figure.ugr.tools.ruta.workbench.testing.true_positive">Figure 16</a>.
Notice that the type system, which will be used by the CAS Editor to open the evaluated file,  can only be resolved for the tested script, if the test files are located in the associated folder structure that is the folder with the name of the script.
If the files are located  in the temp folder, for example by adding the files to the list of test cases by drag and drop, other strategies to find the correct type system will be applied.
For UIMA Ruta projects,  for example, this will be the type system of the last launched script in this project.</p>
</div>
<div id="_figure.ugr.tools.ruta.workbench.testing.true_positive" class="imageblock">
<div class="content">
<img src="./ruta/images/tools/ruta/workbench/testing/true_positive.png" alt="The True Positive view.">
</div>
<div class="title">Figure 16. The True Positive view.</div>
</div>
</div>
<div class="sect3">
<h4 id="_section.ugr.tools.ruta.workbench.testing.evaluators"><a class="anchor" href="#_section.ugr.tools.ruta.workbench.testing.evaluators"></a>3.8.2. Evaluators</h4>
<div class="paragraph">
<p>When testing a CAS file, the system compared the offsets of the annotations of a previously annotated gold standard file with the offsets of the annotations of the result file the script produced.
Responsible for comparing annotations in the two CAS files are evaluators.
These evaluators have different methods and strategies implemented for comparing the annotations.
Also, an extension point is provided that allows easy implementation of new evaluators.</p>
</div>
<div class="paragraph">
<p>Exact Match Evaluator: The Exact Match Evaluator compares the offsets of the annotations in the result and the golden standard file.
Any difference will be marked with either a false positive or false negative annotations.</p>
</div>
<div class="paragraph">
<p>Partial Match Evaluator: The Partial Match Evaluator compares the offsets of the annotations in the result and golden standard file.
It will allow differences in the beginning or the end of an annotation.
For example, "corresponding" and "corresponding " will not be annotated as an error.</p>
</div>
<div class="paragraph">
<p>Core Match Evaluator: The Core Match Evaluator accepts annotations that share a core expression.
In this context, a core expression is at least four digits long and starts with a capitalized letter.
For example, the two annotations "L404-123-421" and "L404-321-412" would be considered a true positive match, because "L404" is considered a core expression that is contained in both annotations.</p>
</div>
<div class="paragraph">
<p>Word Accuracy Evaluator: Compares the labels of all words/numbers in an annotation, whereas the label equals the type of the annotation.
This has the consequence, for example, that each word or number that is not part of the annotation is counted as a single false negative.
For example in the sentence: "Christmas is on the 24.12 every year." The script labels "Christmas is on the 12" as a single sentence, while the test file labels the sentence correctly with a single sentence annotation.
While, for example, the Exact CAS Evaluator is only assigning a single False Negative annotation, Word Accuracy Evaluator will mark every word or number as a single false negative.</p>
</div>
<div class="paragraph">
<p>Template Only Evaluator: This Evaluator compares the offsets of the annotations and the features, that have been created by the script.
For example, the text "Alan Mathison Turing" is marked with the author annotation and "author" contains 2 features: "FirstName" and "LastName". If the script now creates an author annotation with only one feature, the annotation will be marked as a false positive.</p>
</div>
<div class="paragraph">
<p>Template on Word Level Evaluator: The Template On Word Evaluator compares the offsets of the annotations.
In addition, it also compares the features and feature structures and the values stored in the features.
For example, the annotation "author" might have features like "FirstName" and "LastName". The authors name is "Alan Mathison Turing" and the script correctly assigns the author annotation.
The feature assigned by the script are "Firstname : Alan", "LastName : Mathison", while the correct feature values are "FirstName Alan" and "LastName Turing". In this case, the Template Only Evaluator will mark an annotation as a false positive, since the feature values differ.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_section.tools.ruta.workbench.textruler"><a class="anchor" href="#_section.tools.ruta.workbench.textruler"></a>3.9. TextRuler</h3>
<div class="paragraph">
<p>Apache UIMA Ruta TextRuler is a framework for supervised rule induction included in the UIMA Ruta Workbench.
It provides several configurable algorithms, which are able to learn new rules based on given labeled data.
The framework was created in order to support the user by suggesting new rules for the given task.
The user selects a suitable learning algorithm and adapts its configuration parameters.
Furthermore,  the user engineers a set of annotation-based features, which enable the algorithms to form efficient, effective and comprehensive rules.
The rule learning algorithms present their suggested rules in a new view, in which the user can either copy  the complete script or single rules to a new script file, where the rules can be further refined.</p>
</div>
<div class="paragraph">
<p>This section gives a short introduction about the included features and learners, and how to use the framework to learn UIMA Ruta rules.
First, the  available rule learning algorithms are introduced in <a href="#_section.tools.ruta.workbench.textruler.learner">Section 3.9.1</a>.
Then,  the user interface and the usage is explained in <a href="#_section.tools.ruta.workbench.textruler.ui">Section 3.9.2</a> and <a href="#_section.tools.ruta.workbench.textruler.example">Section 4.5</a> illustrates the usage with an exemplary UIMA Ruta project.</p>
</div>
<div class="sect3">
<h4 id="_section.tools.ruta.workbench.textruler.learner"><a class="anchor" href="#_section.tools.ruta.workbench.textruler.learner"></a>3.9.1. Included rule learning algorithms</h4>
<div class="paragraph">
<p>This section gives a short description of the rule learning algorithms, which are provided in the UIMA Ruta TextRuler framework.</p>
</div>
<div class="sect4">
<h5 id="_section.tools.ruta.workbench.textruler.lp2"><a class="anchor" href="#_section.tools.ruta.workbench.textruler.lp2"></a>LP2</h5>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>This rule learner is an experimental implementation of the ideas and algorithms published in: F.
Ciravegna.
(LP)2, Rule Induction for Information Extraction Using Linguistic Constraints.
Technical Report CS-03-07, Department of Computer Science, University of Sheffield, Sheffield, 2003.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This algorithms learns separate rules for the beginning and the end of a single slot, which are later combined  in order to identify the targeted annotation.
The learning strategy is a bottom-up covering algorithm.
It starts by creating a specific seed instance with a window of w tokens to the left and right of the target boundary and searches for the best generalization.
Additional context rules are induced in order to identify missing boundaries.
The current implementation does not support correction rules.
The TextRuler framework provides two versions of this algorithm: LP2 (naive) is a straightforward implementation with limited expressiveness concerning the resulting Ruta rules.
LP2 (optimized) is an improved  version with a dynamic programming approach and is providing better results in general.
The following parameters are available.
For a more detailed description of the parameters,  please refer to the implementation and the publication.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Context Window Size (to the left and right)</p>
</li>
<li>
<p>Best Rules List Size</p>
</li>
<li>
<p>Minimum Covered Positives per Rule</p>
</li>
<li>
<p>Maximum Error Threshold</p>
</li>
<li>
<p>Contextual Rules List Size</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_section.tools.ruta.workbench.textruler.whisk"><a class="anchor" href="#_section.tools.ruta.workbench.textruler.whisk"></a>WHISK</h5>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>This rule learner is an experimental implementation of the ideas and algorithms published in: Stephen Soderland, Claire Cardie, and Raymond Mooney.
Learning Information Extraction Rules for Semi-Structured and Free Text.
In Machine Learning, volume 34, pages 233-272, 1999.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>WHISK is a multi-slot method that operates on all three kinds of documents and learns single- or multi-slot rules looking similar to regular expressions.
However, the current implementation only support single slot rules.
The top-down covering algorithm begins with the most general rule and specializes it by adding single rule terms until the rule does not make errors anymore on the training set.
The TextRuler framework provides two versions of this algorithm: WHISK (token) is a naive token-based implementation.
WHISK (generic) is an optimized and improved implementation,  which is able to refer to arbitrary annotations and also supports primitive features.
The following parameters are available.
For a more detailed description of the parameters,  please refer to the implementation and the publication.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Parameters Window Size</p>
</li>
<li>
<p>Maximum Error Threshold</p>
</li>
<li>
<p>PosTag Root Type</p>
</li>
<li>
<p>Considered Features (comma-separated) - only WHISK (generic)</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_section.tools.ruta.workbench.textruler.trabal"><a class="anchor" href="#_section.tools.ruta.workbench.textruler.trabal"></a>TraBaL</h5>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>This rule learner is an implementation of the ideas and algorithms published in: Benjamin Eckstein, Peter Kluegl, and Frank Puppe.
Towards Learning Error-Driven  Transformations for Information Extraction.
Workshop Notes of the LWA 2011 -  Learning, Knowledge, Adaptation, 2011.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The TraBal rule learner induces rules that try to correct annotations error and relies on two set of documents.
A set of  documents with gold standard annotation and an additional set of annotated documents with the same text that possibly contain erroneous annotations, for which correction rules should be learnt.
First, the algorithm compares the two sets of documents and  identifies the present errors.
Then, rules for each error are induced and extended.
This process can be iterated in order  to incrementally remove all errors.
The following parameters are available.
For a more detailed description of the parameters,  please refer to the implementation and the publication.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Number of times, the algorithm iterates.</p>
</li>
<li>
<p>Number of basic rules to be created for one example.</p>
</li>
<li>
<p>Number of optimized rules to be created for one example.</p>
</li>
<li>
<p>Maximum number of iterations, when optimizing rules.</p>
</li>
<li>
<p>Maximum allowed error rate.</p>
</li>
<li>
<p>Correct features in rules and conditions. (not yet available)</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_section.tools.ruta.workbench.textruler.kep"><a class="anchor" href="#_section.tools.ruta.workbench.textruler.kep"></a>KEP</h5>
<div class="paragraph">
<p>The name of the rule learner KEP (knowledge engineering patterns) is derived from the idea that humans use different engineering patterns  to write annotation rules.
This algorithms implements simple rule induction methods for some patterns, such as boundary detection  or annotation-based restriction of the window.
The results are then combined in order to take advantage of the combination of  the different kinds of induced rules.
Since the single rules are constructed according to how humans engineer the annotations rules,  the resulting rule set should resemble more a handcrafted rule set.
Furthermore, by exploiting the synergy of the patterns, solutions for  some annotation are much simpler.
The following parameters are available.
For a more detailed description of the parameters,  please refer to the implementation.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Maximum number of &#8220;Expand Rules&#8221;</p>
</li>
<li>
<p>Maximum number of &#8220;Infiller Rules&#8221;</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_section.tools.ruta.workbench.textruler.ui"><a class="anchor" href="#_section.tools.ruta.workbench.textruler.ui"></a>3.9.2. The TextRuler view</h4>
<div class="paragraph">
<p>The TextRuler view is normally located in the lower center of the UIMA Ruta perspective and is the main user interface to configure and start the rule learning algorithms.
The view consists of four parts (cf. <a href="#_figure.tools.ruta.workbench.textruler.main">Figure 17</a>):  The toolbar contains buttons for starting (green button) and stopping (red button) the learning process,  and one button that opening the preference page (blue gears) for configuring the rule induction algorithms cf. <a href="#_figure.tools.ruta.workbench.textruler.pref">Figure 18</a>.
The upper part of the view contains text fields for defining the set of utilized documents. &#8220;Training Data&#8221; points to the absolute location of the folder containing the gold standard documents. &#8220;Additional Data&#8221; points to the absolute location of documents that can be additionally used by the algorithms.
These documents are currently only needed by the TraBal algorithm, which tries to learn correction rules for the error in those documents. &#8220;Test Data&#8221; is not yet available.
Finally, &#8220;Preprocess Script&#8221; points to the absolute location of a UIMA Ruta script, which contains all necessary types and can be applied on the documents before the algorithms start in order to add additional annotations as learning features.
The preprocessing can be skipped.
All text fields support drag and drop: the user can drag a file in the script explorer and drop it in the respective text field.
In the center of the view, the target types, for which rule should be induced, can be specified in the &#8220;Information Types&#8221; list.
The list &#8220;Featured Feature Types&#8221; specify the filtering settings, but it is discourage to change these settings.
The user is able to drop a simple text file, which contains a type with complete namespace in each line, to the &#8220;Information Types&#8221; list in order to add all those types.
The lower part of the view contains the list of available algorithms.
All checked algorithms will be started, if the start button in the toolbar of the view is pressed.
When the algorithms are started, they display their current action after their name, and a result view with the currently induced rules is displayed  in the right part of the perspective.</p>
</div>
<div id="_figure.tools.ruta.workbench.textruler.main" class="imageblock">
<div class="content">
<img src="./ruta/images/tools/ruta/workbench/textruler/textruler.png" alt="UIMA Ruta TextRuler framework">
</div>
<div class="title">Figure 17. The UIMA Ruta TextRuler framework</div>
</div>
<div id="_figure.tools.ruta.workbench.textruler.pref" class="imageblock">
<div class="content">
<img src="./ruta/images/tools/ruta/workbench/textruler/textruler_pref.png" alt="UIMA Ruta TextRuler Preferences">
</div>
<div class="title">Figure 18. The UIMA Ruta TextRuler Preferences</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_section.tools.ruta.workbench.check"><a class="anchor" href="#_section.tools.ruta.workbench.check"></a>3.10. Check Annotations view</h3>
<div class="paragraph">
<p>The Check Annotations view provides functionality to quickly validate a set of annotations in different documents.
The user can specify two folders with xmiCAS files: One folder contains the documents with annotations that should be validated.
The other folder is used to store the validated annotations.
The view enables a rapid navigation between the documents and their annotations  of the selected types can easily be accepted or rejected. <a href="#_figure.tools.ruta.workbench.check">Figure 19</a> provides an screenshot of the view.
Its parts are described in the following.</p>
</div>
<div id="_figure.tools.ruta.workbench.check" class="imageblock">
<div class="content">
<img src="./ruta/images/tools/ruta/workbench/check/check.png" alt="Check Annotations view">
</div>
<div class="title">Figure 19. Check Annotations view (right part)</div>
</div>
<div class="paragraph">
<p>The view provides three text fields: the absolute location of the folder with the source documents, which contain the annotations to be validated,  the absolute location of the gold folder, where the accepted annotations will be stored, and the absolute location of the type system that contains  all necessary types.
The toolbar of the view provides seven buttons: the first one updates the set of documents and  their annotations in the main part of the view.
This is necessary, e.g., if the selected types change or if the annotations in the documents change.
The second button opens a dialog for choosing the types that need to be checked.
Only annotations of those types will be displayed and can be accepted or rejected.
If features need to be checked together with the annotations of a type, these features have to be selected in this dialog too.
Features are shown as sub-nodes of the annotation nodes.
By default, only annotations that have been checked are transferred from the original document to the according gold document.
To also transfer  annotations of some type unchecked, these types have to be chosen in another dialog, which is opened with the third button.
The fourth and fifth button accept/reject the currently selected annotation.
Only accepted annotations will be stored in the gold folder.
An annotation can also  be accepted with the key binding &#8220;ctrl+4&#8221; and rejected with the key binding &#8220;ctrl+5&#8221;.
If an annotation is processed,  then the next annotation is automatically selected and a new CAS Editor is opened if necessary.
The sixth button adds the currently accepted annotations, as well as the annotations of a type selected in the unchecked dialog, to the corresponding file in the gold folder and additionally extends an file &#8220;data.xml&#8221;, which remembers what types have already been checked in each documents.
Annotations of these types will not show up again in the main part of the view.
With the last button, the user can select the annotation mode of the CAS editor.
The choice is restricted to the currently selected types.
If an annotation is missing in the source documents, then the user can manually add this annotation in the CAS Editor.
The new annotation will be added as accepted to the list of annotations in the main part of the view.
By right-clicking on an annotation node in the view&#8217;s tree viewer, a dialog opens to change the type of an annotation.
Right-clicking on a feature node opens another dialog to change the feature&#8217;s value.</p>
</div>
</div>
<div class="sect2">
<h3 id="_section.ugr.tools.ruta.workbench.create_dictionaries"><a class="anchor" href="#_section.ugr.tools.ruta.workbench.create_dictionaries"></a>3.11. Creation of Tree Word Lists</h3>
<div class="paragraph">
<p>Tree word lists are external resources, which can be used to annotate all occurrences of list items in a document with a given annotation type, very fast.
For more details on their use, see <a href="#_ugr.tools.ruta.language.external_resources">Section 2.18</a>.
Since simple tree and multi tree word lists have to be compiled the UIMA Ruta Workbench provides an easy way to compile them from ordinary text files.
These text files have to containing one item per line, for example, like in the following list of first names:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>Frank
Peter
Jochen
Martin</code></pre>
</div>
</div>
<div class="paragraph">
<p>To compile a simple tree word list from a text file, right-click on the text file in UIMA Ruta script explorer.
The resulting menu is shown in <a href="#_figure.ugr.tools.ruta.workbench.create_dictionaries_1">Figure 20</a>.</p>
</div>
<div id="_figure.ugr.tools.ruta.workbench.create_dictionaries_1" class="imageblock">
<div class="content">
<img src="./ruta/images/tools/ruta/workbench/create_tree_lists/create_tree_lists.png" alt="Create a simple tree word list.">
</div>
<div class="title">Figure 20. Create a simple tree word list</div>
</div>
<div class="paragraph">
<p>When hovering over UIMA Ruta item you can choose &#8220;Convert to TWL&#8221;.
Click on it and a tree word list with the same name as the original file is generated in the same folder.</p>
</div>
<div class="paragraph">
<p>You can also generate several tree word lists at once.
To do so, just select multiple files and then right-click and do the same like for a single list.
You will get one tree word list for every selected file.</p>
</div>
<div class="paragraph">
<p>To generate a multi tree work list, select all files, which should be generated into the multi tree word list.
Again right-click and select &#8220;Convert to Multi TWL&#8221; under item UIMA Ruta.
A multi tree word list named &#8220;generated.mtwl&#8221; will be created.</p>
</div>
<div class="paragraph">
<p>The preferences page provides the option to remove white spaces when generating the word lists.</p>
</div>
</div>
<div class="sect2">
<h3 id="_ugr.tools.ruta.workbench.apply"><a class="anchor" href="#_ugr.tools.ruta.workbench.apply"></a>3.12. Apply a UIMA Ruta script to a folder</h3>
<div class="paragraph">
<p>The UIMA Ruta Workbench makes it possible to apply a UIMA Ruta script to any folder of the workspace.
Select a folder in the script explorer, right-click to open the context menu and select the menu entry UIMA Ruta.
There are three options to apply a UIMA Ruta script to the files of the selected folder, cf. <a href="#_figure.ugr.tools.ruta.workbench.apply">Figure 21</a>.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Quick Ruta</strong> applies the UIMA Ruta script that is currently opened and focused in the UIMA Ruta editor to all suitable files in the selected folder. Files of the type &#8220;xmi&#8221; will be adapted  and a new xmi-file will be created for other files like txt-files.</p>
</li>
<li>
<p><strong>Quick Ruta (remove basics)</strong> is very similar to the previous menu entry, but removes the annotations of the type &#8220;RutaBasic&#8221; after processing a CAS.</p>
</li>
<li>
<p><strong>Quick Ruta (no xmi)</strong> applies the UIMA Ruta script, but does not change nor create an xmi-file. This menu entry can, for example, be used in combination with an imported XMIWriter Analysis Engine, which  stores the result of the script in a different folder depending on the execution of the rules.</p>
</li>
</ol>
</div>
<div id="_figure.ugr.tools.ruta.workbench.apply" class="imageblock">
<div class="content">
<img src="./ruta/images/tools/ruta/workbench/apply/apply.png" alt="Apply a UIMA Ruta script directly on a folder.">
</div>
<div class="title">Figure 21. Remove Ruta basics</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_ugr.tools.ruta.howtos"><a class="anchor" href="#_ugr.tools.ruta.howtos"></a>4. Apache UIMA Ruta HowTos</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This chapter contains a selection of some use cases and HowTos for UIMA Ruta.</p>
</div>
<div class="sect2">
<h3 id="_ugr.tools.ruta.ae.basic.apply"><a class="anchor" href="#_ugr.tools.ruta.ae.basic.apply"></a>4.1. Apply UIMA Ruta Analysis Engine in plain Java</h3>
<div class="paragraph">
<p>Let us assume that the reader wrote the UIMA Ruta rules using the UIMA Ruta Workbench, which already creates correctly configured descriptors.
In this case, the following java code can be used to apply the UIMA Ruta script.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>File specFile = new File("pathToMyWorkspace/MyProject/descriptor/"+
    "my/package/MyScriptEngine.xml");
XMLInputSource in = new XMLInputSource(specFile);
ResourceSpecifier specifier = UIMAFramework.getXMLParser().
    parseResourceSpecifier(in);
// for import by name... set the datapath in the ResourceManager
AnalysisEngine ae = UIMAFramework.produceAnalysisEngine(specifier);
CAS cas = ae.newCAS();
cas.setDocumentText("This is my document.");
ae.process(cas);</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>The UIMA Ruta Analysis Engine utilizes type priorities.
If the CAS object is not created using the UIMA Ruta Analysis Engine descriptor by other means, then please provide the necessary type priorities for a valid execution of the UIMA Ruta rules.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If the UIMA Ruta script was written, for example, with a common text editor and no configured descriptors are yet available, then the following java code can be used, which, however, is only applicable for executing single script files that do not import additional components or scripts.
In this case the other parameters, e.g., &#8220;additionalScripts&#8221;, need to be configured correctly.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>URL aedesc = RutaEngine.class.getResource("BasicEngine.xml");
XMLInputSource inae = new XMLInputSource(aedesc);
ResourceSpecifier specifier = UIMAFramework.getXMLParser().
    parseResourceSpecifier(inae);
ResourceManager resMgr = UIMAFramework.newDefaultResourceManager();
AnalysisEngineDescription aed = (AnalysisEngineDescription) specifier;
TypeSystemDescription basicTypeSystem = aed.getAnalysisEngineMetaData().
    getTypeSystem();

Collection&lt;TypeSystemDescription&gt; tsds =
    new ArrayList&lt;TypeSystemDescription&gt;();
tsds.add(basicTypeSystem);
// add some other type system descriptors
// that are needed by your script file
TypeSystemDescription mergeTypeSystems = CasCreationUtils.
    mergeTypeSystems(tsds);
aed.getAnalysisEngineMetaData().setTypeSystem(mergeTypeSystems);
aed.resolveImports(resMgr);

AnalysisEngine ae = UIMAFramework.produceAnalysisEngine(aed,
    resMgr, null);
File scriptFile = new File("path/to/file/MyScript.ruta");
ae.setConfigParameterValue(RutaEngine.PARAM_SCRIPT_PATHS,
    new String[] { scriptFile.getParentFile().getAbsolutePath() });
String name = scriptFile.getName().substring(0,
    scriptFile.getName().length() - 5);
ae.setConfigParameterValue(RutaEngine.PARAM_MAIN_SCRIPT, name);
ae.reconfigure();
CAS cas = ae.newCAS();
cas.setDocumentText("This is my document.");
ae.process(cas);</code></pre>
</div>
</div>
<div class="paragraph">
<p>There is also a convenience implementation for applying simple scripts, which do not introduce new types.
The following java code applies a simple rule &#8220;T1 SW{&#8594; MARK(T2)};&#8221;			on the given CAS.
Note that the types need to be already defined in the type system of the CAS.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>Ruta.apply(cas, "T1 SW{-&gt; MARK(T2)};");</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_ugr.tools.ruta.integration"><a class="anchor" href="#_ugr.tools.ruta.integration"></a>4.2. Integrating UIMA Ruta in an existing UIMA Annotator</h3>
<div class="paragraph">
<p>This section provides a walk-through tutorial on integrating Ruta in an existing UIMA annotator.
In our artificial example we will use Ruta rules to post-process the output of a Part-of-Speech tagger.
The POS tagger is a UIMA annotator that iterates over sentences and tokens and updates the posTag field of each Token with a part of speech.
For example, given this text &#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>The quick brown fox receives many bets.
The fox places many bets.
The fox gets up early.
The rabbit made up this story.</code></pre>
</div>
</div>
<div class="paragraph">
<p>... it assigns the posTag JJ (adjective) to the token "brown" , the posTag NN (common noun) to the token "fox" and the tag VBZ (verb, 3rd person singular present) to the token "receives" in the first sentence.</p>
</div>
<div class="paragraph">
<p>We have noticed that the tagger sometimens fails to disambiguate NNS (common noun plural) and VBZ tags, as in the second sentence.
The word "up" also seems to confuse the tagger, which always assigns it an RB (adverb) tag, even when it is a particle (RP) following a verb, as in the third and fourth sentences:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>The|DT quick|JJ brown|JJ fox|NN receives|VBZ many|JJ bets|NNS .|.
The|DT fox|NN places|NNS many|JJ bets|NNS .|.
The|DT fox|NN gets|VBZ up|RB early|RB .|.
The|DT rabbit|NN made|VBD up|RB this|DT story|NN .|.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s imagine that after applying every possible approach available in the POS tagging literature, our tagger still generates these and some other errors.
We decide to write a few Ruta rules to post-process the output of the tagger.</p>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.ae.integration.mvn"><a class="anchor" href="#_ugr.tools.ruta.ae.integration.mvn"></a>4.2.1. Adding Ruta to our Annotator</h4>
<div class="paragraph">
<p>The POS tagger is being developed as a Maven-based project.
Since Ruta maven artifacts are available on Maven Central, we add the following dependency to the project&#8217;s pom.xml.
The functionalities described in this section require a version of Ruta equal to or greater than 2.1.0.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>&lt;dependency&gt;
  &lt;groupId&gt;org.apache.uima&lt;/groupId&gt;
  &lt;artifactId&gt;ruta-core&lt;/artifactId&gt;
  &lt;version&gt;[2.0.2,)&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>We also take care that the Ruta basic typesystem is loaded when our annotator is initialized.
The Ruta typesystem descriptors are available from ruta-core/src/main/resources/org/apache/uima/ruta/engine/</p>
</div>
</div>
<div class="sect3">
<h4 id="_ugr.tools.ruta.ae.integration.loading"><a class="anchor" href="#_ugr.tools.ruta.ae.integration.loading"></a>4.2.2. Developing Ruta rules and applying them from inside Java code</h4>
<div class="paragraph">
<p>We are now ready to write some rules.
The ones we develop for fixing the two errors look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>Token.posTag =="NN" Token.posTag=="NNS"{-&gt; Token.posTag="VBZ"}
    Token.posTag=="JJ";
Token{REGEXP(Token.posTag, "VB(.?)")}
    Token.posTag=="RB"{REGEXP("up")-&gt; Token.posTag="RP"};</code></pre>
</div>
</div>
<div class="paragraph">
<p>That is, we change a Token&#8217;s NNS tag to VBZ, if it is surrounded by a Token tagged as NN and a Token tagged as JJ.
We also change an RB tag for an "up" token to RP, if "up" is preceded by any verbal tag (VB, VBZ, etc.) matched with the help of the <a href="#_ugr.tools.ruta.language.conditions.regexp">REGEXP</a> condition.</p>
</div>
<div class="paragraph">
<p>We test our rules in the Ruta Workbench and see that they indeed fix most of our problems.
We save those and some more rules in a text file src/main/resources/ruta.txt.</p>
</div>
<div class="paragraph">
<p>We declare the file with our rules as an external resource and we load it during initialization.
Here&#8217;s a way to do it using uimaFIT:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>/**
 * Ruta rules for post-processing the tagger's output
 */
public static final String RUTA_RULES_PARA = "RutaRules";
ExternalResource(key = RUTA_RULES_PARA, mandatory=false)
...
File rutaRulesF = new File((String)
    aContext.getConfigParameterValue(RUTA_RULES_PARA));</code></pre>
</div>
</div>
<div class="paragraph">
<p>After our CAS has been populated with posTag annotations from the main algorithm, we post-process the CAS using Ruta.apply():</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>String rutaRules = org.apache.commons.io.FileUtils.readFileToString(
    rutaRulesF, "UTF-8");
Ruta.apply(cas,  rutaRules);</code></pre>
</div>
</div>
<div class="paragraph">
<p>We are now happy to see that the final output of our annotator now looks much better:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>The|DT quick|JJ brown|JJ fox|NN receives|VBZ many|JJ bets|NNS .|.
The|DT fox|NN places|VBZ many|JJ bets|NNS .|.
The|DT fox|NN gets|VBZ up|RP early|RB .|.
The|DT rabbit|NN made|VBD up|RP this|DT story|NN .|.</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_ugr.tools.ruta.maven"><a class="anchor" href="#_ugr.tools.ruta.maven"></a>4.3. UIMA Ruta Maven Plugin</h3>
<div class="paragraph">
<p>UIMA Ruta provides a maven plugin for building analysis engine and type system descriptors for rule scripts.
Additionally, this maven plugin is able able to compile word list (gazetteers) to the more efficient structures, tree word list and multi tree word list.
The usage and configuration is shortly summarized in the following.
An exemplary maven project for UIMA Ruta is given here: <code><a href="https://github.com/apache/uima-ruta/tree/master/example-projects/ruta-maven-example" class="bare">https://github.com/apache/uima-ruta/tree/master/example-projects/ruta-maven-example</a></code></p>
</div>
<div class="sect3">
<h4 id="_generate_goal"><a class="anchor" href="#_generate_goal"></a>4.3.1. generate goal</h4>
<div class="paragraph">
<p>The generate goal can be utilized to create xml descriptors for the UIMA Ruta script files.
Its usage and configuration is summarized in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>&lt;plugin&gt;
&lt;groupId&gt;org.apache.uima&lt;/groupId&gt;
&lt;artifactId&gt;ruta-maven-plugin&lt;/artifactId&gt;
&lt;version&gt;3.0.1&lt;/version&gt;
&lt;configuration&gt;

 &lt;!-- This is a exemplary configuration, which explicitly specifies the
  default configuration values if not mentioned otherwise. --&gt;

 &lt;!--
 The following parameter is optional and should only be specified
 if the structure (e.g., classpath/resources) of the project requires it.

 A FileSet specifying the UIMA Ruta script files that should be built.

 If this parameter is not specified, then all UIMA Ruta script files
 in the output directory (e.g., target/classes) of the project will
 be built.

 default value: none
 &lt;scriptFiles&gt;
   &lt;directory&gt;${basedir}/some/folder&lt;/directory&gt;
   &lt;includes&gt;
     &lt;include&gt;*.ruta&lt;/include&gt;
   &lt;/includes&gt;
 &lt;/scriptFiles&gt;
 --&gt;

 &lt;!-- The directory where the generated type system descriptors will
  be written stored. --&gt;
 &lt;!-- default value: ${project.build.directory}/generated-sources/
   ruta/descriptor --&gt;
 &lt;typeSystemOutputDirectory&gt;${project.build.directory}/generated-sources/
   ruta/descriptor&lt;/typeSystemOutputDirectory&gt;

 &lt;!-- The directory where the generated analysis engine descriptors will
  be stored. --&gt;
 &lt;!-- default value: ${project.build.directory}/generated-sources/ruta/
   descriptor --&gt;
 &lt;analysisEngineOutputDirectory&gt;${project.build.directory}/
  generated-sources/ruta/descriptor&lt;/analysisEngineOutputDirectory&gt;

 &lt;!-- The template descriptor for the generated type system.
  By default the descriptor of the maven dependency is loaded. --&gt;
 &lt;!-- default value: none --&gt;
 &lt;!-- not used in this example &lt;typeSystemTemplate&gt;...
   &lt;/typeSystemTemplate&gt; --&gt;

 &lt;!-- The template descriptor for the generated analysis engine.
   By default the descriptor of the maven dependency is loaded. --&gt;
 &lt;!-- default value: none --&gt;
 &lt;!-- not used in this example &lt;analysisEngineTemplate&gt;...
   &lt;/analysisEngineTemplate&gt; --&gt;

 &lt;!-- Script paths of the generated analysis engine descriptor. --&gt;
 &lt;!-- default value: none --&gt;
 &lt;scriptPaths&gt;
  &lt;scriptPath&gt;${basedir}/src/main/ruta/&lt;/scriptPath&gt;
 &lt;/scriptPaths&gt;

 &lt;!-- Descriptor paths of the generated analysis engine descriptor. --&gt;
 &lt;!-- default value: none --&gt;
 &lt;descriptorPaths&gt;
  &lt;descriptorPath&gt;${project.build.directory}/generated-sources/ruta/
   descriptor&lt;/descriptorPath&gt;
 &lt;/descriptorPaths&gt;

 &lt;!-- Resource paths of the generated analysis engine descriptor. --&gt;
 &lt;!-- default value: none --&gt;
 &lt;resourcePaths&gt;
  &lt;resourcePath&gt;${basedir}/src/main/resources/&lt;/resourcePath&gt;
  &lt;resourcePath&gt;${project.build.directory}/generated-sources/ruta/
   resources/&lt;/resourcePath&gt;
 &lt;/resourcePaths&gt;

 &lt;!-- Suffix used for the generated type system descriptors. --&gt;
 &lt;!-- default value: Engine --&gt;
 &lt;analysisEngineSuffix&gt;Engine&lt;/analysisEngineSuffix&gt;

 &lt;!-- Suffix used for the generated analysis engine descriptors. --&gt;
 &lt;!-- default value: TypeSystem --&gt;
 &lt;typeSystemSuffix&gt;TypeSystem&lt;/typeSystemSuffix&gt;

 &lt;!-- Source file encoding. --&gt;
 &lt;!-- default value: ${project.build.sourceEncoding} --&gt;
 &lt;encoding&gt;UTF-8&lt;/encoding&gt;

 &lt;!-- Type of type system imports. false = import by location. --&gt;
 &lt;!-- default value: false --&gt;
 &lt;importByName&gt;false&lt;/importByName&gt;

 &lt;!-- Option to resolve imports while building. --&gt;
 &lt;!-- default value: false --&gt;
 &lt;resolveImports&gt;false&lt;/resolveImports&gt;

 &lt;!-- Amount of retries for building dependent descriptors. Default value
  -1 leads to three retires for each script. --&gt;
  &lt;!-- default value: -1 --&gt;
 &lt;maxBuildRetries&gt;-1&lt;/maxBuildRetries&gt;

 &lt;!-- List of packages with language extensions --&gt;
 &lt;!-- default value: none --&gt;
 &lt;extensionPackages&gt;
  &lt;extensionPackage&gt;org.apache.uima.ruta&lt;/extensionPackage&gt;
 &lt;/extensionPackages&gt;

 &lt;!-- Add UIMA Ruta nature to .project --&gt;
 &lt;!-- default value: false --&gt;
 &lt;addRutaNature&gt;true&lt;/addRutaNature&gt;


 &lt;!-- Buildpath of the UIMA Ruta Workbench (IDE) for this project --&gt;
 &lt;!-- default value: none --&gt;
 &lt;buildPaths&gt;
  &lt;buildPath&gt;script:src/main/ruta/&lt;/buildPath&gt;
  &lt;buildPath&gt;descriptor:target/generated-sources/ruta/descriptor/
  &lt;/buildPath&gt;
  &lt;buildPath&gt;resources:src/main/resources/&lt;/buildPath&gt;
 &lt;/buildPaths&gt;

&lt;/configuration&gt;
&lt;executions&gt;
 &lt;execution&gt;
  &lt;id&gt;default&lt;/id&gt;
  &lt;phase&gt;process-classes&lt;/phase&gt;
  &lt;goals&gt;
   &lt;goal&gt;generate&lt;/goal&gt;
  &lt;/goals&gt;
 &lt;/execution&gt;
&lt;/executions&gt;
&lt;/plugin&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The configuration parameters for this goal either define the build behavior,  e.g., where the generated descriptor should be placed or which suffix the files should get, or the configuration of the generated analysis engine descriptor, e.g.,  the values of the configuration parameter scriptPaths.
However, there are also other parameters: addRutaNature and buildPaths.
Both can be utilized to configure the current Eclipse project (due to the missing m2e connector). This is required if the functionality of the UIMA Ruta Workbench, e.g., syntax checking or auto-completion, should be available in the maven project.
If the parameter addRutaNature is set to true, then the UIMA Ruta Workbench will recognize the project as a script project.
Only then,  the buildpath of the UIMA Ruta project can be configured using the buildPaths parameter, which specifies  the three important source folders of the UIMA Ruta project.
In normal UIMA Ruta Workbench projects,  these are script, descriptor and resources.</p>
</div>
</div>
<div class="sect3">
<h4 id="_twl_goal"><a class="anchor" href="#_twl_goal"></a>4.3.2. twl goal</h4>
<div class="paragraph">
<p>The twl goal can be utilized to create .twl files from .txt files.
Its usage and configuration is summarized in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>&lt;plugin&gt;
&lt;groupId&gt;org.apache.uima&lt;/groupId&gt;
&lt;artifactId&gt;ruta-maven-plugin&lt;/artifactId&gt;
&lt;version&gt;3.0.1&lt;/version&gt;
&lt;configuration&gt;&lt;/configuration&gt;
&lt;executions&gt;
&lt;execution&gt;
 &lt;id&gt;default&lt;/id&gt;
 &lt;phase&gt;process-classes&lt;/phase&gt;
 &lt;goals&gt;
  &lt;goal&gt;twl&lt;/goal&gt;
 &lt;/goals&gt;
 &lt;configuration&gt;
  &lt;!-- This is a exemplary configuration, which explicitly specifies
   the default configuration values if not mentioned otherwise. --&gt;

  &lt;!-- Compress resulting tree word list. --&gt;
  &lt;!-- default value: true --&gt;
  &lt;compress&gt;true&lt;/compress&gt;

  &lt;!-- Remove white spaces when generating word list. --&gt;
  &lt;!-- default value: true --&gt;
  &lt;dictRemoveWS&gt;true&lt;/dictRemoveWS&gt;

  &lt;!-- The source files for the tree word list. --&gt;
  &lt;!-- default value: none --&gt;
  &lt;inputFiles&gt;
   &lt;directory&gt;${basedir}/src/main/resources&lt;/directory&gt;
   &lt;includes&gt;
    &lt;include&gt;*.txt&lt;/include&gt;
   &lt;/includes&gt;
  &lt;/inputFiles&gt;

  &lt;!-- The directory where the generated tree word lists will be
    written to.--&gt;
  &lt;!-- default value: ${project.build.directory}/generated-sources/
    ruta/resources/ --&gt;
  &lt;outputDirectory&gt;${project.build.directory}/generated-sources/ruta/
    resources/&lt;/outputDirectory&gt;

  &lt;!-- Source file encoding. --&gt;
  &lt;!-- default value: ${project.build.sourceEncoding} --&gt;
  &lt;encoding&gt;UTF-8&lt;/encoding&gt;

 &lt;/configuration&gt;
&lt;/execution&gt;
&lt;/executions&gt;
&lt;/plugin&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_mtwl_goal"><a class="anchor" href="#_mtwl_goal"></a>4.3.3. mtwl goal</h4>
<div class="paragraph">
<p>The mtwl goal can be utilized to create a .mtwl file from multiple .txt files.
Its usage and configuration is summarized in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>&lt;plugin&gt;
&lt;groupId&gt;org.apache.uima&lt;/groupId&gt;
&lt;artifactId&gt;ruta-maven-plugin&lt;/artifactId&gt;
&lt;version&gt;3.0.1&lt;/version&gt;
&lt;configuration&gt;&lt;/configuration&gt;
&lt;executions&gt;
&lt;execution&gt;
 &lt;id&gt;default&lt;/id&gt;
 &lt;phase&gt;process-classes&lt;/phase&gt;
 &lt;goals&gt;
  &lt;goal&gt;mtwl&lt;/goal&gt;
 &lt;/goals&gt;
 &lt;configuration&gt;
  &lt;!-- This is a exemplary configuration, which explicitly specifies
   the default configuration values if not mentioned otherwise. --&gt;

  &lt;!-- Compress resulting tree word list. --&gt;
  &lt;!-- default value: true --&gt;
  &lt;compress&gt;true&lt;/compress&gt;

  &lt;!-- Remove white spaces when generating word list. --&gt;
  &lt;!-- default value: true --&gt;
  &lt;dictRemoveWS&gt;true&lt;/dictRemoveWS&gt;

  &lt;!-- The source files for the multi tree word list. --&gt;
  &lt;!-- default value: none --&gt;
  &lt;inputFiles&gt;
   &lt;directory&gt;${basedir}/src/main/resources&lt;/directory&gt;
   &lt;includes&gt;
    &lt;include&gt;*.txt&lt;/include&gt;
   &lt;/includes&gt;
  &lt;/inputFiles&gt;

  &lt;!-- The directory where the generated tree word list will be
    written to. --&gt;
  &lt;!-- default value: ${project.build.directory}/generated-sources/ruta/
    resources/generated.mtwl --&gt;
  &lt;outputFile&gt;${project.build.directory}/generated-sources/ruta/resources/
    generated.mtwl&lt;/outputFile&gt;

  &lt;!-- Source file encoding. --&gt;
  &lt;!-- default value: ${project.build.sourceEncoding} --&gt;
  &lt;encoding&gt;UTF-8&lt;/encoding&gt;

 &lt;/configuration&gt;
&lt;/execution&gt;
&lt;/executions&gt;
&lt;/plugin&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_ugr.tools.ruta.archetype"><a class="anchor" href="#_ugr.tools.ruta.archetype"></a>4.4. UIMA Ruta Maven Archetype</h3>
<div class="paragraph">
<p>UIMA Ruta provides a maven archetype for creating maven projects that preconfigured for  building UIMA Ruta scripts with maven and contain already a minimal example with a unit test,  which can be utilized as a starting point.</p>
</div>
<div class="paragraph">
<p>A UIMA Ruta project are created with following command using the the archetype (in one line):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>mvn archetype:generate
    -DarchetypeGroupId=org.apache.uima
    -DarchetypeArtifactId=ruta-maven-archetype
    -DarchetypeVersion=&lt;ruta-version&gt;
    -DgroupId=&lt;package&gt;
    -DartifactId=&lt;project-name&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The placeholders need to be replaced with the corresponding values.
This could look like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>mvn archetype:generate -DarchetypeGroupId=org.apache.uima
    -DarchetypeArtifactId=ruta-maven-archetype -DarchetypeVersion=3.0.1
    -DgroupId=my.domain -DartifactId=my-ruta-project</code></pre>
</div>
</div>
<div class="paragraph">
<p>Using the archetype in Eclipse to create a project may result in some missing replacements  of variables and thus to broken projects.
Using the archetype on command line is recommended.</p>
</div>
<div class="paragraph">
<p>In the creation process, several properties need to be defined.
Their default values can be accepted by simply pressing the return key.
After the project was created successfully, switch to the new folder and enter 'mvn install'. Now, the UIMA Ruta project is built: the descriptors for the UIMA Ruta script are created,  the wordlist is compiled to a MTWL file, and the unit test verifies the overall functionality.</p>
</div>
</div>
<div class="sect2">
<h3 id="_section.tools.ruta.workbench.textruler.example"><a class="anchor" href="#_section.tools.ruta.workbench.textruler.example"></a>4.5. Induce rules with the TextRuler framework</h3>
<div class="paragraph">
<p>This section gives a short example how the TextRuler framework is applied in order to induce annotation rules.
We refer to the screenshot in <a href="#_figure.tools.ruta.workbench.textruler.main">Figure 17</a> for the configuration and are using the exemplary UIMA Ruta project &#8220;TextRulerExample&#8221;, which is part of the source release of UIMA Ruta.
After importing the project into your workspace, please rebuild all UIMA Ruta scripts in order to create the descriptors, e.g., by cleaning the project.</p>
</div>
<div class="paragraph">
<p>In this example, we are using the &#8220;KEP&#8221; algorithm for learning annotation rules for identifying Bibtex entries in the reference section of scientific publications:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Select the folder &#8220;single&#8221; and drag and drop it to the &#8220;Training Data&#8221; text field. This folder contains one file with  correct annotations and serves as gold standard data in our example.</p>
</li>
<li>
<p>Select the file &#8220;Feature.ruta&#8221; and drag and drop it to the &#8220;Preprocess Script&#8221; text field. This UIMA Ruta script knows all necessary types, especially the types of the annotations we try the learn rules for, and additionally it contains rules that create useful annotations, which can be used by the algorithm in order to learn better rules.</p>
</li>
<li>
<p>Select the file &#8220;InfoTypes.txt&#8221; and drag and drop it to the &#8220;Information Types&#8221; list. This specifies the goal of the learning process,  which types of annotations should be annotated by the induced rules, respectively.</p>
</li>
<li>
<p>Check the checkbox of the &#8220;KEP&#8221; algorithm and press the start button in the toolbar fo the view.</p>
</li>
<li>
<p>The algorithm now tries to induce rules for the targeted types. The current result is displayed in the view &#8220;KEP Results&#8221; in the right part of the perspective.</p>
</li>
<li>
<p>After the algorithms finished the learning process, create a new UIMA Ruta file in the &#8220;uima.ruta.example&#8221; package and copy the content of the result view to the new file. Now, the induced rules can be applied as a normal UIMA Ruta script file.</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_section.tools.ruta.howto.html"><a class="anchor" href="#_section.tools.ruta.howto.html"></a>4.6. HTML annotations in plain text</h3>
<div class="paragraph">
<p>The following script provides an example how to process HTML files with UIMA Ruta in order to get plain text documents  that still contain information about the HTML tags in form of annotations.
The analysis engine descriptor HtmlViewWriter is identical to the common ViewWriter,  but additionally specifies a type system.
More information about different options to configure the conversion can be found in <a href="#_ugr.tools.ruta.ae.htmlconverter">here</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>PACKAGE uima.ruta.example;

ENGINE utils.HtmlAnnotator;
ENGINE utils.HtmlConverter;
ENGINE HtmlViewWriter;
TYPESYSTEM utils.HtmlTypeSystem;
TYPESYSTEM utils.SourceDocumentInformation;

Document{-&gt; RETAINTYPE(SPACE,BREAK)};
Document{-&gt; EXEC(HtmlAnnotator)};

Document { -&gt; CONFIGURE(HtmlConverter, "inputView" = "_InitialView",
    "outputView" = "plain"),
      EXEC(HtmlConverter)};

Document{ -&gt; CONFIGURE(HtmlViewWriter, "inputView" = "plain",
    "outputView" = "_InitialView", "output" = "/../converted/"),
    EXEC(HtmlViewWriter)};</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_section.tools.ruta.howto.sorter"><a class="anchor" href="#_section.tools.ruta.howto.sorter"></a>4.7. Sorting files with UIMA Ruta</h3>
<div class="paragraph">
<p>The following script provides an example how to utilize UIMA Ruta for sorting files.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>ENGINE utils.XMIWriter;
TYPESYSTEM utils.SourceDocumentInformation;

DECLARE Pattern;

// some rule-based pattern
(NUM SPECIAL NUM SPECIAL NUM){-&gt; Pattern};

Document{CONTAINS(Pattern)-&gt;CONFIGURE(XMIWriter,
  "Output" = "../with/"), EXEC(XMIWriter)};
Document{-CONTAINS(Pattern)-&gt;CONFIGURE(XMIWriter,
  "Output" = "../without/"), EXEC(XMIWriter)};</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_section.tools.ruta.howto.xml"><a class="anchor" href="#_section.tools.ruta.howto.xml"></a>4.8. Converting XML documents with UIMA Ruta</h3>
<div class="paragraph">
<p>The following script provides an example how to process XML files in order to retain only the text content.
the removed XML elements should, howver, be available as annotations.
This script can therefore be applied to create xmiCAS files from text document annotated with XML tags.
The analysis engine descriptor TEIViewWriter is identical to the common ViewWriter,  but additionally specifies a type system.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>ENGINE utils.HtmlAnnotator;
TYPESYSTEM utils.HtmlTypeSystem;
ENGINE utils.HtmlConverter;
ENGINE TEIViewWriter;
TYPESYSTEM utils.SourceDocumentInformation;

DECLARE PersName, LastName, FirstName, AddName;

Document{-&gt;EXEC(HtmlAnnotator, {TAG})};
Document{-&gt; RETAINTYPE(MARKUP,SPACE)};
TAG.name=="PERSNAME"{-&gt; PersName};
TAG.name=="SURNAME"{-&gt; LastName};
TAG.name=="FORENAME"{-&gt; FirstName};
TAG.name=="ADDNAME"{-&gt; AddName};
Document{-&gt; RETAINTYPE};

Document { -&gt; CONFIGURE(HtmlConverter, "inputView" = "_InitialView",
    "outputView" = "plain", "skipWhitespaces" = false),
      EXEC(HtmlConverter)};

Document{ -&gt; CONFIGURE(TEIViewWriter, "inputView" = "plain", "outputView" =
    "_InitialView", "output" = "/../converted/"),
    EXEC(TEIViewWriter)};</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Version 3.4.0<br>
Last updated 2024-01-15 15:24:10 +0100
</div>
</div>
</body>
</html>