<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>UIMA Version 3 User's Guide</title><link rel="stylesheet" type="text/css" href="css/stylesheet-html.css"><meta name="generator" content="DocBook XSL-NS Stylesheets V1.76.1"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div lang="en" class="book" title="UIMA Version 3 User's Guide" id="d5e1"><div xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div><h1 class="title">UIMA Version 3 User's Guide</h1></div><div><div class="authorgroup">
      <h3 class="corpauthor">Written and maintained by the Apache UIMA&#8482; Development Community</h3>
    </div></div><div><p class="releaseinfo">Version 3.0.0-beta</p></div><div><p class="copyright">Copyright &copy; 2006, 2017 The Apache Software Foundation</p></div><div><p class="copyright">Copyright &copy; 2004, 2006 International Business Machines Corporation</p></div><div><div class="legalnotice" title="Legal Notice"><a name="d5e8"></a>
      <p> </p>
      <p title="License and Disclaimer">
        <b>License and Disclaimer.&nbsp;</b>

        The ASF licenses this documentation
           to you under the Apache License, Version 2.0 (the
           "License"); you may not use this documentation except in compliance
           with the License.  You may obtain a copy of the License at
         
         </p><div class="blockquote"><blockquote class="blockquote">
           <a class="ulink" href="http://www.apache.org/licenses/LICENSE-2.0" target="_top">http://www.apache.org/licenses/LICENSE-2.0</a>
         </blockquote></div><p title="License and Disclaimer">
         
           Unless required by applicable law or agreed to in writing,
           this documentation and its contents are distributed under the License 
           on an 
           "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
           KIND, either express or implied.  See the License for the
           specific language governing permissions and limitations
           under the License.
         
      </p>
      <p> </p>
      <p> </p>
      <p title="Trademarks">
        <b>Trademarks.&nbsp;</b>
        All terms mentioned in the text that are known to be trademarks or 
        service marks have been appropriately capitalized.  Use of such terms
        in this book should not be regarded as affecting the validity of the
        the trademark or service mark.
        
      </p>
    </div></div><div><p class="pubdate">November, 2017</p></div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="chapter"><a href="#uv3.overview">1. Overview</a></span></dt><dd><dl><dt><span class="section"><a href="#uv3.overview.new">1.1. What's new</a></span></dt><dt><span class="section"><a href="#uv3.overview.java8">1.2. Java 8 is required</a></span></dt></dl></dd><dt><span class="chapter"><a href="#uv3.backwards_compatibility">2. Backwards Compatibility</a></span></dt><dd><dl><dt><span class="section"><a href="#uv3.backwards_compatibility.jcas">2.1. JCas and non-JCas APIs</a></span></dt><dd><dl><dt><span class="section"><a href="#uv3.backwards_compatibility.jcas.names">2.1.1. JCas reserved names</a></span></dt></dl></dd><dt><span class="section"><a href="#uv3.backwards_compatibility.serialization">2.2. Serialization forms</a></span></dt><dd><dl><dt><span class="section"><a href="#uv3.backwards_compatibility.serialization.deltas">2.2.1. Delta CAS Version 2 Binary deserialization not supported</a></span></dt></dl></dd><dt><span class="section"><a href="#uv3.backwards_compatibility.low_level_apis">2.3. APIs for creating and modifying Feature Structures</a></span></dt><dt><span class="section"><a href="#uv3.backwards_compatibility.PEARs">2.4. PEAR support</a></span></dt><dt><span class="section"><a href="#uv3.backwards_compatibility.toString">2.5. toString()</a></span></dt><dt><span class="section"><a href="#uv3.backwards_compatibility.logging">2.6. Logging configuration is somewhat different</a></span></dt><dt><span class="section"><a href="#uv3.backwards_compatibility.typesystem_sharing">2.7. Type System sharing</a></span></dt><dt><span class="section"><a href="#uv3.backwards_compatibility.deserializing_0_length">2.8. Deserializing 0 length items in a CAS</a></span></dt><dt><span class="section"><a href="#uv3.backwards_compatibility.checking">2.9. Some checks moved to native Java</a></span></dt><dt><span class="section"><a href="#uv3.backwards_compatibility.class_hierarchy">2.10. Some class hierarchies have been modified</a></span></dt></dl></dd><dt><span class="chapter"><a href="#uv3.new_extended_apis">3. New/Extended APIs</a></span></dt><dd><dl><dt><span class="section"><a href="#uv3.new_extended_apis.index_and_iterator_improvements">3.1. UIMA FSIndex and FSIterators improvements</a></span></dt><dt><span class="section"><a href="#uv3.new_extended_apis.select">3.2. New Select API</a></span></dt><dt><span class="section"><a href="#uv3.new_extended_apis.custom_java_objects">3.3. New custom Java objects in the CAS framework</a></span></dt><dt><span class="section"><a href="#uv3.new_extended_apis.lists_and_arrays">3.4. Built-in lists and arrays</a></span></dt><dd><dl><dt><span class="section"><a href="#uv3.new_extended_apis.reorganized.lists_and_arrays">3.4.1. Built-in lists and arrays have common super classes / interfaces</a></span></dt></dl></dd><dt><span class="section"><a href="#uv3.new_extended_apis.collections">3.5. Many UIMA objects implement Stream or Collection</a></span></dt><dt><span class="section"><a href="#uv3.new_extended_apis.reorganized">3.6. Reorganized APIs</a></span></dt><dt><span class="section"><a href="#uv3.new_extended_apis.class">3.7. Use of JCas Class to specify a UIMA type</a></span></dt><dt><span class="section"><a href="#uv3.new_extended_apis.jcasgen">3.8. JCasGen changes</a></span></dt><dd><dl><dt><span class="section"><a href="#uv3.new_extended_apis.jcas_static_fields">3.8.1. JCas additional static fields</a></span></dt></dl></dd><dt><span class="section"><a href="#uv3.new_extended_apis.generics">3.9. Generics added</a></span></dt><dt><span class="section"><a href="#uv3.new_extended_apis.other">3.10. Other changes</a></span></dt></dl></dd><dt><span class="chapter"><a href="#uv3.select">4. Select framework</a></span></dt><dd><dl><dt><span class="section"><a href="#uv3.select.builder_pattern">4.1. Select's use of the builder pattern</a></span></dt><dt><span class="section"><a href="#uv3.select.sources">4.2. Sources of Feature Structures</a></span></dt><dd><dl><dt><span class="section"><a href="#uv3.select.sources.type">4.2.1. Use of Type in selection of sources</a></span></dt><dt><span class="section"><a href="#uv3.select.sources.generics">4.2.2. Sources and generic typing</a></span></dt></dl></dd><dt><span class="section"><a href="#uv3.select.selection_and_ordering">4.3. Selection and Ordering</a></span></dt><dd><dl><dt><span class="section"><a href="#uv3.select.boolean_properties">4.3.1. Boolean properties</a></span></dt><dt><span class="section"><a href="#uv3.select.any_source">4.3.2. Configuration for any source</a></span></dt><dt><span class="section"><a href="#uv3.select.any_index">4.3.3. Configuration for any index</a></span></dt><dt><span class="section"><a href="#uv3.select.ordered_index">4.3.4. Configuration for sort-ordered indexes</a></span></dt><dt><span class="section"><a href="#uv3.select.annot.subselect">4.3.5. Bounded sub-selection within an Annotation Index</a></span></dt><dt><span class="section"><a href="#uv3.select.annot.variations">4.3.6. Variations in Bounded sub-selection within an Annotation Index</a></span></dt><dt><span class="section"><a href="#uv3.select.annot.subselect.defaults">4.3.7. Defaults for bounded selects</a></span></dt><dt><span class="section"><a href="#uv3.select.annot.follow_precede">4.3.8. Following or Preceding</a></span></dt></dl></dd><dt><span class="section"><a href="#uv3.select.terminal_form_actions">4.4. Terminal Form actions</a></span></dt><dd><dl><dt><span class="section"><a href="#uv3.select.terminal_form_actions.iterators">4.4.1. Iterators</a></span></dt><dt><span class="section"><a href="#uv3.select.terminal_form_actions.arrays_lists">4.4.2. Arrays and Lists</a></span></dt><dt><span class="section"><a href="#uv3.select.terminal_form_actions.single_items">4.4.3. Single Items</a></span></dt><dt><span class="section"><a href="#uv3.select.terminal_form_actions.streams">4.4.4. Streams</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#uv3.custom_java_objects">5. CAS Java Objects</a></span></dt><dd><dl><dt><span class="section"><a href="#uv3.custom_java_objects.tutorial">5.1. Tutorial example</a></span></dt><dt><span class="section"><a href="#uv3.custom_java_objects.new_semibuiltins">5.2. semi-built-in UIMA Types</a></span></dt><dd><dl><dt><span class="section"><a href="#uv3.custom_java_objects.semibuiltin_fsarraylist">5.2.1. FSArrayList</a></span></dt><dt><span class="section"><a href="#uv3.custom_java_objects.semibuiltin_integerarraylists">5.2.2. IntegerArrayList</a></span></dt><dt><span class="section"><a href="#uv3.custom_java_objects.semibuiltin_FSHashSet">5.2.3. FSHashSet</a></span></dt></dl></dd><dt><span class="section"><a href="#uv3.custom_java_objects.design">5.3. Design for reuse</a></span></dt></dl></dd><dt><span class="chapter"><a href="#uv3.logging">6. Logging</a></span></dt><dd><dl><dt><span class="section"><a href="#uv3.logging.levels">6.1. Logging Levels</a></span></dt><dt><span class="section"><a href="#uv3.logging.new_recorded_context_data">6.2. Context Data</a></span></dt><dt><span class="section"><a href="#uv3.logging.markers">6.3. Markers used in UIMA Java core logging</a></span></dt><dt><span class="section"><a href="#uv3.logging.defaults_configuration">6.4. Defaults and Configuration</a></span></dt><dd><dl><dt><span class="section"><a href="#uv3.logging.throttling_annotator_logging">6.4.1. Throttling logging from Annotators</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#uv3.migration">7. Migrating to V3</a></span></dt><dd><dl><dt><span class="section"><a href="#uv3.migration.big_picture">7.1. Migrating: the big picture</a></span></dt><dt><span class="section"><a href="#uv3.migration.migrating_pipeline">7.2. How to migrate</a></span></dt><dt><span class="section"><a href="#uv3.migration.jcas">7.3. Migrating JCas classes</a></span></dt><dd><dl><dt><span class="section"><a href="#uv3.migration.tool_guide.running">7.3.1. Running the migration tool</a></span></dt><dt><span class="section"><a href="#uv3.migration.tool_guide.reports">7.3.2. Understanding the reports</a></span></dt><dt><span class="section"><a href="#uv3.migration.tool_guide.cookbook">7.3.3. Examples</a></span></dt></dl></dd><dt><span class="section"><a href="#uv3.migration.consuming">7.4. Consuming V3 Maven artifacts</a></span></dt></dl></dd><dt><span class="chapter"><a href="#uv3.pears">8. PEAR support</a></span></dt><dd><dl><dt><span class="section"><a href="#uv3.pears.jcas">8.1. JCas issues</a></span></dt><dt><span class="section"><a href="#uv3.pears.java_objects">8.2. Custom Java Objects</a></span></dt></dl></dd><dt><span class="chapter"><a href="#uv3.migration.aids">9. Migration aids</a></span></dt><dd><dl><dt><span class="section"><a href="#uv3.migration.aids.property-table">9.1. Properties Table</a></span></dt></dl></dd></dl></div>
  
  

  
  
  <div class="chapter" title="Chapter&nbsp;1.&nbsp;Overview of UIMA Version 3" id="uv3.overview"><div class="titlepage"><div><div><h2 class="title">Chapter&nbsp;1.&nbsp;Overview of UIMA Version 3</h2></div></div></div>
  
  
  
  <p>UIMA Version 3 adds significant new functionality for the Java SDK, while remaining 
  backward compatible with Version 2.  Much of this new function is enabled by a shift in the 
  internal details of how Feature Structures are represented.  In Version 3, these are represented
  internally as ordinary Java objects, and subject to garbage collection.</p>
  <div class="blockquote"><blockquote class="blockquote"><p>
	  In contrast, version 2 stored Feature Structure data in special internal
	  arrays of <code class="code">ints</code> and other data types.  
	  Any Java object representation of Feature Structures in version 2
	  was merely forwarding references to these internal data representations.
  </p>
  </blockquote></div>    
  
  <p>If JCas is being used in an application, the JCas classes must be migrated, but this can often
  be done automatically.  In Version 3, the JCas classes ending in "_Type" are no longer used, and the 
  main JCas class definitions are much simplified.</p>
  
  <div class="blockquote"><blockquote class="blockquote"><p>
  If an application doesn't use JCas classes, then nothing need be done for migration.
  Otherwise, the JCas classes can be migrated in several ways:
  </p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>generating during build</strong></span></span></dt><dd>
        <p>If the project is built by Maven, it's possible the JCas classes are built from the type descriptions, 
          using UIMA's
          Maven JCasGen plugin.  If so, you can just rebuild the project; the JCasGen plugin for V3 generates
          the new JCas classes. 
          </p>
      </dd><dt><span class="term"><span class="strong"><strong>running the migration utility</strong></span></span></dt><dd>
        <p>This is the recommended way if you can't regenerate the classes from the type descriptions.</p>
	      
	      <p>This does the work of migrating and produces new versions of the JCas classes, which
	      need to replace the existing ones.  It allows complex existing JCas classes to migrated, perhaps
	      with developer assistance as needed.  Once done, the application has no migration startup cost.</p>
	      
	      <p>The migration tool is capable of using existing source or compiled JCas classes as input, and 
	      can migrate classes contained within Jars or PEARs.
	      </p>
      </dd><dt><span class="term"><span class="strong"><strong>regenerating the JCas classes using the JCasGen tool</strong></span></span></dt><dd><p>The JCasGen tool (available as a Eclipse or Maven plugin, or a stand-alone application) 
      generates Version 3 JCas classes from the XML descriptors.</p>
      
      <p>This is perfectly adequate for migrating non-customized JCas classes.  When run from the
      UIMA Eclipse plugin for editing XML component descriptors, it will attempt to merge customizations
      with generated code.  However, its approach is not as comprehensive as the migration tool, which parses
      the Java source code.</p></dd></dl></div><p>
  </p></blockquote></div>
  
  <p>Migration of JCas classes is the first step needed to start using UIMA version 3.  
    See the later chapter on migration for details on using the migration tool.
  </p>
  
  <div class="section" title="1.1.&nbsp;What's new in UIMA Java SDK version 3"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="uv3.overview.new">1.1.&nbsp;What's new in UIMA Java SDK version 3</h2></div></div></div>
  
  
  
  <p>The major improvements in version 3 include:
	  </p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Support for arbitrary Java objects, transportable in the CAS</strong></span></span></dt><dd>
	        <p>Support is added to allow users to define additional UIMA Types whose JCas implementation may 
	        include Java objects, with serialization and deserialization performed using normal CAS transportable
	        data.  A following chapter on Custom Java Objects describes this new facility.</p>
	      </dd><dt><span class="term"><span class="strong"><strong>New UIMA semi-built-in types, built using the custom Java object support</strong></span></span></dt><dd>
	        <p>The new support that allows custom serialization of arbitrary Java objects so they can be transported
            in the CAS (above) is used to implement several new semi-built-in UIMA types.  
	        </p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>FSArrayList</strong></span></span></dt><dd>
	              <p>a Java ArrayList of Feature Structures.  The JCas class implements the List API.</p>
	            </dd><dt><span class="term"><span class="strong"><strong>IntegerArrayList</strong></span></span></dt><dd>
	              <p>a variable length int array.  Supports OfInt iterators.</p>
	            </dd><dt><span class="term"><span class="strong"><strong>FSHashSet</strong></span></span></dt><dd>
	              <p>a Java HashSet containing Feature Structures. This JCas class implements the Set API.</p>
	            </dd></dl></div><p>   
	        </p>
	      </dd><dt><span class="term"><span class="strong"><strong>Select framework for accessing Feature Structures</strong></span></span></dt><dd>
          <p>
            A new <span class="emphasis"><em>select framework</em></span> provides a concise way to work with Feature Structure
            data stored in the CAS or other collections.  It is integrated with the Java 8 <span class="emphasis"><em>stream</em></span>
            framework, while providing additional capabilities supported by UIMA, such as the ability to move
            both forwards and backwards while iterating, moving to specific positions, and doing various kinds
            of specialized Annotation selection such as working with Annotations spanned by another annotation.
          </p>
          <p>By default, when sorted iterators are set up by the select framework, they ignore typePriorities;
            this addresses a need of many use cases, and makes operation when there are many annotations spanning
            the same begin and end more reliable.  Each select can specify to use typePriority as
            part of the ordering when required.</p>
            
          <p>This user's guide has a chapter devoted to this new framework.
          </p>
        </dd><dt><span class="term"><span class="strong"><strong>Elimination of ConcurrentModificationException while iterating over UIMA indexes</strong></span></span></dt><dd>
          <p>The index and iteration mechanisms are improved; it is now allowed to modify the indexes while
          iterating over them (the iteration will be unaffected by the modification).</p>
          
          <p>Note that the automatic index corruption avoidance introduced in more recent versions of UIMA could
          be automatically removing Feature Structures from indexes and adding them back, if the user was updating
          some Feature of a Feature Structure that was part of an index specification for inclusion or ordering purposes.</p>
          <div class="blockquote"><blockquote class="blockquote"><p>In version 2, you would accomplish this using a two pass scheme:
          Pass 1 would iterate and merely collect the Feature Structures to be updated into a Java collection of some kind.
          Pass 2 would use a plain Java iterator over that collection and modify the Feature Structures and/or the UIMA indexes.
          This is no longer needed in version 3; UIMA iterators use a copy-on-write technique to allow index updating,
          while doing whatever minimal copying is needed to continue iteration over the original index.</p>
          </blockquote></div>
          
          <p>In both version 2 and 3, there are 3 iterater movement APIs which have a side effect of insuring the
            iterator is operating correctly over the current index contents.  These are the <code class="code">moveToFirst, 
            moveToLast, and moveTo(some_feature_structure)</code> API calls.  In version 3, using these will
            reinitialize the iterator (if needed) so that it is iterating over the current index contents;
            if the index has not been modified, no reinitialization is needed (or done).</p>
        </dd><dt><span class="term"><span class="strong"><strong>Logging updated</strong></span></span></dt><dd>
          <p>The UIMA logger is a facade that can be hooked up at deploy time to one of several logging backends.
          It has been extended to implement all of the Logger API calls provided in the SLF4j <code class="code">Logger</code>
          interface, and has been changed to use SLF4j as its back-end.  SLF4j, in turn, 
          requires a logging back-end which it 
          determines by examining what's available in the classpath, at deploy time.  This design
          allows UIMA to be more easily embedded in other systems which have their own logging frameworks.</p>
          
          <p>Modern loggers support MDC/NDC and Markers; these are supported now via the slf4j facade.  
          UIMA itself is extended to use these to provide contexts around logging.
          </p> 

          <p>See the following chapter on logging for details.</p>
                  
        </dd><dt><span class="term"><span class="strong"><strong>Automatic garbage collection of unreferenced Feature Structures</strong></span></span></dt><dd>
	        <p>This allows creating of temporary Feature Structures, and automatically reclaiming 
	        space resources when they are no longer needed.  In version 2, space was reclaimed only when a 
	        CAS was reset at the end of processing.</p>
	      </dd><dt><span class="term"><span class="strong"><strong>better performance</strong></span></span></dt><dd>
          <p>The internal design details have been extensively reworked to align
          with  recent trends in computer hardware 
          over the last 10-15 years.  In particular, space and time tradeoffs are adjusted in favor of
          using more memory for better locality-of-reference, which improves performance.
          In addition, the many internal algorithms (such as managing Feature Structure indexes) have
          been improved.   
          </p>
          <p>Type system implementations are reused where possible, reducing the footprint in many scaled-out cases.</p>
        </dd><dt><span class="term"><span class="strong"><strong>Backwards compatible</strong></span></span></dt><dd>
	        <p>Version 3 is intended to be binary backwards compatible - the goal is that you should be able to run 
	        existing applications without recompiling them, except for the need to migrate or regenerate 
          any User supplied JCas Classes.  Utilities are provided to help do the necessary JCas migration mostly automatically.</p>
	      </dd><dt><span class="term"><span class="strong"><strong>Integration with Java 8</strong></span></span></dt><dd>
          <p>Version 3 requires Java 8 as the minimum level.  Some of version 3's new facilities, such as the 
          <code class="code">select</code> framework for accessing Feature Structures from CASs or other collections, 
          integrate with the new Java 8 language constructs, such as <code class="code">Streams</code> and <code class="code">Spliterators</code>.</p>
        </dd><dt><span class="term"><span class="strong"><strong>Programming convenience</strong></span></span></dt><dd>
          <p>Many APIs have been made more consistent and better integrated; see the chapter on new and extended APIs.
            Examples:  UIMA Indexes now implement Iterable, so you can use the Java "extended for" construct directly;
            UIMA Lists have new push and pushNode methods to create and link a new node onto the front of a list;
            there are new methods on the CAS and JCas to get a shared instance of common immutable objects, like
            0-length arrays and empty lists.</p>
        </dd></dl></div><p>
  </p>
  
  <p>Just to give a small taste of the kinds of things Java 8 integration provides, 
  here's an example of using the new <code class="code">select</code> framework, where the task is to compute
  </p><div class="itemizedlist"><ul class="itemizedlist" type="disc" compact><li class="listitem"><p>a Set of all the found types
  </p><div class="itemizedlist"><ul class="itemizedlist" type="circle" compact><li class="listitem"><p>in a UIMA index</p></li><li class="listitem"><p>under some top-most type "MyType"</p></li><li class="listitem"><p>occurring as Annotations within a particular bounding Annotation</p></li><li class="listitem"><p>that are nonOverlapping</p></li></ul></div><p>
  </p></li></ul></div><p>
  </p>
  
  <p>
  Here is the Java code using the new <code class="code">select</code> framework together with Java 8 streaming functions:
  
  </p><div class="informalexample">  
<pre class="programlisting">Set&lt;Type&gt; foundTypes =
   myIndex.select(MyType.class) 
   .coveredBy(myBoundingAnnotation)
   .nonOverlapping()
   .map(fs -&gt; fs.getType())
   .collect(Collectors.toCollection(TreeSet::new));
</pre>
</div><p>
</p>

<p>
Another example: to collect, by category, the average length of the annotations having that category.
Here we assume that <code class="code">MyType</code> is an <code class="code">Annotation</code> and that it has
a feature called <code class="code">category</code> which returns a String denoting the category:
</p><div class="informalexample">  
<pre class="programlisting">Map&lt;String, Double&gt; freqByCategory =
   myIndex.select(MyType.class)
   .collect(Collectors
     .groupingBy(MyType::getCategory,
                 Collectors.averagingDouble(f -&gt; 
                   (double)(f.getEnd() - f.getBegin()))));
</pre> 
</div><p>
</p>
</div>

<div class="section" title="1.2.&nbsp;Java 8 is required"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="uv3.overview.java8">1.2.&nbsp;Java 8 is required</h2></div></div></div>
  
  <p>The UIMA Java SDK Version 3 requires Java 8 or later.</p>
</div>      
</div>
  <div class="chapter" title="Chapter&nbsp;2.&nbsp;Backwards Compatibility" id="uv3.backwards_compatibility"><div class="titlepage"><div><div><h2 class="title">Chapter&nbsp;2.&nbsp;Backwards Compatibility</h2></div></div></div>
  
  
  
  <p>Because users have made substantial investment in developing
  applications using the UIMA framework, a goal of version 3 is to protect this investment, by enabling
  Annotators and applications developed under previous versions to be able to be used in 
  subsequent versions of the framework.</p>
  
  <p>To this end, version 3 is designed to be backwards compatible, 
  except for needing:
  </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
     <p>possibly a recompilation (due to some rearrangements of many classes and interfaces)</p>
    </li><li class="listitem">
      <p>a new set of User-defined JCas classes (if these were
        previously being used). The creation of these Cas classes
        can be done by regenerating them using JCasGen, or by 
        using a migration tool that handles converting the existing JCas classes.
        A later chapter covers how to upgrade the JCas classes.</p>
    </li></ul></div><p>
  There are some additional exceptions, described in the following sections.
  </p>
  
  <div class="section" title="2.1.&nbsp;JCas and non-JCas APIs"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="uv3.backwards_compatibility.jcas">2.1.&nbsp;JCas and non-JCas APIs</h2></div></div></div>  
    

    <p>The JCas class changes include no longer needing or using the <code class="code">Xyz_Type</code>
      sister classes for each main JCas class.  User code is unlikely to access these sister classes.
      The JCas API method to access this sister class now throws a UnsupportedOperation exception.
    </p>
        
    <p>The non-JCas Java cover classes for the built-in UIMA types remain, for backwards compatibility.
      So, if you have code that casts a Feature Structure instance to AnnotationImpl (a now deprecated 
      version 2 non-JCas Java cover class), that will continue to work.  
    </p>
    
    <div class="section" title="2.1.1.&nbsp;Additional reserved names in the JCas generated classes"><div class="titlepage"><div><div><h3 class="title" id="uv3.backwards_compatibility.jcas.names">2.1.1.&nbsp;Additional reserved names in the JCas generated classes</h3></div></div></div>  
    
    

    <p>Names beginning with "_" (underscore) are being used by the new JCas implementation, so you should not
      name things with this convention.  If you do, please insure your names are not colliding with the names
      being used by the generated JCas files.
    </p>
    
    </div>
  </div>
  
  
  <div class="section" title="2.2.&nbsp;Serialization forms"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="uv3.backwards_compatibility.serialization">2.2.&nbsp;Serialization forms</h2></div></div></div>  
	  
	  
	  <p>
	  The backwards compatibility extends to the serialized forms, so that it should be
	  possible to have a UIMA-AS services working with a client, where the client is a version 3 instance, but the
	  server is still a version 2 (or vice versa).</p>
	  
	  <div class="section" title="2.2.1.&nbsp;Delta CAS Version 2 Binary deserialization not supported"><div class="titlepage"><div><div><h3 class="title" id="uv3.backwards_compatibility.serialization.deltas">2.2.1.&nbsp;Delta CAS Version 2 Binary deserialization not supported</h3></div></div></div>  
	    
	    
	    <p>The binary serialization forms, including Compressed Binary Form 4, build an
	      internal model of the v2 CAS in order to be able to deserialize v2 generated
	      versions.  For <span class="strong"><strong>delta</strong></span> CAS, this model cannot be accurately built, because version 3
	      excludes from the model all unreachable Feature Structures, so in most cases it
	      won't match the version 2 layout.  
	    </p>
	    
	    <p>Version 3 will throw an exception if delta CAS deserialization of a version 2
	      binary delta CAS is attempted.
	    </p>
    </div>
	  
  </div>
  
  <div class="section" title="2.3.&nbsp;APIs for creating and modifying Feature Structures"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="uv3.backwards_compatibility.low_level_apis">2.3.&nbsp;APIs for creating and modifying Feature Structures</h2></div></div></div>
    
    
    <p>There are 3 sets of APIs for creating and modifying Feature Structures;
      all are supported in V3.
    </p><div class="itemizedlist"><ul class="itemizedlist" type="disc" compact><li class="listitem">
        <p>Using the JCas classes</p>
      </li><li class="listitem">
        <p>Using the normal CAS interface with Type and Feature objects</p>
      </li><li class="listitem">
        <p>Using the low level CAS interface with int codes for Types and Features</p>
      </li></ul></div><p>
    </p>
    
    <p>Version 3 retains all 3 sets, to enable backward compatibility.</p>
    <p>The low level CAS interface was originally provided to enable a extra-high-performance
      (but without compile-time type safety checks) mode.  
      In Version 3, this mode is actually somewhat slower than the others, and no longer has any advantages.      
    </p>
    <p>Using the low level CAS interface also sometimes blocks one of the new features of Version 3 - 
    namely, automatic
    garbage collection of unreachable Feature Structures.  This is because creating a Feature Structure using the
    low level API creates the Java object for that Feature Structure, but returns an "int" handle to it.  
    In order to be able to find the Feature Structure, given that int handle, an entry is made in an internal map.
    This map holds a reference to this Feature Structure, which prevents it from being garbage collected (until of coursse,
    the CAS is reset).
    </p>
    
    <p>The normal CAS APIs allow writing Annotators where the type system is unknown at compile time; these 
    are fully supported.</p>    
    
  </div>
  
  <div class="section" title="2.4.&nbsp;PEAR support"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="uv3.backwards_compatibility.PEARs">2.4.&nbsp;PEAR support</h2></div></div></div>
       
    
    <p>Pears are supported in Version 3.  If they use JCas, their JCas classes need to be migrated.
    </p>
    
    <p>When a PEAR contains a JCas class definition different from the surrounding non-PEAR context,
    each Feature Structure instance within that PEAR has a lazily-created "dual" representation using
    the PEAR's JCas class definition.  The UIMA framework things storing references to Feature Structures
    are modified to store the non-PEAR version of the Feature Structure, but to return (when in 
    a particular PEAR component in the pipeline) the dual version.  The intent is that this be 
    "invisible" to the PEAR's annotators.  Both of these representations share the same 
    underlying CAS data, so modifications to one are seen in the other.
    </p>
    
    <p>If a user builds code that holds onto Feature Structure references, outside of 
    annotators (e.g., as a shared External Resource), and sets and references these from
    both outside and inside one (or more) PEARs, they should adopt a strategy of storing
    the non-PEAR form.  To get the non-PEAR form from a Feature Structure, use the method
    <code class="code">myFeatureStructure._maybeGetBaseForPearFs()</code>.
    </p>
    
    <div class="blockquote"><blockquote class="blockquote"><p>Similarly, if code running in an Annotator within a PEAR wants to
    work with a Feature Structure extracted from non-UIMA managed data outside of annotators
    (e.g., such as a shared External Resource) where the form stored is the non-PEAR form,
    you can convert to the PEAR form using the method 
    <code class="code">myFeatureStructure.__maybeGetPearFs()</code>.  This method checks to see if
    the processing context of the pipeline is currently within a PEAR, and if that PEAR has
    a different definition for that JCas class, and if so, it returns that version of the
    Feature Structure. 
    </p></blockquote></div>
    
    <p>The new Java Object support does not support multiple, 
      different JCas class definitions for the same 
      UIMA Type, inside and outside of the PEAR context.  
      If this is detected, a runtime exception is thrown.
    </p>
    
    <p>The workaround for this is to manually merge any JCas class definitions for the same class.</p>
  </div>
  
  <div class="section" title="2.5.&nbsp;toString()"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="uv3.backwards_compatibility.toString">2.5.&nbsp;toString()</h2></div></div></div>
       
    
    <p>
      The formatting of various UIMA artifacts, including Feature Structures,
      has changed somewhat, to be more informative.  This may impact 
      situations such as testing, where the exact string representations
      are being compared.
    </p>
    
    <p>A special global Java property, -Duima.v2_pretty_print_format can be set to have the toString() operation
      for Feature Sructures print in the V2 style.
    </p>
  </div>
  
  <div class="section" title="2.6.&nbsp;Logging configuration is somewhat different"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="uv3.backwards_compatibility.logging">2.6.&nbsp;Logging configuration is somewhat different</h2></div></div></div>
       
    
    <p>The default logging configuration in v2 was to use Java Util Logging (the logger built into Java).
    For v3, the default is to use SLF4J which, in turn, picks a back-end logger, depending on what it finds
    in the class path.</p>
    
    <p>This change was done to permit easier integration of UIMA as a library running within other frameworks.
    </p>
    
    <p>V3 UIMA logger includes the APIs like info(..), warn(..) etc., that are part of the 
      SLF4j APIs.  In addition, these are augmented with the Java 8 style lambda arguments that
      were introduced in log4j-2, for more concise and efficient log message computation.</p>
      
    <p>The new UIMA Logger APIs (e.g. logger.info(...), logger.warn(...)) 
      use the SLF4j and other modern logger substitutable notation of "{}", as opposed
      to the style adopted by the original Java logger, of "{nnn}".  All modern loggers have switched to
      this. </p>  
      
    <p>The technique for (optionally) reporting the class and method (and sometimes, line number) 
    was changed to conform to current logger conventions - whereby the loggers themselves obtain this
    information from the call stack.  The V2 calls which pass in the sourceClass and sourceMethod information
    have this information ignored, but replaced with what the loggers obtain from the stack track.
    In some cases, where the callers in V2 were not actually passing in the correct class/method information,
    this will result in a different log record.</p>
    
    <p>
      For more details, please see the logging chapter.
    </p>
  </div>
    
  <div class="section" title="2.7.&nbsp;Type System sharing"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="uv3.backwards_compatibility.typesystem_sharing">2.7.&nbsp;Type System sharing</h2></div></div></div>
       
    
    <p>Type System definitions are shared when they are equal.  After type systems 
    have been built up from type definitions, at "commit" time, a check is made to see if an
    identical type system already exists (same types and features).  
    This is often the case when a UIMA application is
    scaling up by adding multiple pipelines, all using the same type system.  
    </p>
    
    <p>If an identical committed type system already exists, then the commit operation returns 
    it, and the one just built is discarded.  Normally, this is not an issue.
    However, some application code may save references to the type system object or to defined types and features.  
    These references end up pointing to the discarded version, when the commit operation finds an already 
    committed equal version.</p>
    
    <p>Application code may code around this by re-acquiring references to the type system object, and to any type and feature
    objects, if the type system instance object returned from <code class="code">commit</code> is not identical (==) to the
    one being committed.
    The type system commit APIs are changed to return the type system - either the one being committed, or an
    already existing equal committed type system.  So when coding
    <code class="code">myTypesystem.commit();</code> if you later refer to <code class="code">myTypesystem</code>, change this to
    <code class="code">myTypesystem = myTypesystem.commit();</code>, to keep the variable <code class="code">myTypesystem</code> always
    referring to to the committed type system.
    </p>
  </div>
  
  <div class="section" title="2.8.&nbsp;Deserializing 0 length items in a CAS"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="uv3.backwards_compatibility.deserializing_0_length">2.8.&nbsp;Deserializing 0 length items in a CAS</h2></div></div></div>
       
    
    <p>In V3, 0-length arrays and lists belonging to one CAS are deserialized into a shared Java object.  Since 
      0-length arrays and lists are
      immutable, this should normally not matter.  It could cause problems if the application somehow is
      depending on object non-identity equality for these items.
    </p>
  </div>
  
  <div class="section" title="2.9.&nbsp;Some checks moved to native Java"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="uv3.backwards_compatibility.checking">2.9.&nbsp;Some checks moved to native Java</h2></div></div></div>
       
    
    <p>In the interest of performance, some duplicate checks, such as whether an array index is within bounds, 
    have been removed from UIMA when they are already being checked by the underlying Java runtime.  
    This has affected some of the internal APIs, such as the JCas's <code class="code">checkArrayBounds</code>
    which was removed because it was no longer being used.
    </p>
  </div>
  
  <div class="section" title="2.10.&nbsp;Some class hierarchies have been modified"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="uv3.backwards_compatibility.class_hierarchy">2.10.&nbsp;Some class hierarchies have been modified</h2></div></div></div>
       
    
    <p>The various JCas Classes implementing the built-ins for arrays have some additional
      interfaces added, grouping them into <code class="code">CommonPrimitiveArray</code> or 
      <code class="code">CommonArray</code>.  These changes are internal, and should not affect users.
    </p>
  </div>
  </div>
  <div class="chapter" title="Chapter&nbsp;3.&nbsp;New and Extended APIs" id="uv3.new_extended_apis"><div class="titlepage"><div><div><h2 class="title">Chapter&nbsp;3.&nbsp;New and Extended APIs</h2></div></div></div>
  
  
      
  <div class="section" title="3.1.&nbsp;UIMA FSIndex and FSIterators improvements"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="uv3.new_extended_apis.index_and_iterator_improvements">3.1.&nbsp;UIMA FSIndex and FSIterators improvements</h2></div></div></div>
    
    
    <p>The FSIndex interface implements Collection, so you can now write <code class="code">for (MyType item : myIndex)</code> to
       iterate over an index.</p>
       
    <p>Because it implements Collection, the FSIndex interface includes a <code class="code">stream()</code> method, so you can now write <code class="code">myIndex.stream().any-stream-operations</code>,
      which will use the items in the index as the source of the stream.</p>
         
    <p>The FSIterator interface now implements the Java ListIterator Interface, and supports the methods there
      except for add, nextIndex, previousIndex, and set; the remove() method's meaning is changed to remove the item
      from all of the UIMA indexes.
    </p>
    
    <p>The iterators over indexes no longer throw concurrent modification exceptions if the index is modified
    while it is being iterated over.  Instead, the iterators use a lazily-created copy-on-write approach that, when
    some portion of the index is updated, prior to the update, copies the original state of that portion, and continues
    to iterate over that.  While this is helpful if you are explicitly modifying the indexes in a loop, it 
    can be especially helpful when modifying Feature Structures as you iterate, because
    the UIMA support for detecting and avoiding possible index corruption if you modify some feature being used by 
    some index as a key, is automatically (under the covers) temporarily removing the Feature Structure from indexes, 
    doing the modification, and then adding it back.
    </p>
    
    <p>Similarly to version 2, iterator methods <code class="code">moveToFirst, moveToLast, and moveTo(a_positioning_Feature_Structure)</code>
      "reset" the iterator to be able to "see" the current state of the indexes.  This corresponds to resetting the
      concurrent modification detection sensing in version 2, when these methods are used.
    </p>
    
    <p>Note that the phrase <span class="emphasis"><em>Concurrent Modification</em></span> is being used here in a single threading
      to the indexes.  UIMA does not support multi-threaded write access to the CAS; it does support multi-threaded
      read access to a set of CAS Views, concurrent with one thread having write access (to different views).
    </p>
    
    <p>The <code class="code">remove()</code> API for iterators is now implemented for FSIterators.  Its meaning is slightly
    different from the normal Java meaning - it doesn't remove the item from the collection being iterated over; rather
    it removes the Feature Structure returned by <code class="code">get()</code> from all indexes in the view.
    </p>
    
    <p>The FSIterator methods that normally check for iterator validity have versions which skip that check.  This
    may be a performance optimization in cases where you can guarantee the iterator is valid, for example if
    you have a loop which is checking <code class="code">hasNext()</code> and following it with a <code class="code">next()</code>, 
    which is only executed if the
    <code class="code">hasNext()</code> was true.  The non-checking versions are suffixed with Nvc (stands for No Validity Check).</p>
    
    <p>The FSIndex API has a new method, <code class="code">subType(type-spec)</code>, which returns an FSIndex for the same
      index, but specialized to elements which are a subtype of the original index.  The type-spec can be either a 
      JCas class, e.g. <code class="code">MyToken.class</code>, or a UIMA type instance.</p>
  </div>

  <div class="section" title="3.2.&nbsp;New Select API"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="uv3.new_extended_apis.select">3.2.&nbsp;New Select API</h2></div></div></div>
    
    
    <p>A versatile new Select framework for accessing and acting on Feature Structures 
    selected from the CAS or from Indexes or from other collection objects is documented in
    a separate chapter.  This API is integrated with Java 8's Stream facility.
    </p>
  </div>
  
  <div class="section" title="3.3.&nbsp;New custom Java objects in the CAS framework"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="uv3.new_extended_apis.custom_java_objects">3.3.&nbsp;New custom Java objects in the CAS framework</h2></div></div></div>
    
    
    <p>There is a new framework that supports allowing you to add your own custom Java objects as
      objects transportable in the CAS.  A following chapter describes this facility, and some new
      semi-built-in types that make use of it.  
    </p>
  </div>  
  
  <div class="section" title="3.4.&nbsp;Built-in lists and arrays"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="uv3.new_extended_apis.lists_and_arrays">3.4.&nbsp;Built-in lists and arrays</h2></div></div></div>
    
    
    <p>The built-in FSArray JCas class is now parameterized with the type of its
      elements.</p>
    
    <p>UIMA Array and List types implement Iterable, so you can use them
      like this: <code class="code">for (MyType item : myArray) ...</code>.</p>
      
    <p>UIMA Arrays and Lists support <code class="code">contains(element)</code> and <code class="code">isEmpty()</code>.</p>

    <p>UIMA Array and List types support a <code class="code">stream()</code> method
    returning a Stream or a type-specialized sub interface of Stream for primitives 
    (IntStream, LongStream, DoubleStream) 
    over the objects in the collection.  Omitted are stream types where boxing would
    occur - Arrays of Byte, Short, Float, Boolean.</p>

    <p>The <code class="code">iterator()</code> methods for <code class="code">IntegerList
      IntegerArrayList, IntegerArray, 
      DoubleArray,</code> and <code class="code">LongArray</code> return
      an <code class="code">OfInt / OfDouble / OfLong</code> instances.  These are subtypes of 
      <code class="code">Iterator</code> with an additional methods nextInt / nextLong / nextDouble which avoid the
      boxing of the normal iterator.
    </p>
       
    <p>The new <code class="code">select</code> framework supports stream operations; see the "select" chapter for details.
    </p> 
    
    <p>
      A new set of methods on UIMA built-in lists, <code class="code">createNonEmptyNode() and emptyList()</code>, 
      creates a non-empty node of the type, or retrieves a (shared) empty node of the type.  
      These methods are not static, and create or get the instance in the same CAS as the object instance.
      These methods are callable on both the empty and non-empty node instances, or on their shared
      super interface, for example, on NonEmptyFloatList, EmptyFloatList, and FloatList (the common super interface).
    </p>
    
    <p>
      A new set of static methods on UIMA built-in lists and arrays, <code class="code">create(jcas, array_source)</code>
      take a Java array of items, and creates
      a corresponding UIMA built-in list or array populated with items from the array_source.
    </p>
    
    <p>For UIMA Lists and Arrays, the CAS and JCas has emptyXXXList/Array methods, which return
      a shared instance of the immutable empty object.
      The Cas and JCas have generic emptyArray/List, taking an argument JCas class identifying the type, 
      e.g.  FloatArray.class, StringList.class, etc.
    </p>
        
    <p>For lists, there are some new common APIs for all list kinds.
      </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
          <p>
            <code class="code">push(item)</code> pushes the item onto an existing list node, creates a new
            non-empty node, setting its head to <code class="code">item</code> and its tail to the existing list node.
            This allows easy construction of a list in backwards order.
          </p>
        </li><li class="listitem">
          <p>
            <code class="code">pushNode()</code> creates and links in a new node in front of this node.
          </p>
        </li><li class="listitem">
          <p>
            <code class="code">insertNode()</code> creates and links in a new node following this node.
          </p>
        </li><li class="listitem">
          <p>
            <code class="code">createNonEmptyNode()</code> creates a node of the 
                 same type, in the same CAS, without linking it.
          </p>
        </li><li class="listitem">
          <p>
            <code class="code">getCommonTail()</code> gets the tail of the node
          </p>
        </li><li class="listitem">
          <p>
            <code class="code">setTail()</code> sets the tail of the node
          </p>
        </li><li class="listitem">
          <p>
            <code class="code">walkList()</code> walks the list applying a consumer to each item
          </p>
        </li><li class="listitem">
          <p>
            <code class="code">getLength()</code> walks the list to compute its length
          </p>
        </li><li class="listitem">
          <p>
            <code class="code">emptyList</code> returns a shared instance of the empty list of the same type, in the same CAS
          </p>
        </li></ul></div><p>
      
    </p>
      
    <div class="section" title="3.4.1.&nbsp;Built-in lists and arrays have common super classes / interfaces"><div class="titlepage"><div><div><h3 class="title" id="uv3.new_extended_apis.reorganized.lists_and_arrays">3.4.1.&nbsp;Built-in lists and arrays have common super classes / interfaces</h3></div></div></div>
      
        <p>Some methods common to multiple implements were moved to the super classes,
          some classes were made abstract (to prevent them from being instantiated, which would be an error).
          For arrays, a new method common to all arrays, <code class="code">copyValuesFrom()</code> copies values from arrays of the same type.
        </p>        
    </div> 
    
  </div>    
  
  <div class="section" title="3.5.&nbsp;Many UIMA objects implement Stream or Collection"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="uv3.new_extended_apis.collections">3.5.&nbsp;Many UIMA objects implement Stream or Collection</h2></div></div></div>
    
      <p>In Java 8, classes which implement Collection can be converted to streams using the <code class="code">xxx.sream()</code>
        method.  To better integrate with Java 8, the following UIMA classes and interfaces now implement Stream or Collection:
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>FSIndex (implements Collection)</p></li><li class="listitem"><p>all of the built-in Arrays, e.g. FloatArray implement Stream, the Integer/long/double arrays implement the non-boxing version</p></li><li class="listitem"><p>all of the built-in Lists implement Stream, the IntegerList implements the non boxing version</p></li></ul></div><p>
      </p>
  </div> 
 
  
 
  <div class="section" title="3.6.&nbsp;Reorganized APIs"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="uv3.new_extended_apis.reorganized">3.6.&nbsp;Reorganized APIs</h2></div></div></div>
    
    
    <p>Some APIs were reorganized.  Some of the reorganizations include altering the super class
      and implements hierarchies, making some classes abstract, making use of Java 8's new
      <code class="code">default</code> mechanisms to supply default implementations in interfaces, 
      and moving methods to more common places.  Users of the non-internal UIMA APIs
      should not be affected by these reorganizations.
    </p>

    <p>As an example, version 2 had two different Java objects representing particular Feature Structures, such as
    "Annotation".  One was used (<code class="code">org.apache.uima.jcas.tcas.Annotation</code>) if the JCas was enabled; 
    the other (<code class="code">org.apache.uima.cas.impl.AnnotationImpl</code>)otherwise.  In version 3, there's only one implementation;
    the other (AnnotationImpl) is converted to an interface.  Annotation now "implements AnnotationImpl.</p>
  </div>
 
  <div class="section" title="3.7.&nbsp;Use of JCas Class to specify a UIMA type"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="uv3.new_extended_apis.class">3.7.&nbsp;Use of JCas Class to specify a UIMA type</h2></div></div></div>
    
    
    <p>Several APIs require a UIMA type to be specified.  For instance, the API to remove all Feature Structures
    of a particular type requires the type to be specified.  Instead of a UIMA Type object, if there is a JCas
    cover class for that type, you can pass that as well, as (for example) <code class="code">Annotation.class</code>.
    </p>
  </div>
    
  <div class="section" title="3.8.&nbsp;JCasGen changes"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="uv3.new_extended_apis.jcasgen">3.8.&nbsp;JCasGen changes</h2></div></div></div>
    
    
    <p>JCasgen is modified to generate the v3 style of JCas cover classes. 
      It no longer generates the the xxx_Type.java classes, as these are 
      not used by UIMA Version 3.</p>
      
    <div class="section" title="3.8.1.&nbsp;JCas additional static fields"><div class="titlepage"><div><div><h3 class="title" id="uv3.new_extended_apis.jcas_static_fields">3.8.1.&nbsp;JCas additional static fields</h3></div></div></div>
    
    
    <p>Static final string fields are declared for each JCas cover class
      and for each feature that is part of that UIMA type.  The fields look like
      this example, taken from the Sofa class:
      </p><pre class="programlisting">public final static String _TypeName = "org.apache.uima.jcas.cas.Sofa";
public final static String _FeatName_sofaNum    = "sofaNum";
public final static String _FeatName_sofaID     = "sofaID";
public final static String _FeatName_mimeType   = "mimeType";
public final static String _FeatName_sofaArray  = "sofaArray";
public final static String _FeatName_sofaString = "sofaString";
public final static String _FeatName_sofaURI    = "sofaURI";</pre><p>
       Each string has a generated name corresponding to the name of the type or the feature, and
       a string value constant which of the type or feature name. These can be useful in
       Java Annotations.
    </p>
  </div>
          
  </div>
  
  <div class="section" title="3.9.&nbsp;Generics added"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="uv3.new_extended_apis.generics">3.9.&nbsp;Generics added</h2></div></div></div>
    
    
    <p>Version 3 adds generic typing to several structures, and makes use of this to enable users to
      unclutter their code by taking advantage of Java's type inferencing, in many cases.
    </p>
    
    <p>Generic types are added to:
      </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
          <p><span class="emphasis"><em>FSIndex</em></span> &lt;T extends FeatureStructure&gt; the type the index is over.</p>
        </li><li class="listitem">
          <p><span class="emphasis"><em>FSArray</em></span> &lt;T extends FeatureStructure&gt; the type the FSArray holds.</p>
        </li><li class="listitem">
          <p><span class="emphasis"><em>FSList</em></span> &lt;T extends TOP&gt; the type the FSList holds.</p>
        </li><li class="listitem">
          <p><span class="emphasis"><em>SelectFSs</em></span> &lt;T extends FeatureStructure&gt; the type the select is producing.</p>
        </li></ul></div><p>
    </p>
  </div>
  
  <div class="section" title="3.10.&nbsp;Other changes"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="uv3.new_extended_apis.other">3.10.&nbsp;Other changes</h2></div></div></div>
    
    
    <p>The convenience methods in the JCas have been duplicated in the CAS, e.g. <code class="code">getAllIndexFS</code>.</p>
    
    <p>New methods <code class="code">getIndexedFSs(myUimaType)</code> and <code class="code">getIndexedFSs(MyJCas.class)</code> return 
    unmodifiable, unordered Collections of all indexed Feature Structures of the specified type and its subtypes in 
    this CAS's view.  This collection can be
    used in a Java extended-for loop construction. <code class="code">getIndexedFSs()</code> is the same but is for all Feature Structures,
    regardless of type.  These are methods on the CAS, JCas, FSIndexRepository
    interfaces, and return the Feature Structures of the specified type (including subtypes).</p>
    
    <p>The TypeSystemMgr Interface has a variation of the <code class="code">commit</code> method, which has a parameter 
      that specifies the class loader to be used when loading JCas class.  This should be used whenever there are
      user-specified JCas classes associated with the type system.  If not specified, it defaults to the class
      loader used to load the UIMA framework.
    </p>
        
    <p>The utility class <code class="code">org.apache.uima.util.FileUtils</code> has a new method
      <code class="code">writeToFile(path, string)</code>, which efficiently writes a string using UTF-8 encoding to 
      <code class="code">path</code>.
    </p>
    
    <p>The StringArray class has a new <code class="code">contains(a_string)</code> method.</p>
    
    <p>The CAS <code class="code">protectIndexes</code> method returns an instance of AutoClosableNoException which is 
      a subtype where the close method doesn't throw an exception.  This allows writing the try-with-resources
      form without a catch block for Exception.</p>
    
    <p>
      Sometimes Annotators may log excessively, causing problems in production settings.
      Although this could be controlled using logging configuration, sometimes when
      UIMA is embedded into other applications, you may not have easy access to modify those.
     </p><p>
      For this case, the produceAnalysisEngine's "additionalParameters" map supports a new key,  
      AnalysisEngine.PARAM_THROTTLE_EXCESSIVE_ANNOTATOR_LOGGING.  
      This key specifies that throttling should be applied to messages
      produced by annotators using loggers obtained by Annotator code using the getLogger() API.
    </p><p>
      The value specified must be an Integer, and is the number of messages allowed before
      logging is suppressed.  This number is applied to each logging level, separately.
      To suppress all logging, use 0.  
    </p>
    
    <p>The Type interface has new methods <code class="code">subsumes(another_type), isStringOrStringSubtype()</code>, 
        and <code class="code">isStringSubtype().</code></p>

    <p>The FlowController_ImplBase supports a getLogger() API, which is shorthand for getContext().getLogger().</p>
    
    <p>Many error messages were changed or added, causing changes to localization classes.
      For coding efficiency, some of the structure of the internal error reporting calls was changed
      to make use of Java's variable number of arguments syntax.</p>
      
    <p>The UIMA Logger implementation has been extended with both the SLF4J logger APIs and the 
       Log4j APIs which support Java 8's <code class="code">Supplier</code> Functional Interfaces.</p>
 
    <p>The TypeSystem and Type object implementations implement <code class="code">Iterable</code> and will iterate over
      all the defined types, or, for a type, all the defined Features for that type.</p>        
  </div> 
   
</div>
  <div class="chapter" title="Chapter&nbsp;4.&nbsp;The select framework for working with CAS data" id="uv3.select"><div class="titlepage"><div><div><h2 class="title">Chapter&nbsp;4.&nbsp;The select framework for working with CAS data</h2></div></div></div>
  
  
  
  <p>The <span class="emphasis"><em>select</em></span> framework provides a concise way to work with
  Feature Structure data stored in the CAS. It is integrated with the Java 8 <span class="emphasis"><em>stream</em></span>
  framework, and provides additional capabilities supported by the underlying 
  UIMA framework, including the ability to move both forwards and backwards while iterating,
  moving to specific positions, and doing various kinds of specialized Annotation 
  selection such as working with Annotations spanned by another annotation (think of a Paragraph
  annotation, and the Sentences or Tokens within that).
  </p>
  
  <p>There are 3 main parts to this framework:</p>
  
  <div class="itemizedlist"><ul class="itemizedlist" type="disc" compact><li class="listitem">
      <p>The source
      </p>
    </li><li class="listitem">
      <p>what to select, ordering
      </p>
    </li><li class="listitem">
      <p>what to do
      </p>
    </li></ul></div>
  
  <div class="figure"><a name="uv3.select.big_picture"></a><div class="figure-contents">
          
          <div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="564"><tr><td><img src="images/version_3_users_guide/select/select_big_pic.png" width="564" alt="Select composed of sources, what to select, and what to do"></td></tr></table></div>
        </div><p class="title"><b>Figure&nbsp;4.1.&nbsp;Select - the big picture</b></p></div><br class="figure-break">
  
  <p>These are described in code using a builder pattern to specify the many options and parameters.
  Some of the very common parameters are also available as positional arguments in some contexts.
  Most of the variations are defaulted so that in the common use cases, they may be omitted.
  </p>
  
  <div class="section" title="4.1.&nbsp;Select's use of the builder pattern"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="uv3.select.builder_pattern">4.1.&nbsp;Select's use of the builder pattern</h2></div></div></div>
    
    
    <p>The various options and specifications are specified using the builder pattern.
    Each specification has a name, which is a Java method name, sometimes having further parameters.
    These methods return an instance of SelectFSs; this instance is updated by each builder method.
    </p>
    
    <p>A common approach is to chain these methods together.  When this is done, each subsequent method
    updates the SelectFSs instance.  This means that the last method in case there are 
    multiple method calls specifying the same specification is the one that is used.
    </p>
    
    <p>For example,
    </p><pre class="programlisting">a_cas.select().typePriority(true).typePriority(false).typePriority(true)</pre><p>
    would configure the select to be using typePriority (described later).</p>
    
    <p>Some parameters are specified as positional parameters, for example, a UIMA Type, or a starting position or
    shift-offset.</p>
  </div>
  
  <div class="section" title="4.2.&nbsp;Sources of Feature Structures"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="uv3.select.sources">4.2.&nbsp;Sources of Feature Structures</h2></div></div></div>
    
    
    <p>Feature Structures are kept in the CAS, and may be accessed using UIMA Indexes.
    Note that not all Feature Structures in the CAS are in the UIMA indexes; only those that the 
    user had "added to the indexes" are. Feature Structures not in the indexes are not 
    included when using the CAS as the source for the select framework.</p>
    
    <p>  
    Feature Structures may, additionally, be kept in <code class="code">FSArrays</code>, <code class="code">FSLists</code>,
    and many additional collection-style objects that implement <code class="code">SelectViaCopyToArray</code> interface.
    This interface is implemented by the new semi-built-in types <code class="code">FSArrayList</code> and <code class="code">FSHashSet</code>;
    user-defined JCas classes for user types may also choose to implement this.
    All of these sources may be used with <code class="code">select</code>.</p>
    
    <div class="figure"><a name="uv3.select.source_type"></a><div class="figure-contents">
      
      <div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="545"><tr><td><img src="images/version_3_users_guide/select/select_source_type.png" width="545" alt="Sources have select method, which has optional type argument"></td></tr></table></div>
    </div><p class="title"><b>Figure&nbsp;4.2.&nbsp;select method with type</b></p></div><br class="figure-break">
  
    <p>For CAS sources, if Views are being used, there is a separate set of indexes per CAS view.
    When there are multiple views, only one view's set of indexed Feature Structures is accessed - the
    view implied by the CAS being used.  Note that there is a way to specify aggregating over all views; see
    <code class="code">allViews</code> described later.</p>
    
    <p>For CAS sources, users may specify all Feature Structures in a view, or restrict this in two ways:
    </p><div class="itemizedlist"><ul class="itemizedlist" type="disc" compact><li class="listitem">
        <p>specifying an index: Users may define their own indexes, in additional to the built in ones, and 
        then specify which index to use.
        </p>
      </li><li class="listitem">
        <p>specifying a type: Only Feature Structures of this type (or its subtypes) are included.
        </p>
      </li></ul></div><p>
    </p>
    
    <p>It is possible to specify both of these, using the form <code class="code">myIndex.select(myType)</code>; 
        in that case the type must be the type or a subtype of
        the index's top most type.
    </p>
        
    <p>If no index is specified, the default is 
    </p><div class="itemizedlist"><ul class="itemizedlist" type="disc" compact><li class="listitem">
        <p>to use all Feature Structures in a CAS View, or</p>
      </li><li class="listitem">
        <p>to use all Feature Structures in the view's AnnotationIndex,
        if the selection and ordering specifications require an AnnotationIndex.</p>
      </li></ul></div>
    
    <p>Note that the non-CAS collection sources (e.g. the FSArray and FSList sources are considered ordered, but non-sorted, 
          and therefore cannot be used for an operations which require a sorted order.</p>
      
    <p>There are 4 kinds of sources of Feature Structures supported:</p>

    <div class="itemizedlist"><ul class="itemizedlist" type="disc" compact><li class="listitem">
	      <p>a CAS view: all the FSs that were added to the indexes for this view.
	      </p>
	    </li><li class="listitem">
	      <p>an Index over a CAS view. Note that the AnnotationIndex is often implied by other 
	            <code class="code">select</code> specifications, so it is often not necessary to supply this.
	      </p>
	    </li><li class="listitem">
	      <p>Feature Structures from a (semi) built-in UIMA Collection instance, such as instances of the types
	      <code class="code">FSArray, FSArrayList, FSHashSet,</code> etc.
	      </p>
	    </li><li class="listitem">
	      <p>Feature Structures from a user-defined UIMA Collection instance.
	      </p>
	    </li></ul></div>
	  
    <p>UIMA Collection sources have somewhat limited configurability,
    because they are considered non-sorted, 
    and therefore cannot be used for an operations which require a sorted order, such as
    the various bounding selections (e.g. <code class="code">coveredBy</code>) 
    or positioning operations (e.g. <code class="code">startAt</code>).</p>

	  <p>Each of these sources has a new API method, <code class="code">select(...)</code>, which initiates the select specification.
	  The select method can take an optional parameter, specifying the UIMA type to return.
	  If supplied, the type must must be the type or subtype of the index 
	  (if one is specified or implied); it serves to further restrict the types selected beyond whatever the 
	  index (if specified) has as its top-most type.</p>
	    
  <div class="section" title="4.2.1.&nbsp;Use of Type in selection of sources"><div class="titlepage"><div><div><h3 class="title" id="uv3.select.sources.type">4.2.1.&nbsp;Use of Type in selection of sources</h3></div></div></div>
    
	  <p>
	  The optional type argument for <code class="code">select(...)</code> specifies a UIMA type.  This restricts the Feature Structures
	  to just those of the specified type or any of its subtypes.  If omitted, if an index is used as a source, 
	  its type specification is used; otherwise all types are included.</p>
	  
	  <p>Type specifications may be specified in multiple ways.  
	  The best practice, if you have a JCas cover class
	  defined for the type, is to use the form <code class="code">MyJCasClass.class</code>.  This has the advantage of setting the 
	  expected generic type of the select to that Java type.
	  </p>
	  
	  <p>The type may also be specified by using the actual UIMA type instance (useful if not using the 
	  JCas), using a fully qualified type name as a string, or using the JCas class static <code class="code">type</code> field.</p>
  </div>
  
  <div class="section" title="4.2.2.&nbsp;Sources and generic typing"><div class="titlepage"><div><div><h3 class="title" id="uv3.select.sources.generics">4.2.2.&nbsp;Sources and generic typing</h3></div></div></div>
    
    <p>The select method results in a generically typed object, which is used to have subsequent operations
    make use of the generic type, which may reduce the need for casting.</p>
    
    <p>The generic type can come from arguments or from where a value is being assigned, 
    if that target has a generic type.  This latter source is only partially available in Java, as it does not
    propagate past the first object in a chain of calls; this becomes a problem when using <code class="code">select</code> with
    generically typed index variables.
    </p>
    
    <p>There is also a static version of the <code class="code">select</code> method which takes a 
    generically typed index as an argument.</p>
    <div class="informalexample">    
    <pre class="programlisting">// this works
// the generic type for Token is passed as an argument to select
FSIterator&lt;Token&gt; token_it = cas.select(Token.class).fsIterator();

FSIndex&lt;Token&gt; token_index = ... ; // generically typed

// this next fails because the
// Token generic type from the index variable being assigned
// doesn't get passed to the select().
FSIterator&lt;Token&gt; token_iterator = token_index.select().fsIterator();

// You can overcome this in two ways:
// pass in the type as an argument to select
// using the JCas cover type.  
FSIterator&lt;Token&gt; token_iterator = 
    token_index.select(Token.class).fsIterator();

// You can also use the static form of select
// to avoid repeating the type information
FSIterator&lt;Token&gt; token_iterator = 
    SelectFSs.select(token_index).fsIterator();

// Finally, you can also explicitly set the generic type 
// that select() should use, like a special kind of type cast, like this:
FSIterator&lt;Token&gt; token_iterator =
    token_index.&lt;Token&gt;select().fsIterator();
</pre>
</div>
        
    <p>Note: the static <code class="code">select</code> method may be statically imported into code that uses it, to avoid repeatedly 
    qualifying this with its class, <code class="code">SelectFSs</code>.</p>
    
  <p>Any specification of an index may be further restricted to just a subType (including that
  subtype's subtypes, if any) of that index's type.
  For example, an AnnotationIndex may be specialized to just Sentences (and their subtypes):
  </p><pre class="programlisting">FSIterator&lt;Token&gt; token_iterator = 
    annotation_index.select(Token.class).fsIterator();
</pre><p>
  </p>  
  </div>

  </div>  

  <div class="section" title="4.3.&nbsp;Selection and Ordering"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="uv3.select.selection_and_ordering">4.3.&nbsp;Selection and Ordering</h2></div></div></div>
    
    
    <p>There are four sets of sub-selection and ordering specifications, grouped 
    by what they apply to:
	    </p><div class="itemizedlist"><ul class="itemizedlist" type="disc" compact><li class="listitem">
		      <p>all sources 
		      </p>
		    </li><li class="listitem">
		      <p>Indexes or FSArrays or FSLists
		      </p>
		    </li><li class="listitem">
		      <p>Ordered Indexes
		      </p>
		    </li><li class="listitem">
		      <p>The Annotation Index
		      </p>
		    </li></ul></div><p>  
    </p>
    
    <p>With some exceptions, configuration items to the left also apply to items on the right.
    </p>

    <p>When the same configuration item is specified multiple times, 
          the last one specified is the one that is used.</p>

    <div class="figure"><a name="uv3.select.fig.selection_and_ordering"></a><div class="figure-contents">
      
      <div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="545"><tr><td><img src="images/version_3_users_guide/select/select_selection_and_ordering.png" width="545" alt="Selection and Ordering configuration"></td></tr></table></div>
    </div><p class="title"><b>Figure&nbsp;4.3.&nbsp;Selection and Ordering</b></p></div><br class="figure-break">
        
    <div class="section" title="4.3.1.&nbsp;Boolean properties"><div class="titlepage"><div><div><h3 class="title" id="uv3.select.boolean_properties">4.3.1.&nbsp;Boolean properties</h3></div></div></div>
      
	    <p>Many configuration items specify a boolean property.  These are named so the default (if you don't specify them)
	    is generally what is desired, and the specification of the method with null parameter switches the property to the 
	    other (non-default) value.</p>
	    
	    <p>For example, normally, when working with bounded limits within Annotation Indexes, type
	    priorities are ignored when computing the bound positions.  
	    Specifying typePriority() says to use type priorities.</p>
	    
	    <p>Additionally, the boolean configuration methods have an optional form where they take a boolean value; 
	    true sets the property.  
	    So, for example typePriority(true) is equivalent to typePriority(), and typePriority(false)
	    is equivalent to omitting this configuration.</p>
    </div>
        
    <div class="section" title="4.3.2.&nbsp;Configuration for any source"><div class="titlepage"><div><div><h3 class="title" id="uv3.select.any_source">4.3.2.&nbsp;Configuration for any source</h3></div></div></div>
      
      
      <div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>limit</strong></span></span></dt><dd>
            <p>a limit to the number of Feature Structures that will be produced or iterated over.
            </p>
          </dd><dt><span class="term"><span class="strong"><strong>nullOk</strong></span></span></dt><dd>
            <p>changes the behavior for some terminal_form actions, which would otherwise
      throw an exception if a null result happened.
            </p>
          </dd></dl></div>
      
    </div>
    
    <div class="section" title="4.3.3.&nbsp;Configuration for any index"><div class="titlepage"><div><div><h3 class="title" id="uv3.select.any_index">4.3.3.&nbsp;Configuration for any index</h3></div></div></div>
      
    
      <div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>allViews</strong></span></span></dt><dd>
            <p>Normally, only Feature Structures belonging to the particular CAS view are included in the selection. 
			      If you want, instead, to include Feature Structures from all views, you can specify
			      <code class="code">allViews()</code>.
			      </p>
			      
			      <p>When this is specified, it acts 
				          as an aggregation of the underlying selections, one per view in the CAS.
				          The ordering among the views is arbitrary; the ordering within each view
				          is the same as if this setting wasn't in force.
				          Because of this implementation, the items in the selection may not be unique -- 
				          Feature Structures in the underlying selections that are in multiple views will appear multiple times.
            </p>
          </dd></dl></div>

    </div>
    
    <div class="section" title="4.3.4.&nbsp;Configuration for sort-ordered indexes"><div class="titlepage"><div><div><h3 class="title" id="uv3.select.ordered_index">4.3.4.&nbsp;Configuration for sort-ordered indexes</h3></div></div></div>
      

      <p>When an index is sort-ordered, there are additional capabilities that can be configured, in particular positioning
        to particular Feature Structures, and running various iterations backwards.
      </p>

      <div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>orderNotNeeded</strong></span></span></dt><dd>
            <p>relaxes any iteration by allowing it to proceed in an unordered manner.  Specifying
				      this may improve performance in some cases.  When this is specified, 
				      the current implementation skips the work of keeping multiple
				      iterators for a type and all of its subtypes in the proper synchronization.
            </p>
          </dd><dt><span class="term"><span class="emphasis"></span>startAt</span></dt><dd>
            <p>position the starting point of any iteration.  
			        <code class="code">startAt(xxx)</code> takes two forms, each of which has, in turn 2 subforms.  
			        The form using <code class="code">begin, end</code> is only valid for Annotation Indexes.
			        </p><pre class="programlisting">startAt(fs);          // fs specifies a feature structure 
                      // indicating the starting position
             
startAt(fs, shifted); // same as above, but after positioning, 
                      // shift to the right or left by the shift 
                      // amount which can be positive or negative
             

// the next two forms are only valid for AnnotationIndex sources
   
startAt(begin, end);  // start at the position indicated by begin/end

startAt(begin, end, shifted) // same as above, 
                             // but with a subsequent shift.
                             // which can be positive or negative
</pre><p>
            </p>
          </dd><dt><span class="term"><span class="strong"><strong>backwards</strong></span></span></dt><dd>
            <p>specifies a backwards order (from last to first position) for
            subsequent operations
            </p>
          </dd></dl></div>
    </div>
  
    <div class="section" title="4.3.5.&nbsp;Bounded sub-selection within an Annotation Index"><div class="titlepage"><div><div><h3 class="title" id="uv3.select.annot.subselect">4.3.5.&nbsp;Bounded sub-selection within an Annotation Index</h3></div></div></div>
      
      
      <p>When selecting Annotations, frequently you may want to select only those which have
      a relation to a bounding Annotation.  A commonly done selection is to select all Annotations 
      (of a particular type including its subtypes) within the span of another bounding Annotation, 
      for example, all <code class="code">Tokens</code>
      within a <code class="code">Sentence</code>.</p>
      
      <p>There are four varieties of sub-selection within an annotation index.  They all are based on a 
      bounding Annotation (except the <code class="code">between</code> which is based on two bounding Annotations).
      </p>
      
      <p>The bounding Annotations are specified using either a Annotation (or a subtype), or
      by specifying the begin and end offsets that would be for the bounding Annotation.</p>
      
      <p>Leaving aside <code class="code">between</code> as a special case, the bounding Annotation's 
      <code class="code">begin</code> and <code class="code">end</code>
      (and sometimes, its <code class="code">type</code>) is used to specify where an iteration would start, where it would end, 
      and possibly, which Annotations within those bounds would be filtered out.  There are many variations
      possible; these are described in the next section.</p>
      
      <p>The returned Annotations exclude the one(s) which are <code class="code">equal</code> to the bounding FS.  
      There are several 
      variations of how this <code class="code">equal</code> test is done, discussed in the next section.</p>
            
      <div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>coveredBy</strong></span></span></dt><dd>
            <p>iterates over Annotations within the bound
            </p>
          </dd><dt><span class="term"><span class="strong"><strong>covering</strong></span></span></dt><dd>
            <p>iterates over Annotations that span the bound.
            </p>
          </dd><dt><span class="term"><span class="strong"><strong>at</strong></span></span></dt><dd>
            <p>iterates over Annotations that have the same span (i.e., begin and end) as the bound.
            </p>
          </dd><dt><span class="term"><span class="strong"><strong>between</strong></span></span></dt><dd>
            <p>uses two Annotations, and returns Annotations that are in between
				      the two bounds.  If the bounds are backwards, then they are automatically used in reverse order.
				      The meaning of between is that an included Annotation's begin has to be &gt;= the earlier bound's <code class="code">end</code>, 
				      and the Annotation's end has to be &lt;= the later bound's <code class="code">begin</code>.
            </p>
          </dd></dl></div>
    </div>
    
    <div class="section" title="4.3.6.&nbsp;Variations in Bounded sub-selection within an Annotation Index"><div class="titlepage"><div><div><h3 class="title" id="uv3.select.annot.variations">4.3.6.&nbsp;Variations in Bounded sub-selection within an Annotation Index</h3></div></div></div>
      
      
      <p>There are five variations you can specify.  
      Two affect how the starting bound position is set; 
      the other three affect skipping of some Annotations while iterating.
      The defaults (summarized following) are designed to fit the popular use cases.</p>
      
      <div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>typePriority</strong></span></span></dt><dd>
            <p>The default is to ignore type priorities when setting the starting position, and just use
            the begin / end position to locate the left-most equal spot.  If you want to respect type priorities,
            specify this variant.
            </p>
          </dd><dt><span class="term"><span class="strong"><strong>nonOverlapping</strong></span></span></dt><dd>
            <p>Normally, all Annotations satisfying the bounds are returned.  If this is set, 
            annotations whose <code class="code">begin</code> position is not &gt;= the previous annotation's (going forwards)
            <code class="code">end</code> position are skipped.  This is also called <span class="emphasis"><em>unambiguous</em></span> iteration.
            If the iterator is run backwards, it is first run forwards to locate all the items that would be in the
            forward iteration following the rules; and then those are traversed backwards.
            This variant is ignored for <code class="code">covering</code> selection.
            </p>
          </dd><dt><span class="term"><span class="strong"><strong>includeAnnotationsWithEndBeyondBounds</strong></span></span></dt><dd>
            <p>The Subiterator <span class="emphasis"><em>strict</em></span> configuration is equivalent to the opposite of this.
            This only applied to the <code class="code">coveredBy</code> selection; 
            if specified, then any Annotations whose
            <code class="code">end</code> position is &gt; the end position of the bounding Annotation are included;
            normally they are skipped.
            </p>
          </dd><dt><span class="term"><span class="strong"><strong>skipSameBeginEndType</strong></span></span></dt><dd>
            <p>While doing bounded iteration, if the Annotation being returned is identical (has the same
            _id()) with the bounding Annotation, it is always skipped. But other annotations, which might 
            have the same begin, end, and type values, are included by default.</p>
            
            <p>  
            When this configuration is specified, any Annotation which has the same begin, end, and type is also skipped.  
            </p>
          </dd></dl></div>
    </div>
 
       <div class="section" title="4.3.7.&nbsp;Defaults for bounded selects"><div class="titlepage"><div><div><h3 class="title" id="uv3.select.annot.subselect.defaults">4.3.7.&nbsp;Defaults for bounded selects</h3></div></div></div>
        
        <p>The ordinary core UIMA Subiterator implementation defaults to using type order as part of the bounds
        determination.  uimaFIT, in contrast, doesn't use type order, and sets bounds according to 
        the begin and end positions.</p>
        
        <p>This <code class="code">select</code> implementation mostly follows the uimaFIT approach by default, but provides
        the above configuration settings to flexibly alter this to the user's preferences.
        For reference, here are the default settings, with some comparisons to the defaults for <code class="code">Subiterators</code>:</p>
        
        <div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>typePriority</strong></span></span></dt><dd>
              <p>default: false; type priorities are not used when moving to left-most among equal items.
              Subiterators created using the AnnotationIndex, in contrast, use type priorities.
              </p>
            </dd><dt><span class="term"><span class="strong"><strong>nonOverlapping</strong></span></span></dt><dd>
              <p>default: false; no Annotations are skipped because they overlap.
              This corresponds to the "ambiguous" mode in Subiterators.
              </p>
            </dd><dt><span class="term"><span class="strong"><strong>includeAnnotationsWithEndBeyondBounds</strong></span></span></dt><dd>
              <p>default: (only applies to <code class="code">coveredBy</code> selections; 
              The default is to skip Annotations whose end position lies outside of the bounds; 
              this corresponds to Subiterator's "strict" option.
              </p>
            </dd><dt><span class="term"><span class="strong"><strong>skipSameBeginEndType</strong></span></span></dt><dd>
              <p>default: only the single Annotation with the same _id() is skipped when using 
                a bounded iteration.
                Use this setting to expand the set of skipped Annotations to include all those equal to the 
                bound's begin, end and type.   
              </p>
            </dd></dl></div>
          
      </div>
    
    <div class="section" title="4.3.8.&nbsp;Following or Preceding"><div class="titlepage"><div><div><h3 class="title" id="uv3.select.annot.follow_precede">4.3.8.&nbsp;Following or Preceding</h3></div></div></div>
      
      
      <p>For an Annotation Index, you can specify all Feature Structures following or preceding a position.
      The position can be specified either as a Feature Structure, or 
      by using begin and end values.
      The arguments are identical to those of the <code class="code">startAt</code> specification, but are interpreted 
      differently.    
      </p>
            
      <div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>following</strong></span></span></dt><dd>
            <p>Position the iterator according to the argument, get that Annotation's <code class="code">end</code>
            value, and then move the iterator forwards until
            the Annotation at that position has its begin value &gt;= to the saved end value.
            </p>
          </dd><dt><span class="term"><span class="strong"><strong>preceding</strong></span></span></dt><dd>
            <p>Position the iterator according to the argument, save that Annotation's <code class="code">begin</code> value,
            and then move it backwards until
            the Annotation's (at that position) <code class="code">end</code> value is &lt;= to the saved <code class="code">begin</code>value.
            </p>
          </dd></dl></div>
      
      <p>The <code class="code">preceding</code> iteration skips annotations whose <code class="code">end</code> values are &gt; the saved <code class="code">begin</code>.</p>
    </div>  
  </div>
  
  <div class="section" title="4.4.&nbsp;Terminal Form actions"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="uv3.select.terminal_form_actions">4.4.&nbsp;Terminal Form actions</h2></div></div></div>
    
    
    <p>After the sources and selection and ordering options have been specified, one 
    terminal form action may be specified.  This can be an getting an iterator, array or list,
    or a single value with various extra checks, or a Java stream.  Specifying any stream operation
    (except limit) converts the object to a stream; from that point on, any stream operation may be used.</p>
    
    <div class="figure"><a name="uv3.select.fig.terminal_form_actions"></a><div class="figure-contents">
      
      <div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="545"><tr><td><img src="images/version_3_users_guide/select/select_terminal_form_actions.png" width="545" alt="Terminal form actions for select"></td></tr></table></div>
    </div><p class="title"><b>Figure&nbsp;4.4.&nbsp;Select Terminal Form Actions</b></p></div><br class="figure-break">
    
    <div class="section" title="4.4.1.&nbsp;Iterators"><div class="titlepage"><div><div><h3 class="title" id="uv3.select.terminal_form_actions.iterators">4.4.1.&nbsp;Iterators</h3></div></div></div>
      
      
      <div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>(Iterable)</strong></span></span></dt><dd>
            <p>The <code class="code">SelectFSs</code> object directly implements <code class="code">Iterable</code>, so it may be 
            used in the extended Java <code class="code">for</code> loop.</p>
          </dd><dt><span class="term"><span class="strong"><strong>fsIterator</strong></span></span></dt><dd>
            <p>returns a configured fsIterator or subIterator.  
            This iterator implements <code class="code">ListIterator</code> as well (which, in turn,
            implements Java <code class="code">Iterator</code>).
            Modifications to the list using <code class="code">add</code> or <code class="code">set</code> are not supported.
            </p>
          </dd><dt><span class="term"><span class="strong"><strong>iterator</strong></span></span></dt><dd>
            <p>This is just the plain Java iterator, for convenience.
            </p>
          </dd><dt><span class="term"><span class="strong"><strong>spliterator</strong></span></span></dt><dd>
            <p>This returns a spliterator, which can be marginally more efficient to use than a normal iterator.
            It is configured to be sequential (not parallel), and has other characteristics set according to 
            the sources and selection/ordering configuration.
            </p>
          </dd></dl></div>
 
    </div>
    <div class="section" title="4.4.2.&nbsp;Arrays and Lists"><div class="titlepage"><div><div><h3 class="title" id="uv3.select.terminal_form_actions.arrays_lists">4.4.2.&nbsp;Arrays and Lists</h3></div></div></div>
      
      <div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>asArray</strong></span></span></dt><dd>
            <p>This takes 1 argument, the class of the returned array type, which must be the type or subtype of the
            select.
            </p>
          </dd><dt><span class="term"><span class="strong"><strong>asList</strong></span></span></dt><dd>
            <p>Returns a Java list, configured from the sources and selection and ordering specifications. 
            </p>
          </dd></dl></div>
    </div>
    <div class="section" title="4.4.3.&nbsp;Single Items"><div class="titlepage"><div><div><h3 class="title" id="uv3.select.terminal_form_actions.single_items">4.4.3.&nbsp;Single Items</h3></div></div></div>
      
      <p>These methods return just a single item, according to the previously specified select configuration.
      Variations may throw exceptions on empty or more than one item situations.</p>
      
      <p>These have no-argument forms as well as argument forms identical to <code class="code">startAt</code> (see above).
      When arguments are specified, they adjust the item returned by positioning within the index 
      according to the arguments.</p>
        
      <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
        <p>Positioning arguments with a Annotation or begin and end require an Annotation Index.
        Positioning using a Feature Structure, by contrast, only require that the index being use be sorted.
        </p>
      </div>
      
      <div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>get</strong></span></span></dt><dd>
            <p>If no argument is specified, then returns the first item, or null.  If nullOk(false) is configured, 
            then if the result is null, an exception will be thrown.
            </p>
            <p>If any positioning arguments are specified, then this returns the item at that position unless 
            there is no item at that position, in which case it throws an exception unless <code class="code">nullOk</code> is set.
            </p>
          </dd><dt><span class="term"><span class="strong"><strong>single</strong></span></span></dt><dd>
            <p>returns the item at the position, but throws exceptions 
            if there are more than one item in the selection,
            or if there are no items in the selection.
            </p>
          </dd><dt><span class="term"><span class="strong"><strong>singleOrNull</strong></span></span></dt><dd>
            <p>returns the item at the position, but throws an exception 
            if there are more than one item in the selection.
            </p>
          </dd></dl></div>
    </div>
    <div class="section" title="4.4.4.&nbsp;Streams"><div class="titlepage"><div><div><h3 class="title" id="uv3.select.terminal_form_actions.streams">4.4.4.&nbsp;Streams</h3></div></div></div>
      
      <div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>any stream method</strong></span></span></dt><dd>
            <p>Select supports all the stream methods.  The first occurance of a stream method converts the select
            into a stream, using <code class="code">spliterator</code>, and from then on, it behaves just like a stream object.
            </p>
            
            <p>For example, here's a somewhat contrived example:  
            you could do the following to collect the set of types appearing
            within some bounding annotation, when considered in nonOverlapping style:
            
    </p><div class="informalexample">  
<pre class="programlisting">Set&lt;Type&gt; foundTypes =
    // items of MyType or subtypes 
   myIndex.select(MyType.class)
   .coveredBy(myBoundingAnnotation)
   .nonOverlapping()
   .map(fs -&gt; fs.getType())
   .collect(Collectors.toCollection(TreeSet::new));
</pre>
</div><p>
Or, to collect by category a set of frequency values:
</p><div class="informalexample">  
<pre class="programlisting">Map&lt;Category, Integer&gt; freqByCategory =
   myIndex.select(MyType.class)
   .collect(Collectors
     .groupingBy(MyType::getCategory,
                 Collectors.summingInt(MyType::getFreq)));
</pre> 
</div><p>
            </p>
          </dd></dl></div>
    </div>
  </div>
    
  </div>
  <div class="chapter" title="Chapter&nbsp;5.&nbsp;Defining CAS-transported custom Java objects" id="uv3.custom_java_objects"><div class="titlepage"><div><div><h2 class="title">Chapter&nbsp;5.&nbsp;Defining CAS-transported custom Java objects</h2></div></div></div>
  
  
  
  <p>One of the goals of v3 is to support more of the Java collection framework within the CAS,
  to enable users to conveniently build more complex models that could be transported by the CAS.
  For example, a user might want to store a Java "Set" object, representing a set of Feature Structures.
  Or a user might want to use an adjustable array, like Java's ArrayList.
  </p>
  
  <p>With the current version 2 implementation of JCas, users already may add arbitrary Java objects to their
  JCas class definitions as fields, but these do not get transported with the CAS (for instance, during 
  serialization).  Furthermore, in version 2, the actual JCas instance you get when accessing a Feature Structure
  in some edge cases may be a fresh instance, losing any previously computed value held as a Java field. 
  In contrast, each Feature Structure in a CAS is represented as the same unique Java Object 
  (because that's the only way a Feature Structure is stored).
  </p>
  
  <p>Version 3 has a new a capability that enables converting arbitrary Java objects 
  that might be part of a 
  JCas class definition, into "ordinary" CAS values that can be transported with the CAS. 
  This is done using a set of conventions which the framework follows, and which developers writing these
  classes make use of; they include
  two kinds of marker Java interfaces, and 2 methods that are called when serializing and deserializing.
  </p><div class="blockquote"><blockquote class="blockquote"><p>
	  The marker interfaces identify those JCas classes which need these extra methods called.  The extra methods are 
	  methods implemented by the creator of these JCas classes, which marshal/unmarshal CAS feature data to/from the 
	  Java Object this class is supporting.
  </p></blockquote></div><p>
  </p>

  <p>
  Storing the Java Object data as the value of a normal CAS Feature means that they get "transported" in a portable
  way with the CAS - they can be saved to external storage and read back in later, or sent to remote services, etc.
  </p>
  
  <div class="section" title="5.1.&nbsp;Tutorial example"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="uv3.custom_java_objects.tutorial">5.1.&nbsp;Tutorial example</h2></div></div></div>
    
    <p>Here's a tutorial example on how to design and implement your own special Java object.  For this example,
    we'll imagine we need to implement a map from FeatureStructures to FeatureStructures.</p>
    
    <div class="figure"><a name="uv3.custom_java_objects.5_steps"></a><div class="figure-contents">
      
      <div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="545"><tr><td><img src="images/version_3_users_guide/custom_java_objects/5_steps.png" width="545" alt="5 steps to creating a custom CAS transportable Java Object"></td></tr></table></div>
    </div><p class="title"><b>Figure&nbsp;5.1.&nbsp;Creating a custom Java CAS-stored Object</b></p></div><br class="figure-break">

    <p>      
    Step 1 is deciding on the Java Object implementation to use.  We can define a special class, but in this case,
    we'll just use the ordinary Java HashMap&lt;TOP, TOP&gt; for this.</p>
    
    <p>Step 2 is deciding on the CAS Feature Structure representation of this.  For this example, let's design this
    to represent the serialized form of the hashmap as 2 FSArrays, one for the keys, and one for the values.
    We could also use just one array and intermingle the keys and values. It's up to the designer of this new JCas
    class to decide how to do this.</p>
    
    <p>Step 3 is defining the UIMA Type for this.  Let's call it FS2FSmap.  It will have 2 Features: an FSArray
    for the keys, and another FSArray for the values.  Let's name those features "keys" and "values".
    Notice that there's no mention of the Java object in the UIMA Type definition.
    </p>
    
    <p>Step 4 is to run JCasGen on this class to get an initial version of the class.  Of course, it will be missing
    the Java HashMap, but we'll add that in the next step.</p>
    
    <div class="variablelist"><dl><dt><span class="term">Step 5: modify 3 aspects of the generated JCas class.</span></dt><dd>
        <p>
    </p><div class="variablelist"><dl><dt><span class="term">1. Mark the class with one of two interfaces:</span></dt><dd>
            <div class="itemizedlist"><ul class="itemizedlist" type="disc" compact><li class="listitem"><p><code class="code">UimaSerializable</code></p></li><li class="listitem"><p><code class="code">UimaSerializableFSs</code></p></li></ul></div>
            <p>These identify this JCas class a needing the calls to marshal/unmarshal the data to/from the
            Java Object and the normal CAS data features.  Use the second form if the data includes any
            Feature Structure references.  In our example, the data does include Feature Structure references, 
            so we add <code class="code">implements UimaSerializableFSs</code> to our JCas class.</p>
          </dd><dt><span class="term">2. Add the Java Object as a field to the class</span></dt><dd>
            
            <div class="variablelist"><dl><dt><span class="term"></span></dt><dd><p></p></dd></dl></div>
            <p>We'll define a new field:
    </p><pre class="programlisting">final private Map&lt;TOP, TOP&gt; fs2fsMap = new HashMap&lt;&gt;();</pre>
          </dd><dt><span class="term">3. Implement two methods to marshal/unmarshal the Java Object data to the CAS Data Features</span></dt><dd>
            
            <div class="variablelist"><dl><dt><span class="term"></span></dt><dd><p></p></dd></dl></div>
            <p>Now, we need to add the code that translates between the two UIMA Features 
                  "keys" and "values" and the map, and vice-versa.  We put this code into two methods, 
                  called <code class="code">_init_from_cas_data</code> and <code class="code">_save_to_cas_data</code>. 
                  These are special methods that are part of this new framework extension; 
                  they are called by the framework at critical times during deserialization and serialization.  
                  Their purpose is to encapsulate all that is needed to convert from transportable 
                  normal CAS data, and the Java Object(s).</p>
    
            <p>In this example, the <code class="code">_init_from_cas_data</code> method would iterate over the two Features,
                  together, and add each key value pair to the Java Object.  Likewise, the 
                  <code class="code">_save_to_cas_data</code> would first create two FSArray objects for the keys and values, 
                  and then iterate over the hash map and extract these and set them into the key and value arrays.
                  </p><pre class="programlisting">public void _init_from_cas_data() {
  FSArray keys = getKeys();
  FSArray values = getValues();
  fs2fsMap.clear();
  for (int i = keys.size() - 1; i &gt;=0; i--) {
    fs2fsMap.put(keys.get(i), values.get(i)); 
  }
}

public void _save_to_cas_data() {
  int i = 0;
  FSArray keys = new FSArray(this, fs2fsMap.size());
  FSArray values = new FSArray(this, fs2fsMap.size());
  for (Entry&lt;TOP, TOP&gt; entry : fs2fsMap.entrySet()) {
    keys.set(i, entry.getKey());
    values.set(i, entry.getValues());
    i++;
  }
  setKeys(keys); 
  setValues(values);
}    
</pre><p>
            </p>
            
            <p>Beyond this simple implementation, various optimization can be done.
            One typical one is to treat the use case where no updates were done as a special
            case (but one which might occur frequently), and in that case having the
            _save_to_cas_data operation do nothing, since the original CAS data is still valid.</p>
            
            <p>One additional "boilerplate" method is required for all of these classes:</p>            
            <p><code class="code">  public FeatureStructureImplC _superClone() {return clone();}</code></p>
          </dd></dl></div><p>

        </p>
      </dd></dl></div>
  
    
    <p>For custom types which hold collections of Feature Structures, you can have those participate in the 
       <code class="code">Select</code> framework, by implementing the optional Interface <code class="code">SelectViaCopyToArray</code>.</p>
       
    <p>For more examples, please see the implementations of the semi-built-in classes described in the
    following section.</p>
  </div>
  
  <div class="section" title="5.2.&nbsp;Additional semi-built-in UIMA Types for some common Java Objects"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="uv3.custom_java_objects.new_semibuiltins">5.2.&nbsp;Additional semi-built-in UIMA Types for some common Java Objects</h2></div></div></div>
	  
	  
	  
	  <p>Some additional semi-built-in UIMA types are defined in Version 3 using this new mechanism.  They work fully in
	  Java, and are serialized or transported to non-Java frameworks as ordinary CAS objects.</p>
	  
    <p>Semi-built-in means that the JCas cover classes for these are defined as part of the core Java classes,
      but the types themselves are not "built-in".  They may be added to any tyupe system by importing them by name using the import statement:
      </p><pre class="programlisting">&lt;import name="org.apache.uima.semibuiltins"/&gt;</pre><p>
      If you have a Java project whose classpath includes uimaj-core, and you run the Component Descriptor Editor
      Eclipse plugin tool on a descriptor which includes a type system, you can configure this import by selecting
      the Add on the Import type system subpanel, and import by name, and selecting org.apache.uima.semibuiltins.
      (Note: this will not show up if your project doesn't include uimaj-core on its build path.)
    </p>
    
	  <div class="section" title="5.2.1.&nbsp;FSArrayList"><div class="titlepage"><div><div><h3 class="title" id="uv3.custom_java_objects.semibuiltin_fsarraylist">5.2.1.&nbsp;FSArrayList</h3></div></div></div>
	    
	    
	    
	    <p>This is like the current FSArray, except that it implements the List API and supports 
	    adding to the array, with automatic resizing, like an ArrayList in Java.  It is implemented internally
	    using a Java ArrayList.</p>
	    
	    <p>The CAS data form is held in a plain FSArray feature.</p>
	    
	    <p>The <code class="code">equals()</code> method is true if both FSArrayList objects have the same size, and
	    contents are <code class="code">equal</code> item by item.  
	    The list of supported operations includes all of the operations of 
	    the Java <code class="code">List</code> interface.  This object also includes the <code class="code">select</code> methods, so it
	    can be used as a source for the <code class="code">select</code> framework.</p> 
	  </div>
	  
	  <div class="section" title="5.2.2.&nbsp;IntegerArrayList"><div class="titlepage"><div><div><h3 class="title" id="uv3.custom_java_objects.semibuiltin_integerarraylists">5.2.2.&nbsp;IntegerArrayList</h3></div></div></div>
      
      
      
      <p>This is like the current IntegerArray, except that it implements the List API and supports 
      adding to the array, with automatic resizing, like an ArrayList in Java.</p>
      
      <p>The CAS data form is held in a plain IntegerArray feature.</p>
      
      <p>The <code class="code">equals()</code> method is true if both IntegerArrayList objects have 
      the same size, and
      contents are <code class="code">equal</code> item by item.  
      The list of supported operations includes a subset of the operations of 
      the Java <code class="code">List</code> interface, where certain values are changed to Java primitive
      <code class="code">ints</code>.  To support the <code class="code">Iterable</code> interface, there is 
      a version of <code class="code">iterator()</code> where the result is "boxed" into an
      Integer.  For efficiency, there's also a method intListIterator, which returns
      an instance of IntListIterator, which permits iterating forwards and backwards, without
      boxing.</p> 
       
    </div>
    
    <div class="section" title="5.2.3.&nbsp;FSHashSet"><div class="titlepage"><div><div><h3 class="title" id="uv3.custom_java_objects.semibuiltin_FSHashSet">5.2.3.&nbsp;FSHashSet</h3></div></div></div>
      
      
      
      <p>This type stores Feature Structures in a HashSet, using whatever is defined
      as the Feature Structure's <code class="code">equals</code> and <code class="code">hashcode</code>.
      
      </p><div class="blockquote"><blockquote class="blockquote">
	      <p>You may customize the particular equals and hashcode by creating a wrapper class that
	      is a subclass of the type of interest which forwards to the underlying Feature Structure, but
	      has its own definition of <code class="code">equals</code> and <code class="code">hashcode</code>. 
	      </p>
      </blockquote></div><p>
      </p>
            
      <p>The CAS data form is held in an FSArray consisting of the members of the set.</p>
            
    </div>
    
  </div>
  
  <div class="section" title="5.3.&nbsp;Design for reuse"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="uv3.custom_java_objects.design">5.3.&nbsp;Design for reuse</h2></div></div></div>
      
      
      <p>While it is possible to have a single custom JCas class implement multiple Java Objects, this is 
        typically not a good design practice, as it reduces reusability.  It is usually better to 
        implement one custom Java object per JCas class, with an associated UIMA type, and have that as
        the reusable entity.
      </p>
  </div>

</div> 
  <div class="chapter" title="Chapter&nbsp;6.&nbsp;Logging" id="uv3.logging"><div class="titlepage"><div><div><h2 class="title">Chapter&nbsp;6.&nbsp;Logging</h2></div></div></div>
  
    
    <p>Logging has evolved; two major changes now supported by V3 are
      </p><div class="itemizedlist"><ul class="itemizedlist" type="disc" compact><li class="listitem">
          <p>using a popular open-source standard logging facade, SLF4j, 
                that can at run time discover and hook to 
                a user specified logging framework.</p>
        </li><li class="listitem">
          <p>Support for both old-style and new style substitutable parameter specification.</p>
        </li></ul></div><p>
    </p>
    
    <p>For backwards compatibilit, V3 retains the existing V2 logging facade, so
      existing code will continue to work.
      The APIs have been augmented by the methods available in the SLF4j <code class="code">Logger</code> API,
      plus the Java 8 enabled APIs from the Log4j implementation that support the 
      <code class="code">Supplier</code> Functional Interface.
    </p>
    
    <p>The old APIs support messages using the standard Java Util Logging style of writing substitutable
      parameters using an integer, e.g., {0}, {1}, etc.  The new APIs support messages using the
      modern substitutable parameters without an integer, e.g. {}.</p>
    
    <p>The implementation of this facade in V2 was the built-in-to-Java (java.util) logging framework.
    For V3, this is changed to be the SLF4j facade.  This is an open source, standard facade
    which allows deferring until deployment time, the specific logging back end to use.
    </p>
    
    <p>If, at initialization time, SLF4J gets configured to use a back end which is either the 
    built-in Java logger, or Log4j-2, then the UIMA logger implementation is switched to
    UIMA's implementation of those APIs (bypassing SLF4j, for efficiency).</p>

    
    
    <p> 
      The SLF4j and other documentation (e.g.,  
      <a class="ulink" href="https://logging.apache.org/log4j/2.x/log4j-slf4j-impl/index.html" target="_top">https://logging.apache.org/log4j/2.x/log4j-slf4j-impl/index.html</a> for log4j-2) describe 
      how to connect various logging back ends to SLF4j, by 
      putting logging back-end implementations into the classpath at run time.  For example, 
      to use the back end logger built into Java,  you would
      include the <code class="code">slf4j-jdk14</code> Jar.  This Jar is included in the UIMA binary distribution, so that
      out-of-the-box, logging is available and configured the same as it was for V2.
    </p>
    
    <p>The Eclipse UIMA Runtime plugin bundle excludes the slf4j api Jar and back ends, but will 
      "hook up" the needed implementations from other bundles.   
    </p> 

  <div class="section" title="6.1.&nbsp;Logging Levels"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="uv3.logging.levels">6.1.&nbsp;Logging Levels</h2></div></div></div>
    
    
    <p>There are 2 logging level schemes, and there is a mapping between them.  Either of them may be used
      when using the UIMA logger.  One of the schemes is the original UIMA v2 level set, which is the same 
      as the built-in-to-java logger levels.  The other is the scheme adopted by SLF4J and many of its back ends.
    </p>
          
   <p>Log statements are "filtered" according to the logging configuration, by Level, and sometimes by
    additional indicators, such as Markers.  Levels work in a hierarchy.  A given level of 
    filtering passes that level and all higher levels.  Some levels have two names, due to the 
    way the different logger back-ends name things.  Most levels are also used as method names on 
    the logger, to indicate logging for that level.  
    For example, you could say <code class="code">aLogger.log(Level.INFO, message)</code>
    but you can also say <code class="code">aLogger.info(message)</code>). The level ordering, highest to lowest, 
    and the associated method names are as follows:
    </p><div class="itemizedlist"><ul class="itemizedlist" type="disc" compact><li class="listitem"><p>SEVERE or ERROR; error(...)</p></li><li class="listitem"><p>WARN or WARNING; warn(...)</p></li><li class="listitem"><p>INFO; info(...)</p></li><li class="listitem"><p>CONFIG; info(UIMA_MARKER_CONFIG, ...)</p></li><li class="listitem"><p>FINE or DEBUG; debug(...)</p></li><li class="listitem"><p>FINER or TRACE; trace(...)</p></li><li class="listitem"><p>FINEST; trace(UIMA_MARKER_FINEST, ...)</p></li></ul></div><p>
    </p>
    
    <p>The CONFIG and FINEST levels are merged with other levels, but distinguished by having 
    <code class="code">Markers</code>.  If the filtering is configured to pass CONFIG level, then it will pass 
    the higher levels (i.e., the INFO/WARN/ERROR or their alternative names WARNING/SEVERE) levels as well.
    </p>
      
  </div>  
  <div class="section" title="6.2.&nbsp;Context Data"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="uv3.logging.new_recorded_context_data">6.2.&nbsp;Context Data</h2></div></div></div>
    
      
    <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p><span class="bold"><strong>Not (yet) implemented; for planning purposes only.</strong></span></p></div>
    
    <p>
      Context data is kept in SLF4j MDC and/or NDC maps; there is a separate map per thread.  
      Some of this information is always updated, other is only recorded if the
      logger for the class has a level set to Tracing.  
      The following table lists the keys and the values recorded in the
      contexts; these can be retrieved by the logging layouts and included in log messages.      
    </p>
    
    <p>Because the keys for context data are global, the ones UIMA uses internally are prefixed with "uima_".</p>   
    
    <div class="informaltable">
     <table style="border-collapse: collapse;border-top: 0.5pt solid black; border-bottom: 0.5pt solid black; border-left: 0.5pt solid black; border-right: 0.5pt solid black; "><colgroup><col class="key"><col class="description"></colgroup><tbody><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; "><span class="bold"><strong>Key Name</strong></span></td><td style="border-bottom: 0.5pt solid black; "><span class="bold"><strong>Description</strong></span></td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; "><p>uima_annotator</p></td><td style="border-bottom: 0.5pt solid black; "><p>the name of the annotator.</p></td></tr><tr><td style="border-right: 0.5pt solid black; "><p>uima_root_context</p></td><td style=""><p>The root context corresponds to the pipeline being run.  This could be be nested.</p></td></tr></tbody></table>
   </div>
    
  </div>

  <div class="section" title="6.3.&nbsp;Markers used in UIMA Java core logging"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="uv3.logging.markers">6.3.&nbsp;Markers used in UIMA Java core logging</h2></div></div></div>
    
    
    <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p><span class="bold"><strong>Not (yet) implemented; for planning purposes only.</strong></span></p></div>
      
    <p>
      Markers are used to group log calls associated with specific kinds of things together,
      so they can be enabled/disabled as a group.  The Marker can also be included in a trace record.
      The following table lists the keys and a description of which logging they are associated with.
    </p>

    <div class="informaltable">
     <table style="border-collapse: collapse;border-top: 0.5pt solid black; border-bottom: 0.5pt solid black; border-left: 0.5pt solid black; border-right: 0.5pt solid black; "><colgroup><col class="key"><col class="description"></colgroup><tbody><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; "><span class="bold"><strong>Marker Name</strong></span></td><td style="border-bottom: 0.5pt solid black; "><span class="bold"><strong>Description of logging</strong></span></td></tr><tr><td style="border-bottom: 0.5pt solid black; " colspan="2" align="center"><span class="bold"><strong>Markers used to classify CONFIG and FINEST </strong></span></td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; "><p>org.apache.uima.config</p></td><td style="border-bottom: 0.5pt solid black; "><p>configuration log record</p></td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; "><p>org.apache.uima.finest</p></td><td style="border-bottom: 0.5pt solid black; "><p>sub category of trace, corresponds to FINEST</p></td></tr><tr><td style="border-bottom: 0.5pt solid black; " colspan="2" align="center"><span class="bold"><strong>Markers used to classify some tracing logging</strong></span></td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; "><p>uima_annotator</p></td><td style="border-bottom: 0.5pt solid black; "><p>for tracing when annotators are entered, exited</p></td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; "><p>uima_flow_controller</p></td><td style="border-bottom: 0.5pt solid black; "><p>for tracing when flow controllers are computing</p></td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; "><p>uima_feature_structure</p></td><td style="border-bottom: 0.5pt solid black; "><p>for tracing Feature Structure Creation and updating</p></td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; "><p>uima_index</p></td><td style="border-bottom: 0.5pt solid black; "><p>for tracing when indexes are added to or removed from</p></td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; "><p>uima_index_copy_on_write</p></td><td style="border-bottom: 0.5pt solid black; "><p>for tracing when an index part is copied, due to it being updated while an iterator might be iterating.</p></td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; "><p>uima_index_auto_rmv_add</p></td><td style="border-bottom: 0.5pt solid black; "><p>for tracing when index corruption avoidance done</p></td></tr><tr><td style="border-right: 0.5pt solid black; "><p>uima_serialization_deserialization</p></td><td style=""><p>for tracing when serialization or deserialization is done</p></td></tr></tbody></table>
   </div>
        
  </div>
  
  <div class="section" title="6.4.&nbsp;Defaults and Configuration"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="uv3.logging.defaults_configuration">6.4.&nbsp;Defaults and Configuration</h2></div></div></div>
    
    
    <p>By default, UIMA is configured so that the UIMA logger is hooked up to the SLF4j facade, which
      may or may not have a logging back-end.  If it doesn't, then any use of the UIMA logger will produce 
      one warning message stating that SLF4j has no back-end logger configured, and so no logging will be done. 
    </p>
        
    <p>When UIMA is run as an embedded library in other applications, slf4j will use those other application's
      logging frameworks.</p>
      
    <p>Each logging back-end has its own way of being configured; 
      please consult the proper back-end documentation for details.</p>
    
    <p>For backwards compatibility, the binary distribution of UIMA includes the slf4j back-end 
      which hooks to the standard built-in Java logging framework, so out-of-the-box, UIMA should
      be configured and log by default as V2 did.</p>  
      
    <div class="section" title="6.4.1.&nbsp;Throttling logging from Annotators"><div class="titlepage"><div><div><h3 class="title" id="uv3.logging.throttling_annotator_logging">6.4.1.&nbsp;Throttling logging from Annotators</h3></div></div></div>
      
      
       <p>Sometimes, in production, you may find annotators are logging excessively, and you wish to throttle 
          this. But you may not have access to logging settings to control this,
          perhaps because UIMA is running as a library component within another framework. 
          For this special case,
          you can limit logging done by Annotators by passing an additional parameter to the UIMA Framework's 
          produceAnalysisEngine API, using the key name 
          <code class="code">AnalysisEngine.PARAM_THROTTLE_EXCESSIVE_ANNOTATOR_LOGGING</code>
          and setting the value to an Integer object equal to the the limit.  Using 0 will suppress all logging.
          Any positive number allows that many log records to be logged, per level.  A limit of 10 would allow 
          10 Errors, 10 Warnings, etc.  The limit is enforced separately, per logger instance.</p>
          
          <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>This only works if the logger used by Annotators is obtained from the 
          Annotator base implementation class via the <code class="code">getLogger()</code> method.</p></div>
          
    </div>  
  </div>  
</div> 
  <div class="chapter" title="Chapter&nbsp;7.&nbsp;Migrating to UIMA Version 3" id="uv3.migration"><div class="titlepage"><div><div><h2 class="title">Chapter&nbsp;7.&nbsp;Migrating to UIMA Version 3</h2></div></div></div>
  
  
  
  <div class="section" title="7.1.&nbsp;Migrating: the big picture"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="uv3.migration.big_picture">7.1.&nbsp;Migrating: the big picture</h2></div></div></div>
    
    
    <p>Although UIMA V3 is designed to be backwards compatible with UIMA V2, there are some migration steps
      needed.  These fall into two broad use cases: 
      </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>if you have an existing UIMA pipeline / application you wish to upgrade to use V3</p></li><li class="listitem"><p>if you are "consuming" the Maven artifacts for the core SDK, as part of another project</p></li></ul></div><p> 
    </p>
    
  </div>
  
  
  <div class="section" title="7.2.&nbsp;How to migrate an existing UIMA pipeline to V3"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="uv3.migration.migrating_pipeline">7.2.&nbsp;How to migrate an existing UIMA pipeline to V3</h2></div></div></div>
    
    
    
    <p>
      UIMA V3 is designed to be binary compatible with existing UIMA V2 pipelines, so compiled and/or JAR-ed up classes 
      representing a V2 pipeline should run with UIMA v3, with three changes:
      </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Java 8 is required. (If you're already using Java 8, nothing need be done.)</p></li><li class="listitem"><p>Any defined JCas cover classes must be migrated or regenerated, and used instead.
        (If you do not define any JCas classes or don't use JCas in your pipeline, then nothing need be done.)
        A quick way to do this is to create a Jar with the migrated JCas classes, and put it into the classpath
        ahead of the other JCas class definitions.</p></li><li class="listitem"><p>The runtime classpath needs to include the slf4j-api Jar, and an appropriate slf4j bridging Jar,
          for details, see next.
          </p></li></ul></div><p>
    </p>
    
    <p>Some adjustments may need to be made to logging setup, typically by including additional Jars 
      (provided in the UIMA Binary distribution) in your 
      application's classpath.  If you are using the standard UIMA Launch scripts, this is already done.
      For custom application setups, insure that the classpath includes the (now) required jar 
      "slf4j-api-xxxx.jar" (replace xxxx with the version).  
      If you were using the standard UIMA based logging,
      to get the similar behavior, include the slf4j-jdk14-xxxx.jar; this 
      enables the standard Java Utility Logging facility. 
    </p>
    
    <p>Some Maven projects use the JCasGen maven plugin; these projects' JCasGen maven plugin,
     if switched to UIMA V3, automatically generate the V3 versions.  For proper operation, please run
     maven clean install; the clean operation ought to remove the previously generated JCas class, including the
     UIMA V2 <code class="code">xxx_Type</code> classes.  These are no longer used, and won't compile in V3. 
    </p>
    
    <p>You can use any of the methods of invoking JCasGen to generate the new V3 versions.  
      If using the Eclipse plugins (i.e., pushing the <code class="code">JCasGen</code>) button in the 
      configuration editor, etc.), the V3 version of the plugin must be the one installed into Eclipse.
    </p>
    
    <p>    
      If you have the source or class files, you can also migrate those using the migration tool described in this section.
      This approach is useful when you've customized the JCas class, and wish to preserve those customizations,
      while converting the v2 style to the v3 style.
    </p>
     
    
    
    
  </div>
  
  
  <div class="section" title="7.3.&nbsp;Migrating JCas classes"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="uv3.migration.jcas">7.3.&nbsp;Migrating JCas classes</h2></div></div></div>
    
   
  
   
  <p>If you have customized JCasGen classes, these can be migrated by running the migration tool, which is available
	  as a stand-alone command line tool (<code class="code">runV3migrateJCas.sh or ...bat</code>), or 
	  as Eclipse launch configurations.</p>
	  
  <p>This tool can migrate either sets of
    </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Java source files (xxx.java) or </p></li><li class="listitem"><p>Compiled Java class files (including those contained in JARs or PEARs)</p></li></ul></div><p>
    
    Usually, if you have the source code it is best to migrate the sources.  Otherwise, you can migrate the compiled classes.
  </p> 
  
  <p>When migrating <span class="strong"><strong>source</strong></span> files, you specify one or more "roots" - places in a file directory, 
    and the tool scans those  
    directories recursively (including inside Jars and PEARs), looking for JCas source files.  When it finds one, it copies it to the output spot 
    and migrates it. The output is arranged in parallel directories (before and after migration), 
    for easy side-by-side comparing in a tool such as Eclipse file compare.</p>
    
  <p>After checking the migration results, including comparing the files, you replace the original source with
    the migrated versions.  Also, the original V2 source would contain a source file for each JCas class ending in
    "_Type"; these are not used in version 3 and should be deleted.</p>
    
  <p>You may also migrate <span class="strong"><strong>class</strong></span> files; this can be used when the source files are not available.
    This option has a decompilation step, to produce the source to be migrated and requires
    a classpath (passed as the <code class="code">migrationClasspath</code> parameter);
    this classpath is used to resolve symbols during the decompilation, and should be the classpath used when running those classes.
    For class files, the migration tool 
    attempts to compile the results and, for Jars and PEARs, to update those migrated classes 
    in a copy of the original packaging (meaning, within Jars or PEARs): 
    
    </p><div class="itemizedlist"><ul class="itemizedlist" type="disc" compact><li class="listitem"><p>The <span class="strong"><strong>classesRoots</strong></span> are used to locate .class files, perhaps within Jars and PEARs.</p></li><li class="listitem"><p>These are decompiled, using special versions of the migrateClasspath.</p></li><li class="listitem"><p>The resultant sources are migrated.</p></li><li class="listitem"><p>The migrated sources are compiled.</p></li><li class="listitem"><p>If the original classes came from Jars or PEARs, copies of these are made with the 
        migrated classes replaced.</p></li></ul></div><p>
  </p>
  
        
  <p>When scanning directories from source or class roots, if a Jar or a PEAR is encountered, it is recursively scanned.</p>
    
  <p>When migrating from compiled classes:
    </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>The class is decompiled, and the resulting source is migrated.</p>
      </li><li class="listitem"><p>The next 2 steps are skipped if no Java compiler is available.  A compiler is available if
        the migrate utility is being run using a JDK (as opposed to a JRE version of Java).</p></li><li class="listitem"><p>The migrated classes are compiled. 
        During this processes, the classpath used is the same as the decompile classpath, except
        that the uima-core Jar for version 3 (from the classpath used to run the migration tool) is prepended
        so that the migrated version can be compiled.
        </p></li><li class="listitem"><p>Finally, if the original "packaging" of the class files is a Jar or PEAR, it 
        is copied and updated with the migrated classes (provided there was no compile error).
        </p>
      </li></ul></div><p>
  </p>
                
  <p>The results of the migration include the migrated files, a set of logs, and for classesRoots: the 
    compiled classes, and repackaging of them into copies of original Jars and/or PEARs.
    The migration operation is summarized in the console
    output, detailing anything that might need inspection to verify the migration was done correctly.
  </p>
  
  <div class="blockquote"><blockquote class="blockquote"><p>
    If all is OK, the migration will say that it "finished with no unusual conditions", at the end.
  </p></blockquote></div> 	  

  <p>To complete the migration, fix any reported issues that need fixing, and then 
    update your UIMA application to use these classes/Jars/PEARs 
    in place of the version 2 ones.
  </p>
    	
	<p>  
	  The actual migration step is a source-to-source transformation, done using a parse of the source files.
	  The parts in the source which are version 2 specific are replaced with the equivalent version 3 code.
	  Only those parts which need updating are modified;
    other code and comments which are part of the source file are left unchanged.  This is intended to preserve
    any user customization that may have been done.  
  </p>
    
 
 		 		 
		 <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>After running the tool, it is important to examining the console output and logs.
       You can confirm that the migration completed without any unusual conditions, or, if something 
       unusual was encountered, you can take corrective action.
		 </p></div>
		  
		<div class="section" title="7.3.1.&nbsp;Running the migration tool"><div class="titlepage"><div><div><h3 class="title" id="uv3.migration.tool_guide.running">7.3.1.&nbsp;Running the migration tool</h3></div></div></div>
	    
      
	    <p>The tool can be run as a stand-alone command, using the launcher scripts <code class="code">runV3migrateJCas</code>; 
	      there are two versions of this &#8212; one for windows (ending it ".bat") 
        and one for linux / mac (ending in ".sh").
		    If you run this without any arguments, it will show a brief help for the arguments.
		  </p>
		  
		  <p>There are also a pair of Eclipse launch configurations 
        (one for migrating source files, the other for compiled classes and JARs and PEARs), 
        which are available if you have the uimaj-examples project
        (included in the binary distribution of UIMA) in your Eclipse workspace.
      </p>
      
      <div class="section" title="7.3.1.1.&nbsp;Using Eclipse to run the migration tool"><div class="titlepage"><div><div><h4 class="title" id="uv3.migration.tool_guide.running.eclipse">7.3.1.1.&nbsp;Using Eclipse to run the migration tool</h4></div></div></div>
      
      
        <p>There are two Eclipse launch configurations; one works with source code, the other with compiled classes
          or Jars or PEARs.  The launch configurations are named:
          </p><div class="itemizedlist"><ul class="itemizedlist" type="disc" compact><li class="listitem"><p>UIMA Run V3 migrate JCas from sources roots</p></li><li class="listitem"><p>UIMA Run V3 migrate JCas from classes roots</p></li></ul></div><p>
          When running from class directory roots, the classes must not have compile errors, and may contain Jars and PEARs.
          Both launchers write their output to a temporary directory, whose name is printed in the Eclipse console log.
        </p>
      
        <p>
          To use the Eclipse launcher to migrate from source code,
            </p><div class="itemizedlist"><ul class="itemizedlist" type="disc" compact><li class="listitem"><p>First select the eclipse project containing the source code to transform; 
                this project's "build path" will also supply the 
                classpath used during migration.</p></li><li class="listitem"><p>run the migrate-from-sources launcher.
              </p></li></ul></div><p>
            This will scan the directory tree of the project, looking for source files which are JCas files, and 
            migrate them.  No existing files are modified; everything is written to the output directory.
  		  </p>
        
        <p>
          To use the launcher for compiled code,
            </p><div class="itemizedlist"><ul class="itemizedlist" type="disc" compact><li class="listitem"><p>First select the eclipse project that provides the classpath for the compiled code. 
                This is required for proper "decompiling" of the classes and
                recompiling the transformed results.
                </p></li><li class="listitem"><p>The launcher will additionally prompt you for another directory 
                which the migration tool will use as the top of a tree to scan for compiled Java JCas classes to be migrated.
              </p></li></ul></div><p>
        </p>
  	            
      </div>
		  
      
      <div class="section" title="7.3.1.2.&nbsp;Running from the command line"><div class="titlepage"><div><div><h4 class="title" id="uv3.migration.tool_guide.running.cmd_line">7.3.1.2.&nbsp;Running from the command line</h4></div></div></div>
      
      
  	    <div class="section" title="Command line: Specifying input sources"><div class="titlepage"><div><div><h5 class="title" id="uv3.migration.tool_guide.running.inputs">Command line: Specifying input sources</h5></div></div></div>
  	      
  	    
  	    <p>Input is specified using these arguments:
  		    </p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>"-sourcesRoots"</strong></span></span></dt><dd>
  		          <p>a list of one or more directories, separated by the
  		            a path separator character (";" for Windows, ":" for others). 
  		          </p>
  		          <p>Migrates each candidate source file found in any of the file tree roots,
  		            skipping over non-JCas classes.</p>
  		        </dd><dt><span class="term"><span class="strong"><strong>"-classesRoots"</strong></span></span></dt><dd>
                <p>a list of one or more directories
                  containing class files or Jars or PEARs, separated by the
                  a path separator character (";" for Windows, ":" for others). 
                </p>
  	            <p>Decompiles, then migrates each candidate class file found in any of the file tree roots
  	              (skipping over non-JCas classes).  
  	            </p>	              
  	          </dd></dl></div><p>
          You can specify either of these, but not both.  
  	    </p>
        </div>
        	    
  	    <div class="section" title="Command line: Specifying a classpath for the migration"><div class="titlepage"><div><div><h5 class="title" id="uv3.migration.tool_guide.classpath">Command line: Specifying a classpath for the migration</h5></div></div></div>
  	      
  	      <p>When migrating from compiled classes, a classpath is required to locate and decompile
            the JCas classes to be migrated.  This classpath should include the JCas classes 
            to be decompiled. The compiled classes must not have compile errors.
          </p>
          
          <p>When migrating from sourcesRoots, this argument is required only if the JCas classes
            have references to other non-migrated classes (other than core UIMA classes).  For example,
            if your JCas class had a reference to a user defined Utility class, that would need to be in the classpath.
            For plain, non-customized JCas classes, this argument is unnecessary.
          </p>
          
          <p>To specify this parameter, use the argument <code class="code">-migrateClasspath</code>.
  	        The Eclipse launcher "UIMA run V3 migrate JCas from classes roots" sets this argument using
  	        the selected Eclipse project's classpath.
  	        When migrating within a PEAR, the migration tool automatically adds the 
            classpath specified by the PEAR (if any) to the classpath.
  	      </p>
  	    </div>

      </div>
      	    	    	    
	    <div class="section" title="7.3.1.3.&nbsp;Handling duplicate definitions"><div class="titlepage"><div><div><h4 class="title" id="uv3.migration.tool_guide.duplicates">7.3.1.3.&nbsp;Handling duplicate definitions</h4></div></div></div>
	      
	      <p>Sometimes, a classpath or directory tree may contain multiple instances of the same JCas class.
	        These might be identical, or they might be different versions.  
        </p>
        
        <p>The migration utility handles this by migrating each instance.  
        
        
        The migrated forms are 
          stored in the output directory prefixed by the root-id (see above), as the parent directory.
          The different versions can then be conveniently compared using tooling such as Eclipse's file compare.
	      </p>
	      
	    </div>
	  </div>  

    <div class="section" title="7.3.2.&nbsp;Understanding the reports"><div class="titlepage"><div><div><h3 class="title" id="uv3.migration.tool_guide.reports">7.3.2.&nbsp;Understanding the reports</h3></div></div></div>
      
      <p>The output directory contains a logs directory with additional information.
        A summary is also written to System.out.
      </p>
        
      <p>Each file translated has both a v2 source and a v3 source.  When the input is ".class" files, 
        the v2 source is the result of the decompilation step, prior to any migration.
      </p>
              
      <p>The process of scanning directories to find JCas class to migrate may come across multiple instances of
        the same class.  There are two subcases:
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>The instances are the same.</p></li><li class="listitem"><p>The instances are different (two non-identical definitions for the same class).
          Sometimes these arise when migrating from compiled classes, where the compilation was done by different
          versions of the Java compiler, and the resulting decompilations are logically equal but have some fields or
          methods in a different order.</p></li></ul></div>
      
      <p>This diagram illustrates some of the potentials for identical and non-identical duplicate definitions
        for the same classname, that the tool may encounter.  The blue boxes represent ordinary file directories
        or Jars, and the other boxes with labels Cn1 and Cn2 represent the definitions for a classes named Cn1 
        and Cn2; the different colors represent non-identical definitions, as an example.  Note that a definition
        for a class might appear sometimes not within a Jar (or a PEAR, not shown here), as well as with that.
         </p><div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="564"><tr><td><img src="images/version_3_users_guide/migrate/multiples.png" width="564" alt="Example of some possible duplicate class definitions"></td></tr></table></div><p>
        
        The migration tool allows for all of these variants.  It will 
        migrate all versions, and will (when migrating from compiled Jars and PEARs) compile and reassemble these.</p>
        
      <p>The output directories prefix the package/classname holding the source code with a prefix of 
        "a0", "a1", etc.  The "a" stands for alternative, and the 0 is for the first alternative, and the 1, 2, ...
        are for other non-equal alternatives.</p>
        
      <p>When the migration is run from compiled classes, then, if possible,
      the resulting migrated classes are recompiled and if from Jars or PEARs, reassembled into copies of those artifacts.
      The compilation for the same classname, with the same sourcecode, could be different for different containers
      because each compilation is done with that container's classpath (e.g. Jar or Pear) and with respect to the
      compilation units of that container.  
      </p>
      
      <p>Because of this, the compiled results for a given source instance, are done separately, and kept in output
      directories, indexed additionally by the container number, as "c0", "c1", ... .
      A list of all container numbers and the migrated      
      classes within those containers, is printed out to enable correlating these by hand when necessary.
      </p>
             
      <p>The overall directory output directory tree looks like:
        </p><pre class="programlisting">Directory structure, starting at -outputDirectory
   converted/
     v2/
       a0/pkg/name.../Classname.java   
                           /Classname2.java etc.
       a1/pkg/name.../Classname.java  if there are multiple
                                              different versions 
       ...
     v3/
       a0/pkg/name.../Classname.java
                     /Classname2.java etc.
       a1/pkg/name.../Classname.java  if there are multiple
                                              different versions
       ...
       
     v3-classes/   for Jars and PEARs, the compiled class
       // xyz is the path in the container to the
       //       start of the pkg/name.../Classname.class
       // the "a0", "a1", ... is extra but serves to 
       //      identify which alternative of the source
       23/a0/xyz/pkg/name.../Classname.class
       33/a0/xyz/pkg/name.../Classname.class
       42/a0/xyz/pkg/name.../Classname.class
         ...    

     pears/
       // xyz_updated_pear_copy is the path
       //    relative to the container, of the PEAR
       33/xyz_updated_pear_copy.pear  
         ...
     
     jars/
       // xyz_updated_jar_copy is the path
       //    relative to the container, of the Jar
       42/xyz_updated_jar_copy.jar
         ...
       
   not-converted/
   
   logs/
     processed.txt
     failed.txt
     skippedBuiltins.txt
     nonJCasFiles.txt
     workaroundDir.txt
     deletedCheckModified.txt
     manualInspection.txt
     pearFileUpdates.txt
     jarFileUpdates.txt
     
     ...</pre><p>
      </p>
    
      <p>
        The converted subtree holds all the sources and migrated versions that were successfully migrated.
        The not-converted subtree hold the sources that failed in some way the migration.
        The logs contain many kinds of entries for different issues encountered:
        </p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>processed.txt</strong></span></span></dt><dd>
              <p>List of successfully processed classes
              </p>
            </dd><dt><span class="term"><span class="strong"><strong>failed.txt</strong></span></span></dt><dd>
              <p>List of classes that failed to migrate
              </p>
            </dd><dt><span class="term"><span class="strong"><strong>skippedBuiltins.txt</strong></span></span></dt><dd>
              <p>List of classes representing built-ins that were skipped.  These need
                manual inspection to see how to merge with new v3 built-ins.
              </p>
            </dd><dt><span class="term"><span class="strong"><strong>NonJCasFiles.txt</strong></span></span></dt><dd>
              <p>List of files that were thought to be JCas classes but 
                upon further analysis appear to not be.  These need 
                manual inspection to confirm.
              </p>
            </dd><dt><span class="term"><span class="strong"><strong>deletedCheckModified.txt</strong></span></span></dt><dd>
              <p>List of class where a version 2 if statement doing the "featOkTst"
                was apparently modified.  In the migrated code, this statement was deleted,
                perhaps incorrectly. These need manual inspection to confirm.
              </p>
            </dd><dt><span class="term"><span class="strong"><strong>manualInspection.txt</strong></span></span></dt><dd>
              <p>List of files where the migration found a get or set method, where
                the version 2 code was accessing a casFeatCode with the 
                feature name not matching.  These need manual inspection.
              </p>
            </dd><dt><span class="term"><span class="strong"><strong>jarsFileUpdates.txt</strong></span></span></dt><dd>
              <p>List of Jar files and classes which were replace in them.
              </p>
            </dd><dt><span class="term"><span class="strong"><strong>pearsFileUpdates.txt</strong></span></span></dt><dd>
              <p>List of Pear files and classes which were replace in them.
              </p>
            </dd></dl></div><p>    
      </p>
           
    </div>
    
    <div class="section" title="7.3.3.&nbsp;Examples"><div class="titlepage"><div><div><h3 class="title" id="uv3.migration.tool_guide.cookbook">7.3.3.&nbsp;Examples</h3></div></div></div>
       
    
      <p>Run the command line tool:
      </p><pre class="programlisting">cd $UIMA_HOME
      
bin/runV3migrateJCas.sh

  -migrateClasspath /home/me/myproj/xyz.jar:$UIMA_HOME/lib/uima-core.jar
    
  -classesRoots /home/me/myproj/xyz.jar:/home/me/myproj/target/classes
  
  -outputDirectory /temp/migratejcas  
</pre><p>
      </p>
      
      <p>Run the Eclipse launcher:</p>
      <p>First, make sure you've installed the V3 UIMA plugins into Eclipse!</p>
      
      <pre class="programlisting">Startup an Eclipse workspace containing the project 
with JCas source files to be migrated.
      
Select the Java project with the JCas sources to be migrated.

Eclipse -&gt; menu -&gt; Run -&gt; Run configurations
  Use the search box to find 
  "UIMA run V3 migrate JCas from sources" launcher.
</pre>
    
    <p>Please read the console output summarization to see where the output went, and about any 
      conditions found during migration which need manual inspection and fixup.</p>
    </div>
    
  </div>
  
    <div class="section" title="7.4.&nbsp;Consuming V3 Maven artifacts"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="uv3.migration.consuming">7.4.&nbsp;Consuming V3 Maven artifacts</h2></div></div></div>
    
    
    
     
    <p>Projects may have tests which write to the UIMA log.  Because V3 switched to SLF4J as the default logger,
      unless SLF4J can find an adapter to some back-end logger, it will issue a message and substitute a "NO-OP" 
      back-end logger.  If your test cases depend on having the V2 default logger (which is the one built into Java), 
      you need to add a "test" dependency that specifies the SLF4J-to-JDK14 adapter to your POM.  Here's the xml for that:</p>
    <pre class="programlisting">&lt;dependency&gt;
  &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
  &lt;artifactId&gt;slf4j-jdk14&lt;/artifactId&gt;
  &lt;version&gt;1.7.24&lt;/version&gt;  &lt;!-- or some version you need --&gt;
  &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</pre>

    
  </div>
  
</div>
  <div class="chapter" title="Chapter&nbsp;8.&nbsp;PEAR support" id="uv3.pears"><div class="titlepage"><div><div><h2 class="title">Chapter&nbsp;8.&nbsp;PEAR support</h2></div></div></div>
  

  <p>PEARs continue to be supported in Version 3, with the same 
    capabilities as in version 2.  Here's a brief review.
  </p>
  
  <p>PEARs are both a packaging facility, and an isolation facility.
  The packaging facility allows putting together into one PEAR file all the parts needed
  for a particular (reusable) UIMA pipeline, including annotators and other data resources,
  and a classpath to use.  PEARs are loaded using special class loaders that load first from
  whatever classpath is specified by the PEAR; this serves to isolate dependencies and insure
  that the PEAR makes use of whatever versions of classes it depends on (and specifies in its 
  classpath).
  </p>
  
  <p>PEARs establish a boundary within a UIMA pipeline &#8212;
    annotator code is running either inside a PEAR, or not.
    Note that PEARs cannot be nested.  
    The CAS, flowing through a pipeline, is dynamically updated with the current PEAR context (if any).    
  </p>
  
  <div class="section" title="8.1.&nbsp;JCas issues"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="uv3.pears.jcas">8.1.&nbsp;JCas issues</h2></div></div></div>
    
    
    <p>JCas classes defining Java implementations for UIMA Types may be defined within a PEAR.  
      These are loaded using the isolating Classloader, just like all the other PEAR resources.
      As a result, this may cause some issues if the same JCas class is also defined outside 
      the PEAR boundary, and loaded with the normal UIMA classloader.  The result of having the 
      same JCas class both on the PEAR classloader and outside that classloader will be that Java 
      will have both classes loaded, and code within the PEAR will be linked with one of them, and code
      outside the PEAR will be linked with the other. 
    </p>  
    
    <p>
      Sometimes, this is exactly what you might want.  For example, you might have in the pear, a special
      JCas definition of a UIMA type "Token" which the PEAR uses, while you might have another JCas 
      definition for that same UIMA type outside of the PEAR. Note that UIMA will always merge Type 
      definitions from inside and outside of PEARs, when it sets up a pipeline - it merges all type 
      definitions found for the whole pipeline.  
    </p>
    
    <p>A consequence of having two loaded class definitions in two contexts for the same UIMA type means
      that the classes have the same names, but are different (because of different loading classloaders), 
      and assigning one to the other in Java will produce a ClassCast exception.
    </p>
    
    <p>Othertimes, you may not want different classes.  For instance, the class definitions might be
      identical, and you want to create some "Token" annotations within the PEAR, and have them 
      used by JCas references outside of the PEAR.
    </p>
    
    <p>In this case, the simplest thing to do is to install the PEAR, but then update its classpath so
      it no longer includes the JCas classes that came with the PEAR.  When classes are not found with the
      special PEAR class loader, that loader delegates to its parent, which is the normal UIMA class loader.
      This action will cause the PEAR to use the identically same JCas class within the PEAR as is used
      outside of the PEAR, and no Class Cast Exception issues will arise.
      This is the most efficient way to run with PEARs that use JCas classes where you want to share results
      inside and outside of PEARs.
    </p>
    
    <p>
      Version 3 has special support for the case where there are different definitions of JCas classes 
      for the same UIMA type, inside and outside the PEAR.  It does this using what are called
      PEAR Trampolines.  When there are multiple JCas definitions, the one defined outside of the PEAR is
      the one stored internally in UIMA's indexes and types that have references to Feature Structures.
      Accessing the Feature Structures checks (by asking the CAS) to see if its in a particular PEAR context
      (there may be several in one pipeline), and if so, a trampoline instance of the Feature Structure is
      created / used / accessed.  The trampoline instance shares internally the CAS data with the
      base instance, but is a separate instance of the PEAR's JCas class definition.  
      This allows seamless access both inside and outside of the PEAR context to the particular
      JCas class definition needed.  
    </p>
  </div>

  <div class="section" title="8.2.&nbsp;Custom Java Objects"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="uv3.pears.java_objects">8.2.&nbsp;Custom Java Objects</h2></div></div></div>
    
    
    <p>Custom Java Objects may store references to Feature Structures.  If it is desired to create 
      these inside a PEAR, and yet have the references work outside a PEAR, the implementor of these must
      insure that the actual stored JCas class for a Feature Structure is the base version, not the PEAR version,
      and also insure that any references are properly converted (while within a PEAR context).  
    </p> 
    
    <p>Refer to the implementation of <code class="code">FSHashSet</code> and <code class="code">FSArrayList</code> to see what
      needs to be done to make these "Pear aware".
    </p> 
    
  </div>
    
  </div>
  <div class="chapter" title="Chapter&nbsp;9.&nbsp;Migration aids" id="uv3.migration.aids"><div class="titlepage"><div><div><h2 class="title">Chapter&nbsp;9.&nbsp;Migration aids</h2></div></div></div>
  
    
    <p>To aid migration, some features of UIMA V3 which might cause migration difficulties 
      can be disabled.  Users may initially want to disable these, and get their pipelines working,
      and then over time, re-enable these while fixing any issues that may come up, one feature
      at a time.
    </p> 
    
    <p>
      Global JVM properties for UIMA V3 that control these are described in the table below.  
    </p>
  
  <div class="section" title="9.1.&nbsp;Properties Table"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="uv3.migration.aids.property-table">9.1.&nbsp;Properties Table</h2></div></div></div>
    
      
    <p>This table describes the various JVM defined properties; specify these on the Java command line
    using <code class="code">-Dxxxxxx</code>, where the <code class="code">xxxxxx</code> is one of
    the properties starting with <code class="code">uima.</code> from the table below.</p>  
    <div class="informaltable">
     <table style="border-collapse: collapse;border-top: 0.5pt solid black; border-bottom: 0.5pt solid black; border-left: 0.5pt solid black; border-right: 0.5pt solid black; "><colgroup><col class="Title"><col class="Description"></colgroup><tbody><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; "><span class="bold"><strong>Title</strong></span></td><td style="border-bottom: 0.5pt solid black; "><span class="bold"><strong>Property Name &amp; Description</strong></span></td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; "><p>Use UIMA V2 format for toString() for Feature Structures</p></td><td style="border-bottom: 0.5pt solid black; "><p><code class="code">uima.uima.v2_pretty_print_format</code></p>
           
                  <p>The native v3 format for pretty printing feature structures
                    includes an id number with each FS, and some other minor improvements.
                    If you have code which depends on the exact format that v2 UIMA produced
                    for the toString() operation on Feature Structures, then include this
                    flag to revert to that format.</p></td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; "><p>Disable Type System consolidation</p></td><td style="border-bottom: 0.5pt solid black; "><p><code class="code">uima.disable_typesystem_consolidation</code></p>
           
                  <p>Default: equal Type Systems are consolidated.</p>
                  <p>When type systems are committed, the resulting Type System (Java object) 
                    is considered read-only, and is compared to already existing Type Systems.
                    Existing type systems, if found, are reused.  Besides saving storage, this can
                    sometimes improve locality of reference, and therefore, performance. 
                    Setting this property disables this consolidation.</p></td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; "><p>Enable finding all Feature Structures by their int ID</p></td><td style="border-bottom: 0.5pt solid black; "><p><code class="code">uima.enable_id_to_feature_structure_map_for_all_fss</code></p>
           
                  <p>Default: normally created Feature Structures are not kept in a map.</p>
                  <p>In version 3, normally, Feature Structures are not added to the 
                        map used by the Low Level CAS API to map from int ids to Feature Structures.
                        This has the benefit that no longer referenced Feature Structures may be 
                        garbaged collected.  This behavior may be overridden by this property.</p></td></tr><tr><td style="border-bottom: 0.5pt solid black; " colspan="2" align="center"><span class="bold"><strong>Trading off runtime checks for speed</strong></span></td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; "><p>Disabling runtime feature validation</p></td><td style="border-bottom: 0.5pt solid black; "><p><code class="code">uima.uima.disable_runtime_feature_validation</code></p>
           
                  <p>Once code is running correctly, you may remove this check for performance
                    reasons by setting this property.</p></td></tr><tr><td style="border-right: 0.5pt solid black; "><p>Disabling runtime feature <span class="emphasis"><em>value</em></span> validation</p></td><td style=""><p><code class="code">uima.disable_runtime_feature_value_validation</code></p>
           
                  <p>Default: features being set into FS features which are FSs are checked for proper type subsumption.</p>
                  <p>Once code is running correctly, you may remove this check for performance
                    reasons by setting this property.</p></td></tr></tbody></table>
   </div>
    
  </div>
  
</div>

  
</div></body></html>