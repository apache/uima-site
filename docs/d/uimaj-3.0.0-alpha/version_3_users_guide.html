<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>UIMA Version 3 User's Guide</title><link rel="stylesheet" type="text/css" href="css/stylesheet-html.css"><meta name="generator" content="DocBook XSL-NS Stylesheets V1.76.1"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div lang="en" class="book" title="UIMA Version 3 User's Guide" id="d5e1"><div xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div><h1 class="title">UIMA Version 3 User's Guide</h1></div><div><div class="authorgroup">
      <h3 class="corpauthor">Written and maintained by the Apache UIMA&#8482; Development Community</h3>
    </div></div><div><p class="releaseinfo">Version 3.0.0-alpha</p></div><div><p class="copyright">Copyright &copy; 2006, 2017 The Apache Software Foundation</p></div><div><p class="copyright">Copyright &copy; 2004, 2006 International Business Machines Corporation</p></div><div><div class="legalnotice" title="Legal Notice"><a name="d5e8"></a>
      <p> </p>
      <p title="License and Disclaimer">
        <b>License and Disclaimer.&nbsp;</b>

        The ASF licenses this documentation
           to you under the Apache License, Version 2.0 (the
           "License"); you may not use this documentation except in compliance
           with the License.  You may obtain a copy of the License at
         
         </p><div class="blockquote"><blockquote class="blockquote">
           <a class="ulink" href="http://www.apache.org/licenses/LICENSE-2.0" target="_top">http://www.apache.org/licenses/LICENSE-2.0</a>
         </blockquote></div><p title="License and Disclaimer">
         
           Unless required by applicable law or agreed to in writing,
           this documentation and its contents are distributed under the License 
           on an 
           "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
           KIND, either express or implied.  See the License for the
           specific language governing permissions and limitations
           under the License.
         
      </p>
      <p> </p>
      <p> </p>
      <p title="Trademarks">
        <b>Trademarks.&nbsp;</b>
        All terms mentioned in the text that are known to be trademarks or 
        service marks have been appropriately capitalized.  Use of such terms
        in this book should not be regarded as affecting the validity of the
        the trademark or service mark.
        
      </p>
    </div></div><div><p class="pubdate">January, 2017</p></div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="chapter"><a href="#uv3.overview">1. Overview</a></span></dt><dd><dl><dt><span class="section"><a href="#uv3.overview.new">1.1. What's new</a></span></dt><dt><span class="section"><a href="#uv3.overview.java8">1.2. Java 8 is required</a></span></dt></dl></dd><dt><span class="chapter"><a href="#uv3.backwards_compatibility">2. Backwards Compatibility</a></span></dt><dd><dl><dt><span class="section"><a href="#uv3.backwards_compatibility.jcas">2.1. JCas and non-JCas APIs</a></span></dt><dt><span class="section"><a href="#uv3.backwards_compatibility.serialization">2.2. Serialization forms</a></span></dt><dd><dl><dt><span class="section"><a href="#uv3.backwards_compatibility.serialization.deltas">2.2.1. Delta CAS Version 2 Binary deserialization not supported</a></span></dt></dl></dd><dt><span class="section"><a href="#uv3.backards_compatibility.low_level_apis">2.3. APIs for creating and modifying Feature Structures</a></span></dt><dt><span class="section"><a href="#uv3.backards_compatibility.PEARs">2.4. PEAR support</a></span></dt><dt><span class="section"><a href="#uv3.backards_compatibility.toString">2.5. toString()</a></span></dt><dt><span class="section"><a href="#uv3.backards_compatibility.typesystem_sharing">2.6. Type System sharing</a></span></dt><dt><span class="section"><a href="#uv3.backards_compatibility.checking">2.7. Some checks moved to native Java</a></span></dt><dt><span class="section"><a href="#uv3.backards_compatibility.class_hierarchy">2.8. Some class hierarchies have been modified</a></span></dt></dl></dd><dt><span class="chapter"><a href="#uv3.new_extended_apis">3. New/Extended APIs</a></span></dt><dd><dl><dt><span class="section"><a href="#uv3.new_extended_apis.jcas_static_fields">3.1. JCas additional static fields</a></span></dt><dt><span class="section"><a href="#uv3.new_extended_apis.java8">3.2. Java 8 integrations</a></span></dt><dd><dl><dt><span class="section"><a href="#uv3.new_extended_apis.java8.lists">3.2.1. Built-in UIMA Arrays and Lists integration with Java 8</a></span></dt></dl></dd><dt><span class="section"><a href="#uv3.new_extended_apis.fsiterator_implements_list">3.3. UIMA FSIterators improvements</a></span></dt><dt><span class="section"><a href="#uv3.new_extended_apis.select">3.4. New Select API</a></span></dt><dt><span class="section"><a href="#uv3.new_extended_apis.custom_java_objects">3.5. New custom Java objects in the CAS framework</a></span></dt><dt><span class="section"><a href="#uv3.new_extended_apis.lists_and_arrays">3.6. Built-in lists and arrays</a></span></dt><dd><dl><dt><span class="section"><a href="#uv3.new_extended_apis.reorganized.lists_and_arrays">3.6.1. Built-in lists and arrays have common super classes / interfaces</a></span></dt></dl></dd><dt><span class="section"><a href="#uv3.new_extended_apis.annotation">3.7. Annotation comparator methods</a></span></dt><dt><span class="section"><a href="#uv3.new_extended_apis.reorganized">3.8. Reorganized APIs</a></span></dt><dt><span class="section"><a href="#uv3.new_extended_apis.other">3.9. Other changes</a></span></dt></dl></dd><dt><span class="chapter"><a href="#uv3.select">4. Select framework</a></span></dt><dd><dl><dt><span class="section"><a href="#uv3.select.builder_pattern">4.1. Select's use of the builder pattern</a></span></dt><dt><span class="section"><a href="#uv3.select.sources">4.2. Sources of Feature Structures</a></span></dt><dd><dl><dt><span class="section"><a href="#uv3.select.sources.type">4.2.1. Use of Type in selection of sources</a></span></dt><dt><span class="section"><a href="#uv3.select.sources.generics">4.2.2. Sources and generic typing</a></span></dt></dl></dd><dt><span class="section"><a href="#uv3.select.selection_and_ordering">4.3. Selection and Ordering</a></span></dt><dd><dl><dt><span class="section"><a href="#uv3.select.boolean_properties">4.3.1. Boolean properties</a></span></dt><dt><span class="section"><a href="#uv3.select.any_source">4.3.2. Configuration for any source</a></span></dt><dt><span class="section"><a href="#uv3.select.any_index">4.3.3. Configuration for any index</a></span></dt><dt><span class="section"><a href="#uv3.select.ordered_index">4.3.4. Configuration for sort-ordered indexes</a></span></dt><dt><span class="section"><a href="#uv3.select.annot.subselect">4.3.5. Bounded sub-selection within an Annotation Index</a></span></dt><dt><span class="section"><a href="#uv3.select.annot.variations">4.3.6. Variations in Bounded sub-selection within an Annotation Index</a></span></dt><dt><span class="section"><a href="#uv3.select.annot.subselect.defaults">4.3.7. Defaults for bounded selects</a></span></dt><dt><span class="section"><a href="#uv3.select.annot.follow_precede">4.3.8. Following or Preceding</a></span></dt></dl></dd><dt><span class="section"><a href="#uv3.select.terminal_form_actions">4.4. Terminal Form actions</a></span></dt><dd><dl><dt><span class="section"><a href="#uv3.select.terminal_form_actions.iterators">4.4.1. Iterators</a></span></dt><dt><span class="section"><a href="#uv3.select.terminal_form_actions.arrays_lists">4.4.2. Arrays and Lists</a></span></dt><dt><span class="section"><a href="#uv3.select.terminal_form_actions.single_items">4.4.3. Single Items</a></span></dt><dt><span class="section"><a href="#uv3.select.terminal_form_actions.streams">4.4.4. Streams</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#uv3.custom_java_objects">5. CAS Java Objects</a></span></dt><dd><dl><dt><span class="section"><a href="#uv3.custom_java_objects.tutorial">5.1. Tutorial example</a></span></dt><dt><span class="section"><a href="#uv3.custom_java_objects.new_semibuiltins">5.2. Semi-Built-in UIMA Types for Java Objects</a></span></dt><dd><dl><dt><span class="section"><a href="#uv3.custom_java_objects.semibuiltin_fsarraylist">5.2.1. FSArrayList</a></span></dt><dt><span class="section"><a href="#uv3.custom_java_objects.semibuiltin_integerarraylists">5.2.2. IntegerArrayList</a></span></dt><dt><span class="section"><a href="#uv3.custom_java_objects.semibuiltin_FSHashSet">5.2.3. FSHashSet</a></span></dt></dl></dd><dt><span class="section"><a href="#uv3.custom_java_objects.design">5.3. Design for reuse</a></span></dt></dl></dd><dt><span class="chapter"><a href="#uv3.migration">6. Migrating JCas</a></span></dt><dd><dl><dt><span class="section"><a href="#uv3.migration.big_picture">6.1. How to migrate</a></span></dt><dd><dl><dt><span class="section"><a href="#uv3.migration.maven-cookbook">6.1.1. Maven v2/v3 simultaneous support</a></span></dt></dl></dd><dt><span class="section"><a href="#uv3.migration.jcas">6.2. Migrating JCas classes</a></span></dt><dd><dl><dt><span class="section"><a href="#uv3.migration.tool_guide.running">6.2.1. Running the migration tool</a></span></dt><dt><span class="section"><a href="#uv3.migration.tool_guide.reports">6.2.2. Understanding the reports</a></span></dt><dt><span class="section"><a href="#uv3.migration.tool_guide.cookbook">6.2.3. Examples</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#uv3.pears">7. PEAR support</a></span></dt><dd><dl><dt><span class="section"><a href="#uv3.pears.jcas">7.1. JCas issues</a></span></dt><dt><span class="section"><a href="#uv3.pears.java_objects">7.2. Custom Java Objects</a></span></dt></dl></dd><dt><span class="chapter"><a href="#uv3.migration.aids">8. Migration aids</a></span></dt><dd><dl><dt><span class="section"><a href="#uv3.migration.aids.property-table">8.1. Properties Table</a></span></dt></dl></dd></dl></div>
  
  

  
  
  <div class="chapter" title="Chapter&nbsp;1.&nbsp;Overview of UIMA Version 3" id="uv3.overview"><div class="titlepage"><div><div><h2 class="title">Chapter&nbsp;1.&nbsp;Overview of UIMA Version 3</h2></div></div></div>
  
  
  
  <p>UIMA Version 3 adds significant new functionality for the Java SDK, while remaining 
  backward compatible with Version 2.  Much of this new function is enabled by a shift in the 
  internal details of how Feature Structures are represented.  In Version 3, these are represented
  internally as ordinary Java objects, and subject to garbage collection.</p>
  <div class="blockquote"><blockquote class="blockquote"><p>
	  In contrast, version 2 stored Feature Structure data in special internal
	  arrays of <code class="code">ints</code> and other data types.  
	  Any Java object representation of Feature Structures in version 2
	  was merely forwarding references to these internal data representations.
  </p>
  </blockquote></div>    
  
  <p>If JCas is being used in an application, the JCas classes must be migrated, but this can often
  be done automatically.  In Version 3, the JCas classes ending in "_Type" are no longer used, and the 
  main JCas class definitions are much simplified.</p>
  
  <div class="blockquote"><blockquote class="blockquote"><p>
  If an application doesn't use JCas classes, then nothing need be done for migration.
  Otherwise, the JCas classes can be migrated in several ways:
  </p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>generating during build</strong></span></span></dt><dd>
        <p>If the project is built by Maven, it's possible the JCas classes are built from the type descriptions, 
          using UIMA's
          Maven JCasGen plugin.  If so, you can just rebuild the project; the JCasGen plugin for V3 generates
          the new JCas classes. 
          </p>
      </dd><dt><span class="term"><span class="strong"><strong>running the migration utility</strong></span></span></dt><dd>
        <p>This is the recommended way if you can't regenerate the classes from the type descriptions.</p>
	      
	      <p>This does the work of migrating and produces new versions of the JCas classes, which
	      need to replace the existing ones.  It allows complex existing JCas classes to migrated, perhaps
	      with developer assistance as needed.  Once done, the application has no migration startup cost.</p>
	      
	      <p>The migration tool is capable of using existing source or compiled JCas classes as input, and 
	      can migrate classes contained within Jars or PEARs.
	      </p>
      </dd><dt><span class="term"><span class="strong"><strong>regenerating the JCas classes using the JCasGen tool</strong></span></span></dt><dd><p>The JCasGen tool (available as a Eclipse or Maven plugin, or a stand-alone application) 
      generates Version 3 JCas classes from the XML descriptors.</p>
      
      <p>This is perfectly adequate for migrating non-customized JCas classes.  When run from the
      UIMA Eclipse plugin for editing XML component descriptors, it will attempt to merge customizations
      with generated code.  However, its approach is not as comprehensive as the migration tool, which parses
      the Java source code.</p></dd></dl></div><p>
  </p></blockquote></div>
  
  <p>Migration of JCas classes is the first step needed to start using UIMA version 3.  
    See the later chapter on migration for details on using the migration tool.
  </p>
  
  <div class="section" title="1.1.&nbsp;What's new in UIMA Java SDK version 3"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="uv3.overview.new">1.1.&nbsp;What's new in UIMA Java SDK version 3</h2></div></div></div>
  
  
  
  <p>The major improvements in version 3 include:
	  </p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Support for arbitrary Java objects, transportable in the CAS</strong></span></span></dt><dd>
	        <p>Support is added to allow users to define additional UIMA Types whose JCas implementation may 
	        include Java objects, with serialization and deserialization performed using normal CAS transportable
	        data.  A following chapter on Custom Java Objects describes this new facility.</p>
	      </dd><dt><span class="term"><span class="strong"><strong>New UIMA built-in types, built using the custom Java object support</strong></span></span></dt><dd>
	        <p>The new support that allows custom serialization of arbitrary Java objects so they can be transported
            in the CAS (above) is used to implement several new built-in UIMA types.  These are implemented in a 
            "lazy" style, avoiding extra computation until needed. 
	        </p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>FSArrayList</strong></span></span></dt><dd>
	              <p>a Java ArrayList of Feature Structures.  The JCas class implements the List API.</p>
	            </dd><dt><span class="term"><span class="strong"><strong>IntegerArrayList</strong></span></span></dt><dd>
	              <p>a variable length int array.  Supports OfInt iterators.</p>
	            </dd><dt><span class="term"><span class="strong"><strong>FSHashSet</strong></span></span></dt><dd>
	              <p>a Java HashSet containing Feature Structures. This JCas class implements the Set API.</p>
	            </dd></dl></div><p>   
	        </p>
	      </dd><dt><span class="term"><span class="strong"><strong>Select framework for accessing Feature Structures</strong></span></span></dt><dd>
          <p>
            A new <span class="emphasis"><em>select framework</em></span> provides a concise way to work with Feature Structure
            data stored in the CAS or other collections.  It is integrated with the Java 8 <span class="emphasis"><em>stream</em></span>
            framework, while providing additional capabilities supported by UIMA, such as the ability to move
            both forwards and backwards while iterating, moving to specific positions, and doing various kinds
            of specialized Annotation selection such as working with Annotations spanned by another annotation.
          </p>
          <p>This user's guide has a chapter devoted to this new framework.
          </p>
        </dd><dt><span class="term"><span class="strong"><strong>Elimination of ConcurrentModificationException while iterating over UIMA indexes</strong></span></span></dt><dd>
          <p>The index and iteration mechanisms are improved; it is now allowed to modify the indexes while
          iterating over them (the iteration will be unaffected by the modification).</p>
          
          <p>Note that the automatic index corruption avoidance introduced in more recent versions of UIMA could
          be automatically removing Feature Structures from indexes and adding them back, if the user was updating
          some Feature of a Feature Structure that was part of an index specification for inclusion or ordering purposes.</p>
          <div class="blockquote"><blockquote class="blockquote"><p>In version 2, you would accomplish this using a two pass scheme:
          Pass 1 would iterate and merely collect the Feature Structures to be updated into a Java collection of some kind.
          Pass 2 would use a plain Java iterator over that collection and modify the Feature Structures and/or the UIMA indexes.
          This is no longer needed in version 3; UIMA iterators use a copy-on-write technique to allow index updating,
          while doing whatever minimal copying is needed to continue iteration over the original index.</p>
          </blockquote></div>
        </dd><dt><span class="term"><span class="strong"><strong>Automatic garbage collection of unreferenced Feature Structures</strong></span></span></dt><dd>
	        <p>This allows creating of temporary Feature Structures, and automatically reclaiming 
	        space resources when they are no longer needed.  In version 2, space was reclaimed only when a 
	        CAS was reset at the end of processing.</p>
	      </dd><dt><span class="term"><span class="strong"><strong>better performance</strong></span></span></dt><dd>
          <p>The internal design details have been extensively reworked to align
          with  recent trends in computer hardware 
          over the last 10-15 years.  In particular, space and time tradeoffs are adjusted in favor of
          using more memory for better locality-of-reference, which improves performance.
          In addition, the many internal algorithms (such as managing Feature Structure indexes) have
          been improved.   
          </p>
          <p>Type system implementations are reused where possible, reducing the footprint in many scaled-out cases.</p>
        </dd><dt><span class="term"><span class="strong"><strong>Backwards compatible</strong></span></span></dt><dd>
	        <p>Version 3 is intended to be binary backwards compatible - the goal is that you should be able to run 
	        existing applications without recompiling them, except for the need to migrate or regenerate 
          any User supplied JCas Classes.  Utilities are provided to help do the necessary JCas migration mostly automatically.</p>
	      </dd><dt><span class="term"><span class="strong"><strong>Integration with Java 8</strong></span></span></dt><dd>
          <p>Version 3 requires Java 8 as the minimum level.  Some of version 3's new facilities, such as the 
          <code class="code">select</code> framework for accessing Feature Structures from CASs or other collections, 
          integrate with the new Java 8 language constructs, such as <code class="code">Streams</code> and <code class="code">Spliterators</code>.</p>
        </dd></dl></div><p>
  </p>
  
  <p>Just to give a small taste of the kinds of things Java 8 integration provides, 
  here's an example of using the new <code class="code">select</code> framework, where the task is to compute
  </p><div class="itemizedlist"><ul class="itemizedlist" type="disc" compact><li class="listitem"><p>a Set of all the found types
  </p><div class="itemizedlist"><ul class="itemizedlist" type="circle" compact><li class="listitem"><p>in a UIMA index</p></li><li class="listitem"><p>under some top-most type "MyType"</p></li><li class="listitem"><p>occurring as Annotations within a particular bounding Annotation</p></li><li class="listitem"><p>that are nonOverlapping</p></li></ul></div><p>
  </p></li></ul></div><p>
  </p>
  
  <p>
  Here is the Java code using the new <code class="code">select</code> framework together with Java 8 streaming functions:
  
  </p><div class="informalexample">  
<pre class="programlisting">Set&lt;Type&gt; foundTypes =
   myIndex.select(MyType.class) 
   .coveredBy(myBoundingAnnotation)
   .nonOverlapping()
   .map(fs -&gt; fs.getType())
   .collect(Collectors.toCollection(TreeSet::new));
</pre>
</div><p>
</p>

<p>
Another example: to collect, by category, the average length of the annotations having that category.
Here we assume that <code class="code">MyType</code> is an <code class="code">Annotation</code> and that it has
a feature called <code class="code">category</code> which returns a String denoting the category:
</p><div class="informalexample">  
<pre class="programlisting">Map&lt;String, Double&gt; freqByCategory =
   myIndex.select(MyType.class)
   .collect(Collectors
     .groupingBy(MyType::getCategory,
                 Collectors.averagingDouble(f -&gt; 
                   (double)(f.getEnd() - f.getBegin()))));
</pre> 
</div><p>
</p>
</div>

<div class="section" title="1.2.&nbsp;Java 8 is required"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="uv3.overview.java8">1.2.&nbsp;Java 8 is required</h2></div></div></div>
  
  <p>The UIMA Java SDK Version 3 requires Java 8 or later.</p>
</div>      
</div>
  <div class="chapter" title="Chapter&nbsp;2.&nbsp;Backwards Compatibility" id="uv3.backwards_compatibility"><div class="titlepage"><div><div><h2 class="title">Chapter&nbsp;2.&nbsp;Backwards Compatibility</h2></div></div></div>
  
  
  
  <p>Because users have made substantial investment in developing
  applications using the UIMA framework, a goal is to protect this investment, by enabling
  Annotators and applications developed under previous versions to be able to be used in 
  subsequent versions of the framework.</p>
  
  <p>To this end, version 3 is designed to be backwards compatible, 
  except for needing a new set of JCas classes (if these were
  previously being used).  The creation of this new set of JCas classes is mostly automated via a 
  migration tool that handles converting the existing JCas classes, described in a later chapter.
  </p>
  
  <div class="section" title="2.1.&nbsp;JCas and non-JCas APIs"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="uv3.backwards_compatibility.jcas">2.1.&nbsp;JCas and non-JCas APIs</h2></div></div></div>  
    

    <p>The JCas class changes include no longer needing or using the <code class="code">Xyz_Type</code>
      sister classes for each main JCas class.  User code is unlikely to access these sister classes.
      The JCas API method to access this sister class now throws a UnsupportedOperation exception.
    </p>
    
    <p>
      New internal-use methods and fields have been added to the JCas classes.  The 
      names for these have been carefully designed to reduce the likelihood of collision with previously
      existing user code names; the usual technique is to start the names with a leading underscore character.
      Users should consider these methods as internal use and subject to change with new releases.
    </p>
    
    <p>The non-JCas Java cover classes for the built-in UIMA types remain, for backwards compatibility.
      So, if you have code that casts a Feature Structure instance to AnnotationImpl (a now deprecated 
      version 2 non-JCas Java cover class), that will continue to work.
      
      </p>
  </div>
  
  
  <div class="section" title="2.2.&nbsp;Serialization forms"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="uv3.backwards_compatibility.serialization">2.2.&nbsp;Serialization forms</h2></div></div></div>  
	  
	  
	  <p>
	  The backwards compatibility extends to the serialized forms, so that it should be
	  possible to have a UIMA-AS services working with a client, where the client is a version 3 instance, but the
	  server is still a version 2 (or vice versa).</p>
	  
	  <p>Some formats like Binary and BinaryCompressedForm4 require the type systems match exactly.
	  Version 3 adds some new built-in types, so the type systems won't match exactly; an accommodation is made
	  when the version 3 deserialization detects that the serialized CAS was serialized with version 2, that
	  enables version 3 to load version 2 serialized CASs, even for binary formats.  A planned extension for 
	  UIMA-AS will allow version 3 clients to detect when a service is running version 2 code, and have the 
	  serialization altered to be compatible with version 2 (provided that the new, built-in, types are not being used).
	  </p>
	  
	  <div class="section" title="2.2.1.&nbsp;Delta CAS Version 2 Binary deserialization not supported"><div class="titlepage"><div><div><h3 class="title" id="uv3.backwards_compatibility.serialization.deltas">2.2.1.&nbsp;Delta CAS Version 2 Binary deserialization not supported</h3></div></div></div>  
	    
	    
	    <p>The binary serialization forms, including Compressed Binary Form 4, build an
	      internal model of the v2 CAS in order to be able to deserialize v2 generated
	      versions.  For delta CAS, this model cannot be accurately built, because version 3
	      excludes from the model all unreachable Feature Structures, so in most cases it
	      won't match the version 2 layout.  
	    </p>
	    
	    <p>Version 3 will throw an exception if delta CAS deserialization of a version 2
	      delta CAS is attempted.
	    </p>
    </div>
	  
  </div>
  
  <div class="section" title="2.3.&nbsp;APIs for creating and modifying Feature Structures"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="uv3.backards_compatibility.low_level_apis">2.3.&nbsp;APIs for creating and modifying Feature Structures</h2></div></div></div>
    
    
    <p>There are 3 sets of APIs for creating and modifying Feature Structures.
    </p><div class="itemizedlist"><ul class="itemizedlist" type="disc" compact><li class="listitem">
        <p>Using the JCas classes</p>
      </li><li class="listitem">
        <p>Using the normal CAS interface with Type and Feature objects</p>
      </li><li class="listitem">
        <p>Using the low level CAS interface with int codes for Types and Features</p>
      </li></ul></div><p>
    </p>
    
    <p>Version 3 retains all 3 sets, to enable backward compatibility.</p>
    <p>The low level CAS interface was originally provided to enable a extra-high-performance
      (but without type safety checks) mode.  In Version 3, this mode is actually somewhat slower than the others,
      and no longer has any advantages.      
    </p>
    <p>Using the low level CAS interface also blocks one of the new features of Version 3 - namely, automatic
    garbage collection of unreachable Feature Structures.  This is because creating a Feature Structure using the
    low level API creates the Java object for that Feature Structure, but returns an "int" handle to it.  
    In order to be able to find the Feature Structure, given that int handle, an entry is made in an internal map.
    This map holds a reference to this Feature Structure, which prevents it from being garbage collected (until of coursse,
    the CAS is reset).
    </p>
    
    <p>The normal CAS APIs allow writing Annotators where the type system is unknown at compile time; these 
    are fully supported.</p>    
    
  </div>
  
  <div class="section" title="2.4.&nbsp;PEAR support"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="uv3.backards_compatibility.PEARs">2.4.&nbsp;PEAR support</h2></div></div></div>
       
    
    <p>Pears are supported in Version 3.  If they use JCas, their JCas classes need to be migrated.
    </p>
    
    <p>When a PEAR contains a JCas class definition different from the surrounding non-PEAR context,
    each Feature Structure instance within that PEAR has a lazily-created "dual" representation using
    the PEAR's JCas class definition.  The UIMA framework things storing references to Feature Structures
    are modified to store the non-PEAR version of the Feature Structure, but to return (when in 
    a particular PEAR component in the pipeline) the dual version.  The intent is that this be 
    "invisible" to the PEAR's annotators.  Both of these representations share the same 
    underlying CAS data, so modifications to one are seen in the other.
    </p>
    
    <p>If a user builds code that holds onto Feature Structure references, outside of 
    annotators (e.g., as a shared External Resource), and sets and references these from
    both outside and inside one (or more) PEARs, they should adopt a strategy of storing
    the non-PEAR form.  To get the non-PEAR form from a Feature Structure, use the method
    <code class="code">myFeatureStructure._maybeGetBaseForPearFs()</code>.
    </p>
    
    <div class="blockquote"><blockquote class="blockquote"><p>Similarly, if code running in an Annotator within a PEAR wants to
    work with a Feature Structure extracted from non-UIMA managed data outside of annotators
    (e.g., such as a shared External Resource) where the form stored is the non-PEAR form,
    you can convert to the PEAR form using the method 
    <code class="code">myFeatureStructure.__maybeGetPearFs()</code>.  This method checks to see if
    the processing context of the pipeline is currently within a PEAR, and if that PEAR has
    a different definition for that JCas class, and if so, it returns that version of the
    Feature Structure. 
    </p></blockquote></div>
    
    <p>The new Java Object support does not support multiple, 
      different JCas class definitions for the same 
      UIMA Type, inside and outside of the PEAR context.  
      If this is detected, a runtime exception is thrown.
    </p>
  </div>
  
  <div class="section" title="2.5.&nbsp;toString()"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="uv3.backards_compatibility.toString">2.5.&nbsp;toString()</h2></div></div></div>
       
    
    <p>
      The formatting of various UIMA artifacts, including Feature Structures,
      has changed somewhat, to be more informative.  This may impact 
      situations such as testing, where the exact string representations
      are being compared.
    </p>
  </div>
  
  <div class="section" title="2.6.&nbsp;Type System sharing"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="uv3.backards_compatibility.typesystem_sharing">2.6.&nbsp;Type System sharing</h2></div></div></div>
       
    
    <p>Type System definitions are shared when they are equal.  After type systems 
    have been built up from type definitions, and are committed, a check is made to see if an
    identical type system already exists.  This is often the case when a UIMA application is
    scaling up by adding multiple pipelines, all using the same type system.  
    </p>
    
    <p>If an identical type system is already created, then the commit operation returns 
    the already created one, and the one just built is discarded.  Normally, this is not an issue.
    However, some application code (for example, test cases) may construct type systems
    programmatically, and along the way save references to defined types and features.  These
    references can then become invalid when the type system is created and perhaps replaced with
    an already existing one.</p>
    
    <p>Application code may code around this by re-acquiring references to type and feature
    objects, if the type system returned from <code class="code">commit</code> is not identical (==) to the
    one being committed.</p>
  </div>
  
  <div class="section" title="2.7.&nbsp;Some checks moved to native Java"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="uv3.backards_compatibility.checking">2.7.&nbsp;Some checks moved to native Java</h2></div></div></div>
       
    
    <p>In the interest of performance, some duplicate checks, such as whether an array index is within bounds, 
    have been removed from UIMA when they are already being checked by the underlying Java runtime.  
    This has affected some of the internal APIs, such as the JCas's <code class="code">checkArrayBounds</code>
    which was removed because it was no longer being used.
    </p>
  </div>
  
  <div class="section" title="2.8.&nbsp;Some class hierarchies have been modified"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="uv3.backards_compatibility.class_hierarchy">2.8.&nbsp;Some class hierarchies have been modified</h2></div></div></div>
       
    
    <p>The various JCas Classes implementing the built-ins for arrays have some additional
      interfaces added, grouping them into <code class="code">CommonPrimitiveArray</code> or 
      <code class="code">CommonArray</code>.  These changes are internal, and should not affect users.
    </p>
  </div>
  </div>
  <div class="chapter" title="Chapter&nbsp;3.&nbsp;New and Extended APIs" id="uv3.new_extended_apis"><div class="titlepage"><div><div><h2 class="title">Chapter&nbsp;3.&nbsp;New and Extended APIs</h2></div></div></div>
  
  
  
  <div class="section" title="3.1.&nbsp;JCas additional static fields"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="uv3.new_extended_apis.jcas_static_fields">3.1.&nbsp;JCas additional static fields</h2></div></div></div>
    
    
    <p>(Also in UIMA Version 2 after release 2.10.0) Static final string fields are declared for each JCas cover class
      and for each feature that is part of that UIMA type.  The fields look like
      this example, taken from the Sofa class:
      </p><pre class="programlisting">public final static String _TypeName = "org.apache.uima.jcas.cas.Sofa";
public final static String _FeatName_sofaNum    = "sofaNum";
public final static String _FeatName_sofaID     = "sofaID";
public final static String _FeatName_mimeType   = "mimeType";
public final static String _FeatName_sofaArray  = "sofaArray";
public final static String _FeatName_sofaString = "sofaString";
public final static String _FeatName_sofaURI    = "sofaURI";</pre><p>
       Each string has a generated name corresponding to the name of the type or the feature, and
       a string value constant which of the type or feature name. These can be useful in
       Java Annotations.
    </p>
  </div>
  
  <div class="section" title="3.2.&nbsp;Java 8 integrations"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="uv3.new_extended_apis.java8">3.2.&nbsp;Java 8 integrations</h2></div></div></div>
    
    
    <p>Several of the the JCas cover classes provide additional
      integrations with Java 8 facilities.</p>
      
    <div class="section" title="3.2.1.&nbsp;Built-in UIMA Arrays and Lists integration with Java 8"><div class="titlepage"><div><div><h3 class="title" id="uv3.new_extended_apis.java8.lists">3.2.1.&nbsp;Built-in UIMA Arrays and Lists integration with Java 8</h3></div></div></div>
      
      
      <p>The <code class="code">iterator()</code> methods for <code class="code">IntegerList
        IntegerArrayList, IntegerArray, 
        DoubleArray,</code> and <code class="code">LongArray</code> return
        an <code class="code">OfInt / OfDouble / OfLong</code> instances.  These are a subtype of 
        <code class="code">Iterator</code> with an additional methods nextInt / nextLong / nextDouble which avoid the
        boxing of the normal iterator.
      </p>
      
      <p>The built-in collection types support a <code class="code">stream()</code> method
      returning a Stream or a type-specialized sub interface of Stream for primitives 
      (IntStream, LongStream, DoubleStream) 
      over the objects in the collection.</p>
      
      <p>The new <code class="code">select</code> framework supports stream operations; see the "select" chapter for details.
      </p> 
           
    </div>
  </div>
  
  <div class="section" title="3.3.&nbsp;UIMA FSIterators improvements"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="uv3.new_extended_apis.fsiterator_implements_list">3.3.&nbsp;UIMA FSIterators improvements</h2></div></div></div>
    
    
    <p>To enable more seamless integration with popular Java idioms, the UIMA iterators for iterating 
    over UIMA Indexes (the FSIterator interface) now implements the Java ListIterator Interface.
    </p>
    
    <p>The iterators over indexes no longer throw concurrent modification exceptions if the index is modified
    while it is being iterated over.  Instead, the iterators use a lazily-created copy-on-write approach that, when
    some portion of the index is updated, prior to the update, copies the original state of that portion, and continues
    to iterate over that.  While this is helpful if you are explicitly modifying the indexes in a loop, it 
    can be especially helpful when modifying Feature Structures as you iterate, because
    the UIMA support for detecting and avoiding possible index corruption if you modify some feature being used by 
    some index as a key, is automatically (under the covers) temporarily removing the Feature Structure from indexes, 
    doing the modification, and then adding it back.
    </p>
    
    <p>Similarly to version 2, iterator methods <code class="code">moveToFirst, moveToLast, and moveTo(a_positioning_Feature_Structure)</code>
      "reset" the iterator to be able to "see" the current state of the indexes.  This corresponds to resetting the
      concurrent modification detection sensing in version 2, when these methods are used.
    </p>
    
    <p>Note that the phrase <span class="emphasis"><em>Concurrent Modification</em></span> is being used here in a single threading
      context, to mean that within a single thread, while an iterator is active, some modifications are being done
      to the indexes.  UIMA does not support multi-threaded write access to the CAS; it does support multi-threaded
      read access to a set of CAS Views, concurrent with one thread having write access (to different views).</p>
  </div>

  <div class="section" title="3.4.&nbsp;New Select API"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="uv3.new_extended_apis.select">3.4.&nbsp;New Select API</h2></div></div></div>
    
    
    <p>A versatile new Select framework for accessing and acting on Feature Structures 
    selected from the CAS or from Indexes or from other collection objects is documented in
    a separate chapter.  This API is integrated with Java 8's Stream facility.
    </p>
  </div>
  
  <div class="section" title="3.5.&nbsp;New custom Java objects in the CAS framework"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="uv3.new_extended_apis.custom_java_objects">3.5.&nbsp;New custom Java objects in the CAS framework</h2></div></div></div>
    
    
    <p>There is a new framework that supports allowing you to add your own custom Java objects as
      objects transportable in the CAS.  The following chapter describes this facility, and some new
      semi-built-in types that make use of it.  
    </p>
  </div>  
  
  <div class="section" title="3.6.&nbsp;Built-in lists and arrays"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="uv3.new_extended_apis.lists_and_arrays">3.6.&nbsp;Built-in lists and arrays</h2></div></div></div>
    
    
    <p>
      A new set of static methods on UIMA built-in lists and arrays, <code class="code">create(jcas, array_source)</code>
      is available; these take a Java array of items, and creates
      a corresponding UIMA built-in list or array populated with items from the array_source.
    </p>
    
    <p>For lists, new static methods <code class="code">getEmptyList(JCas jcas)</code> on each of the 4
      kinds of built-in lists (FS, Integer, Float, and String) retrieve a 
      shared, common instance of the EmptyXxxList for a CAS.
    </p>
    
    <p>For lists, a new <code class="code">push(item)</code> API on an existing list node creates a new
      non-empty node, sets its head to <code class="code">item</code> and its tail to the existing list node.
      This allows easy construction of a list in backwards order.
      There is also a <code class="code">pushNode()</code> which just creates and links in a new node to the front of the list.
      And finally, there's a <code class="code">createNonEmptyNode()</code>, which just creates a node of the 
      same type, in the same CAS, without linking it.</p>
      
    <div class="section" title="3.6.1.&nbsp;Built-in lists and arrays have common super classes / interfaces"><div class="titlepage"><div><div><h3 class="title" id="uv3.new_extended_apis.reorganized.lists_and_arrays">3.6.1.&nbsp;Built-in lists and arrays have common super classes / interfaces</h3></div></div></div>
      
        <p>Some methods common to multiple implements were moved to the super classes,
          some classes were made abstract (to prevent them from being instantiated, which would be an error).
          For arrays, a new method common to all arrays, <code class="code">copyValuesFrom()</code> copies values from arrays of the same type.
        </p>
    </div> 
  </div>     
  
  <div class="section" title="3.7.&nbsp;Annotation comparator methods"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="uv3.new_extended_apis.annotation">3.7.&nbsp;Annotation comparator methods</h2></div></div></div>
    
    
    <p>The built-in type Annotation has 4 new methods to allow comparing two annotations.
      The first method (<code class="code">compareAnnotation</code>) uses
      the standard annotation comparator (two keys: begin (ascending) and end (descending)). 
      A second method (<code class="code">compareAnnotation(other, linear_type_order)</code>) adds a 3rd comparison,
      used if the Annotations compare equal), which uses a linear_type_order to compare the two types.
      Another two methods extend these two methods with an additional key - the Annotation's ID,
      used only if the previous comparsions are all equal.
      All of these return the standard Java compare result allowing discrimination between equal, &gt;, and &lt;.
      </p>
  </div>

  <div class="section" title="3.8.&nbsp;Reorganized APIs"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="uv3.new_extended_apis.reorganized">3.8.&nbsp;Reorganized APIs</h2></div></div></div>
    
    
    <p>Some APIs were reorganized.  Some of the reorganizations include altering the super class
      and implements hierarchies, making some classes abstract, making use of Java 8's new
      <code class="code">default</code> mechanisms to supply default implementations in interfaces, 
      and moving methods to more common places.  Users of the non-internal UIMA APIs
      should not be affected by these reorganizations.
    </p>

    <p>As an example, version 2 had two different Java objects representing particular Feature Structures, such as
    "Annotation".  One was used (<code class="code">org.apache.uima.jcas.tcas.Annotation</code>) if the JCas was enabled; 
    the other (<code class="code">org.apache.uima.cas.impl.AnnotationImpl</code>)otherwise.  In version 3, there's only one implementation;
    the other (AnnotationImpl) is converted to an interface.  Annotation now "implements AnnotationImpl.</p>
  </div>
  
  <div class="section" title="3.9.&nbsp;Other changes"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="uv3.new_extended_apis.other">3.9.&nbsp;Other changes</h2></div></div></div>
    
    
    <p>The utility class <code class="code">org.apache.uima.util.FileUtils</code> has a new method
      <code class="code">writeToFile(path, string)</code>, which efficiently writes a string using UTF-8 encoding to 
      <code class="code">path</code>.
    </p>
    
    <p>Many error messages were changed or added, causing changes to localization classes.
      For coding efficiency, some of the structure of the internal error reporting calls was changed
      to make use of Java's variable number of arguments syntax.</p>
  </div> 
   
</div>
  <div class="chapter" title="Chapter&nbsp;4.&nbsp;The select framework for working with CAS data" id="uv3.select"><div class="titlepage"><div><div><h2 class="title">Chapter&nbsp;4.&nbsp;The select framework for working with CAS data</h2></div></div></div>
  
  
  
  <p>The <span class="emphasis"><em>select</em></span> framework provides a concise way to work with
  Feature Structure data stored in the CAS. It is integrated with the Java 8 <span class="emphasis"><em>stream</em></span>
  framework, and provides additional capabilities supported by the underlying 
  UIMA framework, including the ability to move both forwards and backwards while iterating,
  moving to specific positions, and doing various kinds of specialized Annotation 
  selection such as working with Annotations spanned by another annotation (think of a Paragraph
  annotation, and the Sentences or Tokens within that).
  </p>
  
  <p>There are 3 main parts to this framework:</p>
  
  <div class="itemizedlist"><ul class="itemizedlist" type="disc" compact><li class="listitem">
      <p>The source
      </p>
    </li><li class="listitem">
      <p>what to select, ordering
      </p>
    </li><li class="listitem">
      <p>what to do
      </p>
    </li></ul></div>
  
  <div class="figure"><a name="uv3.select.big_picture"></a><div class="figure-contents">
          
          <div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="564"><tr><td><img src="images/version_3_users_guide/select/select_big_pic.png" width="564" alt="Select composed of sources, what to select, and what to do"></td></tr></table></div>
        </div><p class="title"><b>Figure&nbsp;4.1.&nbsp;Select - the big picture</b></p></div><br class="figure-break">
  
  <p>These are described in code using a builder pattern to specify the many options and parameters.
  Some of the very common parameters are also available as positional arguments in some contexts.
  Most of the variations are defaulted so that in the common use cases, they may be omitted.
  </p>
  
  <div class="section" title="4.1.&nbsp;Select's use of the builder pattern"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="uv3.select.builder_pattern">4.1.&nbsp;Select's use of the builder pattern</h2></div></div></div>
    
    
    <p>The various options and specifications are specified using the builder pattern.
    Each specification has a name, which is a Java method name, sometimes having further parameters.
    These methods return an instance of SelectFSs; this instance is updated by each builder method.
    </p>
    
    <p>A common approach is to chain these methods together.  When this is done, each subsequent method
    updates the SelectFSs instance.  This means that the last method in case there are 
    multiple method calls specifying the same specification is the one that is used.
    </p>
    
    <p>For example,
    </p><pre class="programlisting">a_cas.select().typePriority(true).typePriority(false).typePriority(true)</pre><p>
    would configure the select to be using typePriority (described later).</p>
    
    <p>Some parameters are specified as positional parameters, for example, a UIMA Type, or a starting position or
    shift-offset.</p>
  </div>
  
  <div class="section" title="4.2.&nbsp;Sources of Feature Structures"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="uv3.select.sources">4.2.&nbsp;Sources of Feature Structures</h2></div></div></div>
    
    
    <p>Feature Structures are kept in the CAS, and may be accessed using UIMA Indexes.
    Note that not all Feature Structures in the CAS are in the UIMA indexes; only those that the 
    user had "added to the indexes" are. Feature Structures not in the indexes are not 
    included when using the CAS as the source for the select framework.</p>
    
    <p>  
    Feature Structures may, additionally, be kept in <code class="code">FSArrays</code>, <code class="code">FSLists</code>,
    and many additional collection-style objects that implement <code class="code">SelectViaCopyToArray</code> interface.
    This interface is implemented by the new built-in types <code class="code">FSArrayList</code> and <code class="code">FSHashSet</code>;
    user-defined JCas classes for user types may also choose to implement this.
    All of these sources may be used with <code class="code">select</code>.</p>
    
    <div class="figure"><a name="uv3.select.source_type"></a><div class="figure-contents">
      
      <div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="545"><tr><td><img src="images/version_3_users_guide/select/select_source_type.png" width="545" alt="Sources have select method, which has optional type argument"></td></tr></table></div>
    </div><p class="title"><b>Figure&nbsp;4.2.&nbsp;select method with type</b></p></div><br class="figure-break">
  
    <p>For CAS sources, if Views are being used, there is a separate set of indexes per CAS view.
    When there are multiple views, only one view's set of indexed Feature Structures is accessed - the
    view implied by the CAS being used.  Note that there is a way to specify aggregating over all views; see
    <code class="code">allViews</code> described later.</p>
    
    <p>For CAS sources, users may specify all Feature Structures in a view, or restrict this in two ways:
    </p><div class="itemizedlist"><ul class="itemizedlist" type="disc" compact><li class="listitem">
        <p>specifying an index: Users may define their own indexes, in additional to the built in ones, and 
        then specify which index to use.
        </p>
      </li><li class="listitem">
        <p>specifying a type: Only Feature Structures of this type (or its subtypes) are included.
        </p>
      </li></ul></div><p>
    </p>
    
    <p>It is possible to specify both of these, using the form <code class="code">myIndex.select(myType)</code>; 
        in that case the type must be the type or a subtype of
        the index's top most type.
    </p>
        
    <p>If no index is specified, the default is 
    </p><div class="itemizedlist"><ul class="itemizedlist" type="disc" compact><li class="listitem">
        <p>to use all Feature Structures in a CAS View, or</p>
      </li><li class="listitem">
        <p>to use all Feature Structures in the view's AnnotationIndex,
        if the selection and ordering specifications require an AnnotationIndex.</p>
      </li></ul></div>
    
    <p>Note that the non-CAS collection sources (e.g. the FSArray and FSList sources are considered ordered, but non-sorted, 
          and therefore cannot be used for an operations which require a sorted order.</p>
      
    <p>There are 4 kinds of sources of Feature Structures supported:</p>

    <div class="itemizedlist"><ul class="itemizedlist" type="disc" compact><li class="listitem">
	      <p>a CAS view: all the FSs that were added to the indexes for this view.
	      </p>
	    </li><li class="listitem">
	      <p>an Index over a CAS view. Note that the AnnotationIndex is often implied by other 
	            <code class="code">select</code> specifications, so it is often not necessary to supply this.
	      </p>
	    </li><li class="listitem">
	      <p>Feature Structures from a built-in UIMA Collection instance, such as instances of the types
	      <code class="code">FSArray, FSArrayList, FSHashSet,</code> etc.
	      </p>
	    </li><li class="listitem">
	      <p>Feature Structures from a user-defined UIMA Collection instance.
	      </p>
	    </li></ul></div>
	  
    <p>UIMA Collection sources have somewhat limited configurability,
    because they are considered non-sorted, 
    and therefore cannot be used for an operations which require a sorted order, such as
    the various bounding selections (e.g. <code class="code">coveredBy</code>) 
    or positioning operations (e.g. <code class="code">startAt</code>).</p>

	  <p>Each of these sources has a new API method, <code class="code">select(...)</code>, which initiates the select specification.
	  The select method can take an optional parameter, specifying the UIMA type to return.
	  If supplied, the type must must be the type or subtype of the index 
	  (if one is specified or implied); it serves to further restrict the types selected beyond whatever the 
	  index (if specified) has as its top-most type.</p>
	    
  <div class="section" title="4.2.1.&nbsp;Use of Type in selection of sources"><div class="titlepage"><div><div><h3 class="title" id="uv3.select.sources.type">4.2.1.&nbsp;Use of Type in selection of sources</h3></div></div></div>
    
	  <p>
	  The optional type argument for <code class="code">select(...)</code> specifies a UIMA type.  This restricts the Feature Structures
	  to just those of the specified type or any of its subtypes.  If omitted, if an index is used as a source, 
	  its type specification is used; otherwise all types are included.</p>
	  
	  <p>Type specifications may be specified in multiple ways.  
	  The best practice, if you have a JCas cover class
	  defined for the type, is to use the form <code class="code">MyJCasClass.class</code>.  This has the advantage of setting the 
	  expected generic type of the select to that Java type.
	  </p>
	  
	  <p>The type may also be specified by using the actual UIMA type instance (useful if not using the 
	  JCas), using a fully qualified type name as a string, or using the JCas class static <code class="code">type</code> field.</p>
  </div>
  
  <div class="section" title="4.2.2.&nbsp;Sources and generic typing"><div class="titlepage"><div><div><h3 class="title" id="uv3.select.sources.generics">4.2.2.&nbsp;Sources and generic typing</h3></div></div></div>
    
    <p>The select method results in a generically typed object, which is used to have subsequent operations
    make use of the generic type, which may reduce the need for casting.</p>
    
    <p>The generic type can come from arguments or from where a value is being assigned, 
    if that target has a generic type.  This latter source is only partially available in Java, as it does not
    propagate past the first object in a chain of calls; this becomes a problem when using <code class="code">select</code> with
    generically typed index variables.
    </p>
    
    <p>There is also a static version of the <code class="code">select</code> method which takes a 
    generically typed index as an argument.</p>
    <div class="informalexample">    
    <pre class="programlisting">// this works
// the generic type for Token is passed as an argument to select
FSIterator&lt;Token&gt; token_it = cas.select(Token.class).fsIterator();

FSIndex&lt;Token&gt; token_index = ... ; // generically typed

// this next fails because the
// Token generic type from the index variable being assigned
// doesn't get passed to the select().
FSIterator&lt;Token&gt; token_iterator = token_index.select().fsIterator();

// You can overcome this in two ways:
// pass in the type as an argument to select
// using the JCas cover type.  
FSIterator&lt;Token&gt; token_iterator = 
    token_index.select(Token.class).fsIterator();

// You can also use the static form of select
// to avoid repeating the type information
FSIterator&lt;Token&gt; token_iterator = 
    SelectFSs.select(token_index).fsIterator();

// Finally, you can also explicitly set the generic type 
// that select() should use, like a special kind of type cast, like this:
FSIterator&lt;Token&gt; token_iterator =
    token_index.&lt;Token&gt;select().fsIterator();
</pre>
</div>
        
    <p>Note: the static <code class="code">select</code> method may be statically imported into code that uses it, to avoid repeatedly 
    qualifying this with its class, <code class="code">SelectFSs</code>.</p>
    
  <p>Any specification of an index may be further restricted to just a subType (including that
  subtype's subtypes, if any) of that index's type.
  For example, an AnnotationIndex may be specialized to just Sentences (and their subtypes):
  </p><pre class="programlisting">FSIterator&lt;Token&gt; token_iterator = 
    annotation_index.select(Token.class).fsIterator();
</pre><p>
  </p>  
  </div>

  </div>  

  <div class="section" title="4.3.&nbsp;Selection and Ordering"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="uv3.select.selection_and_ordering">4.3.&nbsp;Selection and Ordering</h2></div></div></div>
    
    
    <p>There are four sets of sub-selection and ordering specifications, grouped 
    by what they apply to:
	    </p><div class="itemizedlist"><ul class="itemizedlist" type="disc" compact><li class="listitem">
		      <p>all sources 
		      </p>
		    </li><li class="listitem">
		      <p>Indexes or FSArrays or FSLists
		      </p>
		    </li><li class="listitem">
		      <p>Ordered Indexes
		      </p>
		    </li><li class="listitem">
		      <p>The Annotation Index
		      </p>
		    </li></ul></div><p>  
    </p>
    
    <p>With some exceptions, configuration items to the left also apply to items on the right.
    </p>

    <p>When the same configuration item is specified multiple times, 
          the last one specified is the one that is used.</p>

    <div class="figure"><a name="uv3.select.fig.selection_and_ordering"></a><div class="figure-contents">
      
      <div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="545"><tr><td><img src="images/version_3_users_guide/select/select_selection_and_ordering.png" width="545" alt="Selection and Ordering configuration"></td></tr></table></div>
    </div><p class="title"><b>Figure&nbsp;4.3.&nbsp;Selection and Ordering</b></p></div><br class="figure-break">
        
    <div class="section" title="4.3.1.&nbsp;Boolean properties"><div class="titlepage"><div><div><h3 class="title" id="uv3.select.boolean_properties">4.3.1.&nbsp;Boolean properties</h3></div></div></div>
      
	    <p>Many configuration items specify a boolean property.  These are named so the default (if you don't specify them)
	    is generally what is desired, and the specification of the method with null parameter switches the property to the 
	    other (non-default) value.</p>
	    
	    <p>For example, normally, when working with bounded limits within Annotation Indexes, type
	    priorities are ignored when computing the bound positions.  
	    Specifying typePriority() says to use type priorities.</p>
	    
	    <p>Additionally, the boolean configuration methods have an optional form where they take a boolean value; 
	    true sets the property.  
	    So, for example typePriority(true) is equivalent to typePriority(), and typePriority(false)
	    is equivalent to omitting this configuration.</p>
    </div>
        
    <div class="section" title="4.3.2.&nbsp;Configuration for any source"><div class="titlepage"><div><div><h3 class="title" id="uv3.select.any_source">4.3.2.&nbsp;Configuration for any source</h3></div></div></div>
      
      
      <div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>limit</strong></span></span></dt><dd>
            <p>a limit to the number of Feature Structures that will be produced or iterated over.
            </p>
          </dd><dt><span class="term"><span class="strong"><strong>nullOk</strong></span></span></dt><dd>
            <p>changes the behavior for some terminal_form actions, which would otherwise
      throw an exception if a null result happened.
            </p>
          </dd></dl></div>
      
    </div>
    
    <div class="section" title="4.3.3.&nbsp;Configuration for any index"><div class="titlepage"><div><div><h3 class="title" id="uv3.select.any_index">4.3.3.&nbsp;Configuration for any index</h3></div></div></div>
      
    
      <div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>allViews</strong></span></span></dt><dd>
            <p>Normally, only Feature Structures belonging to the particular CAS view are included in the selection. 
			      If you want, instead, to include Feature Structures from all views, you can specify
			      <code class="code">allViews()</code>.
			      </p>
			      
			      <p>When this is specified, it acts 
				          as an aggregation of the underlying selections, one per view in the CAS.
				          The ordering among the views is arbitrary; the ordering within each view
				          is the same as if this setting wasn't in force.
				          Because of this implementation, the items in the selection may not be unique -- 
				          Feature Structures in the underlying selections that are in multiple views will appear multiple times.
            </p>
          </dd></dl></div>

    </div>
    
    <div class="section" title="4.3.4.&nbsp;Configuration for sort-ordered indexes"><div class="titlepage"><div><div><h3 class="title" id="uv3.select.ordered_index">4.3.4.&nbsp;Configuration for sort-ordered indexes</h3></div></div></div>
      

      <p>When an index is sort-ordered, there are additional capabilities that can be configured, in particular positioning
        to particular Feature Structures, and running various iterations backwards.
      </p>

      <div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>orderNotNeeded</strong></span></span></dt><dd>
            <p>relaxes any iteration by allowing it to proceed in an unordered manner.  Specifying
				      this may improve performance in some cases.  When this is specified, 
				      the current implementation skips the work of keeping multiple
				      iterators for a type and all of its subtypes in the proper synchronization.
            </p>
          </dd><dt><span class="term"><span class="emphasis"></span>startAt</span></dt><dd>
            <p>position the starting point of any iteration.  
			        <code class="code">startAt(xxx)</code> takes two forms, each of which has, in turn 2 subforms.  
			        The form using <code class="code">begin, end</code> is only valid for Annotation Indexes.
			        </p><pre class="programlisting">startAt(fs);          // fs specifies a feature structure 
                      // indicating the starting position
             
startAt(fs, shifted); // same as above, but after positioning, 
                      // shift to the right or left by the shift 
                      // amount which can be positive or negative
             

// the next two forms are only valid for AnnotationIndex sources
   
startAt(begin, end);  // start at the position indicated by begin/end

startAt(begin, end, shifted) // same as above, 
                             // but with a subsequent shift.
                             // which can be positive or negative
</pre><p>
            </p>
          </dd><dt><span class="term"><span class="strong"><strong>backwards</strong></span></span></dt><dd>
            <p>specifies a backwards order (from last to first position) for
            subsequent operations
            </p>
          </dd></dl></div>
    </div>
  
    <div class="section" title="4.3.5.&nbsp;Bounded sub-selection within an Annotation Index"><div class="titlepage"><div><div><h3 class="title" id="uv3.select.annot.subselect">4.3.5.&nbsp;Bounded sub-selection within an Annotation Index</h3></div></div></div>
      
      
      <p>When selecting Annotations, frequently you may want to select only those which have
      a relation to a bounding Annotation.  A commonly done selection is to select all Annotations 
      (of a particular type) within the span of another, bounding Annotation, such as all <code class="code">Tokens</code>
      within a <code class="code">Sentence</code>.</p>
      
      <p>There are four varieties of sub-selection within an annotation index.  They all are based on a 
      bounding Annotation (except the <code class="code">between</code> which is based on two bounding Annotations).
      </p>
      
      <p>The bounding Annotations are specified using either a Annotation (or a subtype), or
      by specifying the begin and end offsets that would be for the bounding Annotation.</p>
      
      <p>Leaving aside <code class="code">between</code> as a special case, the bounding Annotation's 
      <code class="code">begin</code> and <code class="code">end</code>
      (and sometimes, its <code class="code">type</code>) is used to specify where an iteration would start, where it would end, 
      and possibly, which Annotations within those bounds would be filtered out.  There are many variations
      possible; these are described in the next section.</p>
      
      <p>The returned Annotations exclude the one(s) which are <code class="code">equal</code> to the bounding FS.  
      There are several 
      variations of how this <code class="code">equal</code> test is done, discussed in the next section.</p>
            
      <div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>coveredBy</strong></span></span></dt><dd>
            <p>iterates over Annotations within the bound
            </p>
          </dd><dt><span class="term"><span class="strong"><strong>covering</strong></span></span></dt><dd>
            <p>iterates over Annotations that span (or are equal to) the bound.
            </p>
          </dd><dt><span class="term"><span class="strong"><strong>at</strong></span></span></dt><dd>
            <p>iterates over Annotations that have the same span (i.e., begin and end) as the bound.
            </p>
          </dd><dt><span class="term"><span class="strong"><strong>between</strong></span></span></dt><dd>
            <p>uses two Annotations, and returns Annotations that are in between
				      the two bounds.  If the bounds are backwards, then they are automatically used in reverse order.
				      The meaning of between is that an included Annotation's begin has to be &gt;= the earlier bound's <code class="code">end</code>, 
				      and the Annotation's end has to be &lt;= the later bound's <code class="code">begin</code>.
            </p>
          </dd></dl></div>
    </div>
    
    <div class="section" title="4.3.6.&nbsp;Variations in Bounded sub-selection within an Annotation Index"><div class="titlepage"><div><div><h3 class="title" id="uv3.select.annot.variations">4.3.6.&nbsp;Variations in Bounded sub-selection within an Annotation Index</h3></div></div></div>
      
      
      <p>There are five variations you can specify.  
      Two affect how the starting bound position is set; 
      the other three affect skipping of some Annotations while iterating.
      The defaults (summarized following) are designed to fit the popular use cases.</p>
      
      <div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>typePriority</strong></span></span></dt><dd>
            <p>The default is to ignore type priorities when setting the starting position, and just use
            the begin / end position to locate the left-most equal spot.  If you want to respect type priorities,
            specify this variant.
            </p>
          </dd><dt><span class="term"><span class="strong"><strong>positionUsesType</strong></span></span></dt><dd>
            <p>When type priorities are not being used, Annotations with the same begin and end and type
            will be together in the index.  The starting position, when there are many Annotations 
            which might compare equal, is the left-most (earliest) one of these.  In this comparison for 
            equality, by default, the <code class="code">type</code> of the bounding Annotation is ignored; 
            only its begin and end values are used. 
            If you want to include the type of the bounding Annotation in the equal comparison, set this to true.
            </p>
          </dd><dt><span class="term"><span class="strong"><strong>nonOverlapping</strong></span></span></dt><dd>
            <p>Normally, all Annotations satisfying the bounds are returned.  If this is set, 
            annotations whose <code class="code">begin</code> position is not &gt;= the previous annotation's (going forwards)
            <code class="code">end</code> position are skipped.  This is also called <span class="emphasis"><em>unambiguous</em></span> iteration.
            If the iterator is run backwards, it is first run forwards to locate all the items that would be in the
            forward iteration following the rules; and then those are traversed backwards.
            This variant is ignored for <code class="code">covering</code> selection.
            </p>
          </dd><dt><span class="term"><span class="strong"><strong>includeAnnotationsWithEndBeyondBounds</strong></span></span></dt><dd>
            <p>The Subiterator <span class="emphasis"><em>strict</em></span> configuration is equivalent to the opposite of this.
            This only applied to the <code class="code">coveredBy</code> selection; 
            if specified, then any Annotations whose
            <code class="code">end</code> position is &gt; the end position of the bounding Annotation are included;
            normally they are skipped.
            </p>
          </dd><dt><span class="term"><span class="strong"><strong>useAnnotationEquals</strong></span></span></dt><dd>
            <p>While doing bounded iteration, if the Annotation being returned is identical (has the same
            _id()) with the bounding Annotation, it is always skipped.</p>
            
            <p>  
            When this variant is specified, in addition to
            that, any Annotation which has the same begin, end, and (maybe) type is also skipped.  
            The <code class="code">positionUsesType</code> setting is used to specify in this variant whether or not the 
            type is included when doing the equals test.  Note that <code class="code">typePriority</code> implies
            <code class="code">positionUsesType</code>.
            </p>
          </dd></dl></div>
    </div>
 
       <div class="section" title="4.3.7.&nbsp;Defaults for bounded selects"><div class="titlepage"><div><div><h3 class="title" id="uv3.select.annot.subselect.defaults">4.3.7.&nbsp;Defaults for bounded selects</h3></div></div></div>
        
        <p>The ordinary core UIMA Subiterator implementation defaults to using type order as part of the bounds
        determination.  uimaFIT, in contrast, doesn't use type order, and sets bounds according to 
        the begin and end positions.</p>
        
        <p>This <code class="code">select</code> implementation mostly follows the uimaFIT approach by default, but provides
        the above configuration settings to flexibly alter this to the user's preferences.
        For reference, here are the default settings, with some comparisons to the defaults for <code class="code">Subiterators</code>:</p>
        
        <div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>typePriority</strong></span></span></dt><dd>
              <p>default: type priorites are not used when determining bounds in bounded selects.
              Subiterators, in contrast, use type priorities.
              </p>
            </dd><dt><span class="term"><span class="strong"><strong>positionUsesType</strong></span></span></dt><dd>
              <p>default: the type of the bounding Annotation is ignored 
               when determining bounds in bounded selects; only its begin and end position are used
              </p>
            </dd><dt><span class="term"><span class="strong"><strong>nonOverlapping</strong></span></span></dt><dd>
              <p>default: false; no Annotations are skipped because they overlap.
              This corresponds to the "ambiguous" mode in Subiterators.
              </p>
            </dd><dt><span class="term"><span class="strong"><strong>includeAnnotationsWithEndBeyondBounds</strong></span></span></dt><dd>
              <p>default: (only applies to <code class="code">coveredBy</code> selections; 
              The default is to skip Annotations whose end position lies outside of the bounds; 
              this corresponds to Subiterator's "strict" option.
              </p>
            </dd><dt><span class="term"><span class="strong"><strong>useAnnotationEquals</strong></span></span></dt><dd>
              <p>default: only the single Annotation with the same _id() is skipped when doing sub selecting.
                Use this setting to expand the set of skipped Annotations to include all those equal to the 
                bound's begin and end (and maybe, type, if positionUsesType or typePriority specified).   
              </p>
            </dd></dl></div>
          
      </div>
    
    <div class="section" title="4.3.8.&nbsp;Following or Preceding"><div class="titlepage"><div><div><h3 class="title" id="uv3.select.annot.follow_precede">4.3.8.&nbsp;Following or Preceding</h3></div></div></div>
      
      
      <p>For an sorted Index, you can specify all Feature Structures following or preceding a position.
      The position can be specified either as a Feature Structure, or (for AnnotationIndexes only) 
      by using begin and end values.
      The arguments are identical to those of the <code class="code">startAt</code> specification, but are interpreted 
      differently.    
      </p>
            
      <div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>following</strong></span></span></dt><dd>
            <p>Position the iterator according to the argument, get that Annotation's <code class="code">end</code>
            value, and then move the iterator forwards until
            the Annotation at that position has its begin value &gt;= to the saved end value.
            </p>
          </dd><dt><span class="term"><span class="strong"><strong>preceding</strong></span></span></dt><dd>
            <p>Position the iterator according to the argument, save that Annotation's <code class="code">begin</code> value,
            and then move it backwards until
            the Annotation's (at that position) <code class="code">end</code> value is &lt;= to the saved <code class="code">begin</code>value.
            </p>
          </dd></dl></div>
      
    </div>  
  </div>
  
  <div class="section" title="4.4.&nbsp;Terminal Form actions"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="uv3.select.terminal_form_actions">4.4.&nbsp;Terminal Form actions</h2></div></div></div>
    
    
    <p>After the sources and selection and ordering options have been specified, one 
    terminal form action may be specified.  This can be an getting an iterator, array or list,
    or a single value with various extra checks, or a Java stream.  Specifying any stream operation
    (except limit) converts the object to a stream; from that point on, any stream operation may be used.</p>
    
    <div class="figure"><a name="uv3.select.fig.terminal_form_actions"></a><div class="figure-contents">
      
      <div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="545"><tr><td><img src="images/version_3_users_guide/select/select_terminal_form_actions.png" width="545" alt="Terminal form actions for select"></td></tr></table></div>
    </div><p class="title"><b>Figure&nbsp;4.4.&nbsp;Select Terminal Form Actions</b></p></div><br class="figure-break">
    
    <div class="section" title="4.4.1.&nbsp;Iterators"><div class="titlepage"><div><div><h3 class="title" id="uv3.select.terminal_form_actions.iterators">4.4.1.&nbsp;Iterators</h3></div></div></div>
      
      
      <div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>(Iterable)</strong></span></span></dt><dd>
            <p>The <code class="code">SelectFSs</code> object directly implements <code class="code">Iterable</code>, so it may be 
            used in the extended Java <code class="code">for</code> loop.</p>
          </dd><dt><span class="term"><span class="strong"><strong>fsIterator</strong></span></span></dt><dd>
            <p>returns a configured fsIterator or subIterator.  
            This iterator implements <code class="code">ListIterator</code> as well (which, in turn,
            implements Java <code class="code">Iterator</code>).
            Modifications to the list using <code class="code">add</code> or <code class="code">set</code> are not supported.
            </p>
          </dd><dt><span class="term"><span class="strong"><strong>iterator</strong></span></span></dt><dd>
            <p>This is just the plain Java iterator, for convenience.
            </p>
          </dd><dt><span class="term"><span class="strong"><strong>spliterator</strong></span></span></dt><dd>
            <p>This returns a spliterator, which can be marginally more efficient to use than a normal iterator.
            It is configured to be sequential (not parallel), and has other characteristics set according to 
            the sources and selection/ordering configuration.
            </p>
          </dd></dl></div>
 
    </div>
    <div class="section" title="4.4.2.&nbsp;Arrays and Lists"><div class="titlepage"><div><div><h3 class="title" id="uv3.select.terminal_form_actions.arrays_lists">4.4.2.&nbsp;Arrays and Lists</h3></div></div></div>
      
      <div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>asArray</strong></span></span></dt><dd>
            <p>This takes 1 argument, the class of the returned array type, which must be the type or subtype of the
            select.
            </p>
          </dd><dt><span class="term"><span class="strong"><strong>asList</strong></span></span></dt><dd>
            <p>Returns a Java list, configured from the sources and selection and ordering specifications. 
            </p>
          </dd></dl></div>
    </div>
    <div class="section" title="4.4.3.&nbsp;Single Items"><div class="titlepage"><div><div><h3 class="title" id="uv3.select.terminal_form_actions.single_items">4.4.3.&nbsp;Single Items</h3></div></div></div>
      
      <p>These methods return just a single item, according to the previously specified select configuration.
      Variations may throw exceptions on empty or more than one item situations.</p>
      
      <p>These have no-argument forms as well as argument forms identical to <code class="code">startAt</code> (see above).
      When arguments are specified, they adjust the item returned by positioning within the index 
      according to the arguments.</p>
        
      <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
        <p>Positioning arguments with a Annotation or begin and end require an Annotation Index.
        Positioning using a Feature Structure, by contrast, only require that the index being use be sorted.
        </p>
      </div>
      
      <div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>get</strong></span></span></dt><dd>
            <p>If no argument is specified, then returns the first item, or null.  If nullOk(false) is configured, 
            then if the result is null, an exception will be thrown.
            </p>
            <p>If any positioning arguments are specified, then this returns the item at that position unless 
            there is no item at that position, in which case it throws an exception unless <code class="code">nullOk</code> is set.
            </p>
          </dd><dt><span class="term"><span class="strong"><strong>single</strong></span></span></dt><dd>
            <p>returns the item at the position, but throws exceptions 
            if there are more than one item in the selection,
            or if there are no items in the selection.
            </p>
          </dd><dt><span class="term"><span class="strong"><strong>singleOrNull</strong></span></span></dt><dd>
            <p>returns the item at the position, but throws an exception 
            if there are more than one item in the selection.
            </p>
          </dd></dl></div>
    </div>
    <div class="section" title="4.4.4.&nbsp;Streams"><div class="titlepage"><div><div><h3 class="title" id="uv3.select.terminal_form_actions.streams">4.4.4.&nbsp;Streams</h3></div></div></div>
      
      <div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>any stream method</strong></span></span></dt><dd>
            <p>Select supports all the stream methods.  The first occurance of a stream method converts the select
            into a stream, using <code class="code">spliterator</code>, and from then on, it behaves just like a stream object.
            </p>
            
            <p>For example, here's a somewhat contrived example:  
            you could do the following to collect the set of types appearing
            within some bounding annotation, when considered in nonOverlapping style:
            
    </p><div class="informalexample">  
<pre class="programlisting">Set&lt;Type&gt; foundTypes =
    // items of MyType or subtypes 
   myIndex.select(MyType.class)
   .coveredBy(myBoundingAnnotation)
   .nonOverlapping()
   .map(fs -&gt; fs.getType())
   .collect(Collectors.toCollection(TreeSet::new));
</pre>
</div><p>
Or, to collect by category a set of frequency values:
</p><div class="informalexample">  
<pre class="programlisting">Map&lt;Category, Integer&gt; freqByCategory =
   myIndex.select(MyType.class)
   .collect(Collectors
     .groupingBy(MyType::getCategory,
                 Collectors.summingInt(MyType::getFreq)));
</pre> 
</div><p>
            </p>
          </dd></dl></div>
    </div>
  </div>
    
  </div>
  <div class="chapter" title="Chapter&nbsp;5.&nbsp;Defining CAS-transported custom Java objects" id="uv3.custom_java_objects"><div class="titlepage"><div><div><h2 class="title">Chapter&nbsp;5.&nbsp;Defining CAS-transported custom Java objects</h2></div></div></div>
  
  
  
  <p>One of the goals of v3 is to support more of the Java collection framework within the CAS,
  to enable users to conveniently build more complex models that could be transported by the CAS.
  For example, a user might want to store a Java "Set" object, representing a set of Feature Structures.
  Or a user might want to use an adjustable array, like Java's ArrayList.
  </p>
  
  <p>With the current version 2 implementation of JCas, users already may add arbitrary Java objects to their
  JCas class definitions as fields, but these do not get transported with the CAS (for instance, during 
  serialization).  Furthermore, in version 2, the actual JCas instance you get when accessing a Feature Structure
  in some edge cases may be a fresh instance, losing any previously computed value held as a Java field. 
  In contrast, each Feature Structure in a CAS is represented as the same unique Java Object 
  (because that's the only way a Feature Structure is stored).
  </p>
  
  <p>Version 3 has a new a capability that enables converting arbitrary Java objects 
  that might be part of a 
  JCas class definition, into "ordinary" CAS values that can be transported with the CAS. 
  This is done using a set of conventions which the framework follows, and which developers writing these
  classes make use of; they include
  two kinds of marker Java interfaces, and 2 methods that are called when serializing and deserializing.
  </p><div class="blockquote"><blockquote class="blockquote"><p>
	  The marker interfaces identify those JCas classes which need these extra methods called.  The extra methods are 
	  methods implemented by the creator of these JCas classes, which marshal/unmarshal CAS feature data to/from the 
	  Java Object this class is supporting.
  </p></blockquote></div><p>
  </p>

  <p>
  Storing the Java Object data as the value of a normal CAS Feature means that they get "transported" in a portable
  way with the CAS - they can be saved to external storage and read back in later, or sent to remote services, etc.
  </p>
  
  <div class="section" title="5.1.&nbsp;Tutorial example"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="uv3.custom_java_objects.tutorial">5.1.&nbsp;Tutorial example</h2></div></div></div>
    
    <p>Here's a tutorial example on how to design and implement your own special Java object.  For this example,
    we'll imagine we need to implement a map from FeatureStructures to FeatureStructures.</p>
    
    <div class="figure"><a name="uv3.custom_java_objects.5_steps"></a><div class="figure-contents">
      
      <div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="545"><tr><td><img src="images/version_3_users_guide/custom_java_objects/5_steps.png" width="545" alt="5 steps to creating a custom CAS transportable Java Object"></td></tr></table></div>
    </div><p class="title"><b>Figure&nbsp;5.1.&nbsp;Creating a custom Java CAS-stored Object</b></p></div><br class="figure-break">

    <p>      
    Step 1 is deciding on the Java Object implementation to use.  We can define a special class, but in this case,
    we'll just use the ordinary Java HashMap&lt;TOP, TOP&gt; for this.</p>
    
    <p>Step 2 is deciding on the CAS Feature Structure representation of this.  For this example, let's design this
    to represent the serialized form of the hashmap as 2 FSArrays, one for the keys, and one for the values.
    We could also use just one array and intermingle the keys and values. It's up to the designer of this new JCas
    class to decide how to do this.</p>
    
    <p>Step 3 is defining the UIMA Type for this.  Let's call it FS2FSmap.  It will have 2 Features: an FSArray
    for the keys, and another FSArray for the values.  Let's name those features "keys" and "values".
    Notice that there's no mention of the Java object in the UIMA Type definition.
    </p>
    
    <p>Step 4 is to run JCasGen on this class to get an initial version of the class.  Of course, it will be missing
    the Java Hashmap, but we'll add that in the next step.</p>
    
    <p>Step 5: modify 3 aspects of the generated JCas class.
    </p><div class="variablelist"><dl><dt><span class="term">Mark the class with one of two interfaces:</span></dt><dd>
            <div class="itemizedlist"><ul class="itemizedlist" type="disc" compact><li class="listitem"><p><code class="code">UimaSerializable</code></p></li><li class="listitem"><p><code class="code">UimaSerializableFSs</code></p></li></ul></div>
            <p>These identify this JCas class a needing the calls to marshal/unmarshal the data to/from the
            Java Object and the normal CAS data features.  Use the second form if the data includes any
            Feature Structure references.  In our example, the data does include Feature Structure references, 
            so we add <code class="code">implements UimaSerializableFSs</code> to our JCas class.</p>
          </dd><dt><span class="term">Add the Java Object as a field to the class</span></dt><dd>
            <p>We'll define a new field:
    </p><pre class="programlisting">final private Map&lt;TOP, TOP&gt; fs2fsMap = new HashMap&lt;&gt;();</pre>
          </dd><dt><span class="term">Implement two methods to marshal/unmarshal the Java Object data to the CAS Data Features</span></dt><dd>
            <p>Now, we need to add the code that translates between the two UIMA Features 
                  "keys" and "values" and the map, and vice-versa.  We put this code into two methods, 
                  called <code class="code">_init_from_cas_data</code> and <code class="code">_save_to_cas_data</code>. 
                  These are special methods that are part of this new framework extension; 
                  they are called by the framework at critical times during deserialization and serialization.  
                  Their purpose is to encapsulate all that is needed to convert from transportable 
                  normal CAS data, and the Java Object(s).</p>
    
            <p>In this example, the <code class="code">_init_from_cas_data</code> method would iterate over the two Features,
                  together, and add each key value pair to the Java Object.  Likewise, the 
                  <code class="code">_save_to_cas_data</code> would first create two FSArray objects for the keys and values, 
                  and then iterate over the hash map and extract these and set them into the key and value arrays.
                  </p><pre class="programlisting">public void _init_from_cas_data() {
  FSArray keys = getKeys();
  FSArray values = getValues();
  fs2fsMap.clear();
  for (int i = keys.size() - 1; i &gt;=0; i--) {
    fs2fsMap.put(keys.get(i), values.get(i)); 
  }
}

public void _save_to_cas_data() {
  int i = 0;
  FSArray keys = new FSArray(this, fs2fsMap.size());
  FSArray values = new FSArray(this, fs2fsMap.size());
  for (Entry&lt;TOP, TOP&gt; entry : fs2fsMap.entrySet()) {
    keys.set(i, entry.getKey());
    values.set(i, entry.getValues());
    i++;
  }
  setKeys(keys); 
  setValues(values);
}    
</pre><p>
            </p>
            
            <p>Beyond this simple implementation, various optimization can be done.
            One typical one is to treat the use case where no updates were done as a special
            case (but one which might occur frequently), and in that case having the
            _save_to_cas_data operation do nothing, since the original CAS data is still valid.</p>
            
            <p>One additional "boilerplate" method is required for all of these classes:            
            </p><div class="blockquote"><blockquote class="blockquote"><p>public FeatureStructureImplC _superClone() {return clone();}</p></blockquote></div>
          </dd></dl></div><p>
    </p>
    
    <p>For more examples, please see the implementations of the built-in classes described in the
    following section.</p>
  </div>
  
  <div class="section" title="5.2.&nbsp;Additional Semi-Built-in UIMA Types for some common Java Objects"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="uv3.custom_java_objects.new_semibuiltins">5.2.&nbsp;Additional Semi-Built-in UIMA Types for some common Java Objects</h2></div></div></div>
	  
	  
	  
	  <p>Some additional semi-built-in UIMA types are defined in Version 3 using this new mechanism.  They work fully in
	  Java, and are serialized or transported to non-Java frameworks as ordinary CAS objects.</p>
	  
    <p>Semi-built-in means that the JCas cover classes for these are defined as part of the core Java classes,
      but the types themselves are not "built-in".  They may be added to any tyupe system by importing them by name using the import statement:
      </p><pre class="programlisting">&lt;import name="org.apache.uima.semibuiltins"/&gt;</pre><p>
      If you have a Java project whose classpath includes uimaj-core, and you run the Component Descriptor Editor
      Eclipse plugin tool on a descriptor which includes a type system, you can configure this import by selecting
      the Add on the Import type system subpanel, and import by name, and selecting org.apache.uima.semibuiltins.
      (Note: this will not show up if your project doesn't include uimaj-core on its build path.)
    </p>
    
	  <div class="section" title="5.2.1.&nbsp;FSArrayList"><div class="titlepage"><div><div><h3 class="title" id="uv3.custom_java_objects.semibuiltin_fsarraylist">5.2.1.&nbsp;FSArrayList</h3></div></div></div>
	    
	    
	    
	    <p>This is like the current FSArray, except that it implements the List API and supports 
	    adding to the array, with automatic resizing, like an ArrayList in Java.  It is implemented internally
	    using a Java ArrayList.</p>
	    
	    <p>The CAS data form is held in a plain FSArray feature.</p>
	    
	    <p>The <code class="code">equals()</code> method is true if both FSArrayList objects have the same size, and
	    contents are <code class="code">equal</code> item by item.  
	    The list of supported operations includes all of the operations of 
	    the Java <code class="code">List</code> interface.  This object also includes the <code class="code">select</code> methods, so it
	    can be used as a source for the <code class="code">select</code> framework.</p> 
	  </div>
	  
	  <div class="section" title="5.2.2.&nbsp;IntegerArrayList"><div class="titlepage"><div><div><h3 class="title" id="uv3.custom_java_objects.semibuiltin_integerarraylists">5.2.2.&nbsp;IntegerArrayList</h3></div></div></div>
      
      
      
      <p>This is like the current IntegerArray, except that it implements the List API and supports 
      adding to the array, with automatic resizing, like an ArrayList in Java.</p>
      
      <p>The CAS data form is held in a plain IntegerArray feature.</p>
      
      <p>The <code class="code">equals()</code> method is true if both IntegerArrayList objects have 
      the same size, and
      contents are <code class="code">equal</code> item by item.  
      The list of supported operations includes a subset of the operations of 
      the Java <code class="code">List</code> interface, where certain values are changed to Java primitive
      <code class="code">ints</code>.  To support the <code class="code">Iterable</code> interface, there is 
      a version of <code class="code">iterator()</code> where the result is "boxed" into an
      Integer.  For efficiency, there's also a method intListIterator, which returns
      an instance of IntListIterator, which permits iterating forwards and backwards, without
      boxing.</p> 
       
    </div>
    
    <div class="section" title="5.2.3.&nbsp;FSHashSet"><div class="titlepage"><div><div><h3 class="title" id="uv3.custom_java_objects.semibuiltin_FSHashSet">5.2.3.&nbsp;FSHashSet</h3></div></div></div>
      
      
      
      <p>This type stores Feature Structures in a HashSet, using whatever is defined
      as the Feature Structure's <code class="code">equals</code> and <code class="code">hashcode</code>.
      
      </p><div class="blockquote"><blockquote class="blockquote">
	      <p>You may customize the particular equals and hashcode by creating a wrapper class that
	      is a subclass of the type of interest which forwards to the underlying Feature Structure, but
	      has its own definition of <code class="code">equals</code> and <code class="code">hashcode</code>. 
	      </p>
      </blockquote></div><p>
      </p>
            
      <p>The CAS data form is held in an FSArray consisting of the members of the set.</p>
            
    </div>
    
  </div>
  
  <div class="section" title="5.3.&nbsp;Design for reuse"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="uv3.custom_java_objects.design">5.3.&nbsp;Design for reuse</h2></div></div></div>
      
      
      <p>While it is possible to have a single custom JCas class implement multiple Java Objects, this is 
        typically not a good design practice, as it reduces reusability.  It is usually better to 
        implement one custom Java object per JCas class, with an associated UIMA type, and have that as
        the reusable entity.
      </p>
  </div>

</div> 
  <div class="chapter" title="Chapter&nbsp;6.&nbsp;Migrating JCas classes from Version 2 to 3" id="uv3.migration"><div class="titlepage"><div><div><h2 class="title">Chapter&nbsp;6.&nbsp;Migrating JCas classes from Version 2 to 3</h2></div></div></div>
  
  
  
  <div class="section" title="6.1.&nbsp;How to migrate an existing UIMA pipeline to V3"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="uv3.migration.big_picture">6.1.&nbsp;How to migrate an existing UIMA pipeline to V3</h2></div></div></div>
    
    
    
    <p>
      UIMA V3 is designed to be binary compatible with existing UIMA V2 pipelines, so compiled and/or JAR-ed up classes 
      representing a V2 pipeline should run with UIMA v3, with two changes:
      </p><div class="itemizedlist"><ul class="itemizedlist" type="disc" compact><li class="listitem"><p>Java 8 is required. (If you're already using Java 8, nothing need be done.)</p></li><li class="listitem"><p>Any defined JCas cover classes must be migrated or regenerated, and used instead.
        (If you do not define any JCas classes or don't use JCas in your pipeline, then nothing need be done.)</p></li></ul></div><p>
    </p>
    
    <p>Some Maven projects use the JCasGen maven plugin; these project's JCasGen maven plugin,
     if switched to UIMA V3, automatically generate the V3 versions.
    </p>
    
    <p>You can use any of the methods of invoking JCasGen to generate the new V3 versions.  If you already have
    the source or class files, you can also migrate those using the migration tool described in this section.</p>
     
    <p>For simple testing, after users have migrated or generated any user-supplied JCas classes, 
      users typically will JAR-up these migrated classes,
      and then place that JAR in the class path ahead of the original V2 pipeline's classes so these will replace
      the corresponding classes.
    </p>
    
    <div class="section" title="6.1.1.&nbsp;How to modify a Maven project to support both v2 and v3"><div class="titlepage"><div><div><h3 class="title" id="uv3.migration.maven-cookbook">6.1.1.&nbsp;How to modify a Maven project to support both v2 and v3</h3></div></div></div>
      
      
      
      <p>When migrating an existing Maven project to v3, you can of course, just change the dependencies, upgrade
      to Java 8 if needed, and migrate/regenerate any user-defined JCas class definitions.  Nothing special is needed
      for this approach.</p>
      
      <p>If you want to simultaneously support both v2 and v3, you can take advantage of the binary compatibility
      support in v3, and have one set of maven artifacts for both (compiled with Java 7), plus an additional
      Maven project just for the generated JCas classes v3-style.  This additional maven project would 
      specify Java 8 and UIMA v3 dependencies, and produce a Jar file with the V3 version, either from migrated Java sources,
      or using the JCasGen maven plugin, generating from the type system description.</p>
      
      <p>
      The using community would see the original output artifacts, plus one new Jar artifact, which, if they were
      wanting to use V3, they would need to place ahead of the original artifacts in the running pipeline's classpath.
      </p>
    </div>
  </div>
  <div class="section" title="6.2.&nbsp;Migrating JCas classes"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="uv3.migration.jcas">6.2.&nbsp;Migrating JCas classes</h2></div></div></div>
    
    
  <p>Some projects are built using Maven, and use the JCasGen Maven plugin as part of the build.
  These builds, when switched to depend on version 3, will automatically generate the new JCas
  class definitions, so nothing special need be done.
  </p>
  
  <p>If you have customized JCasGen classes, these can be migrated by running the migration tool, which is available
	  as a stand-alone command line tool (<code class="code">runV3migrateJCas.sh or ...bat</code>), or 
	  as an Eclipse launch configuration.</p>
	  
  <p>This tool is run against a directory tree, and scans all the files in the tree, looking for 
     JCas cover classes.  It can process either source files, or, if those are not available, compiled
     class files.  It can process these inside directories, as well as inside Jar files within those directories.</p>
                
	<p>Run this tool using a Java 8 JDK (as opposed to a Java JRE) in order to have the Java compiler available.</p>

  <p>The results of the migration include the migrated class files and a set of logs, summarized in the console
    output, detailing anything that might need inspection to verify the migration was done correctly.
  </p>
  
  <div class="blockquote"><blockquote class="blockquote"><p>
    If all is OK, the migration will say that it "finished with no unusual conditions", at the end.
  </p></blockquote></div> 	  

  <p>To complete the migration, update your UIMA application to use these classes in place of the version 2 JCas classes.
  </p>
    
  <p>The migration tool is able to scan multiple directory trees, looking for existing Java
	  source (.java) or class (.class) files, even inside Jars and PEAR archives. If compiled class files
	  are used as input, a Java decompiler is used to decompile these to source.
	  For PEARs and Jars, it replaces the migrated and compiled classes in copies of the PEARs and Jars.
	</p>
	
	<p>  
	  The actual migration step is a source-to-source transformation, done using a Java parse of the source files.
	  The parts in the source which are version 2 specific with the equivalent
	  version 3 code.
	  Only those parts which need updating are modified;
    other code and comments which are part of the source file are left unchanged.  This is intended to preserve
    any user customization that may have been done.  
    Detailed reports detailing any issues encountered are written to log files. 
  </p>
    
 
 		 
		 <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>The compilation step (done after the source-to-source transformation) requires that a Java compiler is available 
		   (which will be the case if you're running with a Java JDK, not a JRE).
		 </p></div>
		 
		 <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>After running the tool, it is important to examining the console output and logs.
       You can confirm that the migration completed without any unusual conditions, or, if something 
       unusual was encountered, you can take corrective action.
		 </p></div>
		  
		<div class="section" title="6.2.1.&nbsp;Running the migration tool"><div class="titlepage"><div><div><h3 class="title" id="uv3.migration.tool_guide.running">6.2.1.&nbsp;Running the migration tool</h3></div></div></div>
	    
	    <p>The tool can be run as a stand-alone command, using the launcher scripts <code class="code">runV3migrateJCas</code>; 
	      there are two versions of this &#8212; one for windows (ending it ".bat") and one for linux / mac (ending in ".sh").
		    If you run this without any arguments, it will show a brief help for the arguments.
		  </p>
		  
		  <p>There are also a pair of Eclipse launch configurations 
        (one for source files, the other for compiled classes), 
        which are available if you have the uimaj-examples project
        (included in the binary distribution of UIMA) in your Eclipse workspace.
      </p>
      
      <div class="section" title="6.2.1.1.&nbsp;Using Eclipse to run the migration tool"><div class="titlepage"><div><div><h4 class="title" id="uv3.migration.tool_guide.running.eclipse">6.2.1.1.&nbsp;Using Eclipse to run the migration tool</h4></div></div></div>
      
      
        <p>There are two Eclipse launch configurations; one works with source code, the other with compiled classes
          or Jars or PEARs.  The launch configurations are named:
          </p><div class="itemizedlist"><ul class="itemizedlist" type="disc" compact><li class="listitem"><p>UIMA Run V3 migrate JCas from sources roots</p></li><li class="listitem"><p>UIMA Run V3 migrate JCas from classes roots</p></li></ul></div><p>
          When running from classes roots, the classes must not have compile errors, and may contain Jars and PEARs. 
        </p>
      
        <p>
          To use these launchers,
            </p><div class="itemizedlist"><ul class="itemizedlist" type="disc" compact><li class="listitem"><p>First select the eclipse project; this project's "build path" will supply the 
                classpath used during migration for decompiling and compiling the sources.</p></li><li class="listitem"><p>run the launcher - it will prompt for two values:
                </p><div class="itemizedlist"><ul class="itemizedlist" type="circle" compact><li class="listitem"><p>the root directory to scan recursively looking for JCas sources or classes/Jars/Pears to be converted</p></li><li class="listitem"><p>an output directory - a writable folder, such as /temp/migrate</p></li></ul></div><p>
              </p></li></ul></div><p>
  		  </p>
  	    
  	    <p>No matter how the tool is started, the input to the tool is one or more directory tree roots; 
  	      the tool will scan the file system under these roots (including inside Jars and PEARs when running from
          compiled classes), looking for definitions to migrate.  
  	    </p>
		    
	      
        
      </div>
		  
      
      <div class="section" title="6.2.1.2.&nbsp;Running from the command line"><div class="titlepage"><div><div><h4 class="title" id="uv3.migration.tool_guide.running.cmd_line">6.2.1.2.&nbsp;Running from the command line</h4></div></div></div>
      
      
  	    <div class="section" title="Command line: Specifying input sources"><div class="titlepage"><div><div><h5 class="title" id="uv3.migration.tool_guide.running.inputs">Command line: Specifying input sources</h5></div></div></div>
  	      
  	    
  	    <p>Input is specified using these arguments:
  		    </p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>"-sourcesRoots"</strong></span></span></dt><dd>
  		          <p>a list of one or more directories, separated by the
  		            a path separator character (";" for Windows, ":" for others). 
  		          </p>
  		          <p>Migrates each candidate source file found in any of the file tree roots,
  		            skipping over non-JCas classes.</p>
  		        </dd><dt><span class="term"><span class="strong"><strong>"-classesRoots"</strong></span></span></dt><dd>
                <p>a list of one or more directories
                  containing class files or Jars or PEARs, separated by the
                  a path separator character (";" for Windows, ":" for others). 
                </p>
  	            <p>Decompiles, then migrates each candidate class file found in any of the file tree roots
  	              (skipping over non-JCas classes).  
  	            </p>	              
  	          </dd></dl></div><p>  
  	    </p>
        </div>
        	    
  	    <div class="section" title="Command line: Specifying a classpath for the migration"><div class="titlepage"><div><div><h5 class="title" id="uv3.migration.tool_guide.classpath">Command line: Specifying a classpath for the migration</h5></div></div></div>
  	      
  	      <p>A classpath is required for the proper operation of the decompiling and compiling steps of 
  	        the migration.  This is provided using the argument <code class="code">-migrateClasspath</code>.
  	        The Eclipse launcher "UIMA run V3 migrate JCas from classes roots" sets this argument using
  	        the selected Eclipse project's classpath.
  	        When migrating within a PEAR, the migration tool automatically adds the PEAR classes to the 
  	        classpath.
  	      </p>
  	    </div>

      </div>
      	    	    	    
	    <div class="section" title="6.2.1.3.&nbsp;Handling duplicate definitions"><div class="titlepage"><div><div><h4 class="title" id="uv3.migration.tool_guide.duplicates">6.2.1.3.&nbsp;Handling duplicate definitions</h4></div></div></div>
	      
	      <p>Sometimes, a classpath or directory tree may contain multiple instances of the same JCas class.
	        These might be identical, or they might be different versions.  The migration utility detects this, 
	        and migrates all non-identical instances, using a convention to store them in the output directory in a manner
	        where different versions can be conveniently compared using tooling such as Eclipse's file compare.
	      </p>
	      <div class="blockquote"><blockquote class="blockquote"><p>When there are non-identical duplicate definitions, 
	        the user must manually compare these and decide which version to use.</p></blockquote></div>
	      
	    </div>
	  </div>  

    <div class="section" title="6.2.2.&nbsp;Understanding the reports"><div class="titlepage"><div><div><h3 class="title" id="uv3.migration.tool_guide.reports">6.2.2.&nbsp;Understanding the reports</h3></div></div></div>
      
      <p>The output directory contains a logs directory with additional information.
        A summary is also written to System.out.
      </p>
        
      <p>Each file translated has both a v2 source and a v3 source.  When the input is ".class" files, 
        the v2 source is the result of the decompilation step, prior to any migration.
      </p>
      
      <div class="blockquote"><blockquote class="blockquote"><p>
        These are arranged in parallel directories, allowing Eclipse's multi-file directory "compare" to work on both directory
        collections and conveniently show for all the migrated files the change details.
      </p></blockquote></div>
        
      <p>In the case of non-identical duplicates, an increasing integer 
        starting with 1 is inserted into the output directory tree
        for each migrated class.</p>
        
      <p>The overall directory output directory tree looks like:
        </p><pre class="programlisting">Directory structure, starting at -outputDirectory
   converted/
     v2/
       x/y/z/javapath/.../Classname.java
       x/y/z/javapath/.../Classname.java
       ...
     v3/
       x/y/z/javapath/.../Classname.java
       x/y/z/javapath/.../Classname.java
       ...
       
       
       1/     &lt;&lt; for non identical duplicates
         x/y/z/javapath/.../Classname.java    
         x/y/z/javapath/.../Classname.java  
         ...                                    
       2/     &lt;&lt; for non identical duplicates
         x/y/z/javapath/.../Classname.java
         x/y/z/javapath/.../Classname.java
         ...
     v3-classes/
         ...    
       
   not-converted/
   logs/
     processed.txt
     failed.txt
     skippedBuiltins.txt
     NonJCasFiles.txt
     workaroundDir.txt
     deletedCheckModified.txt
     manualInspection.txt
     pearsFileUpdates.txt
     jarsFileUpdates.txt
   pears/
     xyz_converted_pear.pear  
     ...
   jars/
     ...</pre><p>
     
        The converted subtree holds all the sources and migrated versions that were successfully migrated.
        The not-converted subtree hold the sources that failed in some way the migration.
        The logs contain many kinds of entries for different issues encountered:
        </p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>processed.txt</strong></span></span></dt><dd>
              <p>List of successfully processed classes
              </p>
            </dd><dt><span class="term"><span class="strong"><strong>failed.txt</strong></span></span></dt><dd>
              <p>List of classes that failed to migrate
              </p>
            </dd><dt><span class="term"><span class="strong"><strong>skippedBuiltins.txt</strong></span></span></dt><dd>
              <p>List of classes representing built-ins that were skipped.  These need
                manual inspection to see how to merge with new v3 built-ins.
              </p>
            </dd><dt><span class="term"><span class="strong"><strong>NonJCasFiles.txt</strong></span></span></dt><dd>
              <p>List of files that were thought to be JCas classes but 
                upon further analysis appear to not be.  These need 
                manual inspection to confirm.
              </p>
            </dd><dt><span class="term"><span class="strong"><strong>deletedCheckModified.txt</strong></span></span></dt><dd>
              <p>List of class where a version 2 if statement doing the "featOkTst"
                was apparently modified.  In the migrated code, this statement was deleted,
                perhaps incorrectly. These need manual inspection to confirm.
              </p>
            </dd><dt><span class="term"><span class="strong"><strong>manualInspection.txt</strong></span></span></dt><dd>
              <p>List of files where the migration found a get or set method, where
                the version 2 code was accessing a casFeatCode with the 
                feature name not matching.  These need manual inspection.
              </p>
            </dd><dt><span class="term"><span class="strong"><strong>workaroundDir.txt</strong></span></span></dt><dd>
	            <p>When running conversions on a windows system for files from a linux system,
	              sometimes there is a clash caused by the fact that Windows doesn't recognize 
	              upper vs lower case in file names.  When this happens, an entry is logged here,
	              and the conflicting name is suffixed with a "_c".
	            </p>
	          </dd><dt><span class="term"><span class="strong"><strong>jarsFileUpdates.txt</strong></span></span></dt><dd>
              <p>List of Jar files and classes which were replace in them.
              </p>
            </dd><dt><span class="term"><span class="strong"><strong>pearsFileUpdates.txt</strong></span></span></dt><dd>
              <p>List of Pear files and classes which were replace in them.
              </p>
            </dd></dl></div><p>    
      </p>
      
           
    </div>
    
    <div class="section" title="6.2.3.&nbsp;Examples"><div class="titlepage"><div><div><h3 class="title" id="uv3.migration.tool_guide.cookbook">6.2.3.&nbsp;Examples</h3></div></div></div>
       
    
      <p>Run the command line tool:
      </p><pre class="programlisting">cd $UIMA_HOME
      
bin/runV3migrateJCas.sh

  -migrateClasspath /home/me/myproj/xyz.jar:$UIMA_HOME/lib/uima-core.jar
    
  -classesRoots /home/me/myproj/xyz.jar:/home/me/myproj/target/classes
  
  -outputDirectory /temp/migratejcas  
</pre><p>
      </p>
      
      <p>Run the Eclipse launcher:</p>
      
      <pre class="programlisting">Load Eclipse workspace containing the project to be migrated,
  and the version 3 uimaj-migration project.
      
Select the Java project having the classpath used when running.

Eclipse -&gt; menu -&gt; Run -&gt; Run configurations
  Use the search box to find "Migrate JCas" launcher, and launch that.

In the first prompt, 
  enter the path to the root of the compiled classes or Jar or PEAR
In the second prompt, 
  enter a path to where you want the output, e.g. /temp/migrateJCas
</pre>
    
    <p>Please read the console output summarization to see about any 
      conditions found during migration which need manual inspection and fixup.</p>
    </div>
    
  </div>
</div>
  <div class="chapter" title="Chapter&nbsp;7.&nbsp;PEAR support" id="uv3.pears"><div class="titlepage"><div><div><h2 class="title">Chapter&nbsp;7.&nbsp;PEAR support</h2></div></div></div>
  

  <p>PEARs continue to be supported in Version 3, with the same 
    capabilities as in version 2.  Here's a brief review.
  </p>
  
  <p>PEARs are both a packaging facility, and an isolation facility.
  The packaging facility allows putting together into one PEAR file all the parts needed
  for a particular (reusable) UIMA pipeline, including annotators and other data resources,
  and a classpath to use.  PEARs are loaded using special class loaders that load first from
  whatever classpath is specified by the PEAR; this serves to isolate dependencies and insure
  that the PEAR makes use of whatever versions of classes it depends on (and specifies in its 
  classpath).
  </p>
  
  <p>PEARs establish a boundary within a UIMA pipeline &#8212;
    annotator code is running either inside a PEAR, or not.
    Note that PEARs cannot be nested.  
    The CAS, flowing through a pipeline, is dynamically updated with the current PEAR context (if any).    
  </p>
  
  <div class="section" title="7.1.&nbsp;JCas issues"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="uv3.pears.jcas">7.1.&nbsp;JCas issues</h2></div></div></div>
    
    
    <p>JCas classes defining Java implementations for UIMA Types may be defined within a PEAR.  
      These are loaded using the isolating Classloader, just like all the other PEAR resources.
      As a result, this may cause some issues if the same JCas class is also defined outside 
      the PEAR boundary, and loaded with the normal UIMA classloader.  The result of having the 
      same JCas class both on the PEAR classloader and outside that classloader will be that Java 
      will have both classes loaded, and code within the PEAR will be linked with one of them, and code
      outside the PEAR will be linked with the other. 
    </p>  
    
    <p>
      Sometimes, this is exactly what you might want.  For example, you might have in the pear, a special
      JCas definition of a UIMA type "Token" which the PEAR uses, while you might have another JCas 
      definition for that same UIMA type outside of the PEAR. Note that UIMA will always merge Type 
      definitions from inside and outside of PEARs, when it sets up a pipeline - it merges all type 
      definitions found for the whole pipeline.  
    </p>
    
    <p>A consequence of having two loaded class definitions in two contexts for the same UIMA type means
      that the classes have the same names, but are different (because of different loading classloaders), 
      and assigning one to the other in Java will produce a ClassCast exception.
    </p>
    
    <p>Othertimes, you may not want different classes.  For instance, the class definitions might be
      identical, and you want to create some "Token" annotations within the PEAR, and have them 
      used by JCas references outside of the PEAR.
    </p>
    
    <p>In this case, the simplest thing to do is to install the PEAR, but then update its classpath so
      it no longer includes the JCas classes that came with the PEAR.  When classes are not found with the
      special PEAR class loader, that loader delegates to its parent, which is the normal UIMA class loader.
      This action will cause the PEAR to use the identically same JCas class within the PEAR as is used
      outside of the PEAR, and no Class Cast Exception issues will arise.
      This is the most efficient way to run with PEARs that use JCas classes where you want to share results
      inside and outside of PEARs.
    </p>
    
    <p>
      Version 3 has special support for the case where there are different definitions of JCas classes 
      for the same UIMA type, inside and outside the PEAR.  It does this using what are called
      PEAR Trampolines.  When there are multiple JCas definitions, the one defined outside of the PEAR is
      the one stored internally in UIMA's indexes and built-in types that have references to Feature Structures.
      Accessing the Feature Structures checks (by asking the CAS) to see if its in a particular PEAR context
      (there may be several in one pipeline), and if so, a trampoline instance of the Feature Structure is
      created / used / accessed.  The trampoline instance shares internally the CAS data with the
      base instance, but is a separate instance of the PEAR's JCas class definition.  
      This allows seamless access both inside and outside of the PEAR context to the particular
      JCas class definition needed.  
    </p>
  </div>

  <div class="section" title="7.2.&nbsp;Custom Java Objects"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="uv3.pears.java_objects">7.2.&nbsp;Custom Java Objects</h2></div></div></div>
    
    
    <p>Custom Java Objects may store references to Feature Structures.  If it is desired to create 
      these inside a PEAR, and yet have the references work outside a PEAR, the implementor of these must
      insure that the actual stored JCas class for a Feature Structure is the base version, not the PEAR version,
      and also insure that any references are properly converted (while within a PEAR context).  
    </p>  
    
    <p>The new built-in types that reference Feature Structures <span class="emphasis"><em>do not</em></span> include 
      the extra facility to support this conversion; they store whatever they're given.  This means that
      they may be used inside or outside a PEAR, but cannot be used to hold onto Feature Structures set in
      one context, but referenced in the other.
    </p>
    
    <p>If there is interest or need, additional documentation can be written describing how the 
      core framework handles this, and providing a cookbook for others to implement this capability
      for custom Java objects.
    </p>
  </div>
    
  </div>
  <div class="chapter" title="Chapter&nbsp;8.&nbsp;Migration aids" id="uv3.migration.aids"><div class="titlepage"><div><div><h2 class="title">Chapter&nbsp;8.&nbsp;Migration aids</h2></div></div></div>
  
    
    <p>To aid migration, some features of UIMA V3 which might cause migration difficulties 
      can be disabled.  Users may initially want to disable these, and get their pipelines working,
      and then over time, re-enable these while fixing any issues that may come up, one feature
      at a time.
    </p> 
    
    <p>
      Global JVM properties for UIMA V3 that control these are described in the table below.  
    </p>
  
  <div class="section" title="8.1.&nbsp;Properties Table"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="uv3.migration.aids.property-table">8.1.&nbsp;Properties Table</h2></div></div></div>
    
      
    <p>This table describes the various JVM defined properties; specify these on the Java command line
    using -Dxxxxxx, where the xxxxxx is one of
    the properties starting with <code class="code">uima.</code> from the table below.</p>  
    <div class="informaltable">
     <table style="border-collapse: collapse;border-top: 0.5pt solid black; border-bottom: 0.5pt solid black; border-left: 0.5pt solid black; border-right: 0.5pt solid black; "><colgroup><col class="Title"><col class="Description"><col></colgroup><tbody><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; "><span class="bold"><strong>Title</strong></span></td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; "><span class="bold"><strong>Property Name &amp; Description</strong></span></td><td class="auto-generated" style="border-bottom: 0.5pt solid black; ">&nbsp;</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; "><p>Disable Type System consolidation</p></td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; "><p>uima.disable_typesystem_consolidation</p>
           
                  <p>Default: equal Type Systems are consolidated.</p>
                  <p>When type systems are committed, the resulting Type System (Java object) 
                    is considered read-only, and is compared to already existing Type Systems.
                    Existing type systems, if found, are reused.  Besides saving storage, this can
                    sometimes improve locality of reference, and therefore, performance. 
                    Setting this property disables this consolidation.</p></td><td class="auto-generated" style="border-bottom: 0.5pt solid black; ">&nbsp;</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; "><p>Enable finding all Feature Structures by their int ID</p></td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; "><p>uima.enable_id_to_feature_structure_map_for_all_fss</p>
           
                  <p>Default: normally created Feature Structures are not kept in a map.</p>
                  <p>In version 3, normally, Feature Structures are not added to the 
                        map used by the Low Level CAS API to map from int ids to Feature Structures.
                        This has the benefit that no longer referenced Feature Structures may be 
                        garbaged collected.  This behavior may be overridden by this property.</p></td><td class="auto-generated" style="border-bottom: 0.5pt solid black; ">&nbsp;</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; " colspan="2" align="center"><span class="bold"><strong>Trading off runtime checks for speed</strong></span></td><td class="auto-generated" style="border-bottom: 0.5pt solid black; ">&nbsp;</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; "><p>Disabling runtime feature validation</p></td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; "><p>uima.uima.disable_runtime_feature_validation</p>
           
                  <p>Once code is running correctly, you may remove this check for performance
                    reasons by setting this property.</p></td><td class="auto-generated" style="border-bottom: 0.5pt solid black; ">&nbsp;</td></tr><tr><td style="border-right: 0.5pt solid black; "><p>Disabling runtime feature <span class="emphasis"><em>value</em></span> validation</p></td><td style="border-right: 0.5pt solid black; "><p>uima.disable_runtime_feature_value_validation</p>
           
                  <p>Default: features being set into FS features which are FSs are checked for proper type subsumption.</p>
                  <p>Once code is running correctly, you may remove this check for performance
                    reasons by setting this property.</p></td><td class="auto-generated" style="">&nbsp;</td></tr></tbody></table>
   </div>
    
  </div>
  
</div>

  
</div></body></html>