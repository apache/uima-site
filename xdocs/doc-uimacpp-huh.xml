<?xml version="1.0" encoding="ISO-8859-1"?>

<!--
 Licensed to the Apache Software Foundation (ASF) under one
 or more contributor license agreements.  See the NOTICE file
 distributed with this work for additional information
 regarding copyright ownership.  The ASF licenses this file
 to you under the Apache License, Version 2.0 (the
 "License"); you may not use this file except in compliance
 with the License.  You may obtain a copy of the License at
 
 http://www.apache.org/licenses/LICENSE-2.0
 
 Unless required by applicable law or agreed to in writing,
 software distributed under the License is distributed on an
 "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 KIND, either express or implied.  See the License for the
 specific language governing permissions and limitations
 under the License.
-->

<document>

 <properties>
  <title>Getting Started: UIMA C++ Framework</title>
  <author email="dev@uima.apache.org">
   UIMA Documentation Team
  </author>
 </properties>

 <body>
  <section name="Getting Started: UIMA C++ Framework">
   <p>
     The "Getting Started: UIMA C++ Framework" guide should help you to understand how UIMA C++ enables the creation of UIMA compliant Analysis Engines (AE) in C++ and other programming languages, and how these AE interact with UIMA's Java framework.
   </p>

  <subsection name="UIMA C++ Overview">

   <p>
    The UIMA C++ framework is designed to facilitate the creation of UIMA compliant Analysis Engines (AE) from analytics written in C++, or written in languages that can utilize C++ libraries. The UIMACPP SDK directly supports C++, and indirectly supports Perl, Python and Tcl languages via SWIG (http://www.swig.org/). Existing analytic programs in any of these languages can be wrapped with a UIMACPP annotator and integrated with other UIMA compliant analytics or UIMA-based applications.
   </p>
   <p>
     <table width="100%"><tr><td align="center" valign="middle">
       <img src="./images/getting-started/framework-core.png" alt="UIMA Framework Core" border="0"/>
       <br>Figure 1 - UIMA Framework Core</br></td>
      </tr></table>
   </p>
   <p>
    Figure 1 illustrates the core functions of the UIMA framework which define a primitive AE: the CAS interface methods used to access the artifact being analyzed and any pre-existing analysis results or other metadata, and to create new analysis results; context APIs used to access configuration and logging; and finally, methods used to provide a standardized interface to a UIMA compliant AE. For Perl, Python and Tcl, SWIG is used to expose the CAS and context methods to user code in each language.
   </p>
   <p>
    A UIMA C++ AE can be used anywhere a UIMA Java AE can be used, for example, as a delegate in an aggregate AE, or as a UIMA service (using JMS, Vinci or SOAP protocols). When used in the Java framework, by default a C++ AE is instantiated and called via the JNI, running as part of the JVM process. This is also true for Vinci and SOAP services. For JMS services, the UIMACPP SDK includes a native service wrapper compatible with <a href="doc-uimaas-what.html">UIMA-AS</a>.
   </p>
   <p>
    The UIMA C++ framework supports testing and embedding UIMA components into native processes. A UIMA C++ test driver, <b>runAECpp</b>, is available so that UIMA C++ components can be fully developed and tested in the native environment, no use of Java is needed.
   </p>
   <p>
    UIMA C++ includes APIs to parse component descriptors, instantiate and call analysis engines, so that UIMA C++ compliant AE can be used in native applications. However, UIMA C++ components are primarily intended to be integrated into applications using UIMA's Java-based interfaces.
   </p>
   <p>
    The <a href="http://uima.apache.org/downloads.cgi">UIMA Download Page</a> contains UIMACPP source and 32-bit binary SDK packages for both Linux and Windows platforms. The Linux source package has been used to build and test successfully on MacOSX and on 64-bit Linux platforms.
   </p>
	</subsection>

   <subsection name="UIMACPP Sample Code">
   <p>
    The UIMACPP package includes several sample UIMA C++ annotators and a sample C++ application that instantiates and uses a C++ annotator. Please go to the <a href="http://uima.apache.org/downloads.cgi">UIMA Download Page</a> and get the "UIMACPP Framework" package for Linux or Windows as appropriate. For best interaoperability with the Java version of UIMA, unpack into the $UIMA_HOME directory. See the README file in the top level directory for instructions on testing the package, and follow the links there to the sample code in C++, Perl, Python and Tcl.
   </p>
   <p>
    A UIMA C++ annotator descriptor differs from a Java descriptor in the frameworkImplementation, specifying
<pre>&lt;frameworkImplementation&gt;org.apache.uima.cpp&lt;/frameworkImplementation&gt;</pre> 
For a C++ annotator, the annotatorImplementationName specifies the name of a dynamic link library. UIMACPP will add the OS appropriate suffix and search the active dynamic libary path: LD_LIBRARY_PATH for Linux, PATH for Windows, and DYLD_LIBRARY_PATH for MacOSX. The suffix is not automatically added when the annotatorImplementationName includes a path.
   </p>
   <p>
    An annotator library is derived from the UIMACPP class "Annotator" and must implement basic annotator methods. Annotators in Perl, Python and Tcl languages each use a C++ annotator to instantiate the appropriate interpreter, load the specified annotator source and call the annotator methods.
   </p>
  </subsection>

   <subsection name="UIMACPP Example - Running a C++ analytic in a Native Process">
   <p>
    As in UIMA, UIMACPP includes application level methods to instantiate an Analysis Engine from a UIMA annotator descriptor, create a CAS using the AE type system, and call AE methods.
   </p>
   <p>
    <b>examples/src/ExampleApplication.cpp</b> is a simple program that instantiates the specified annotator, reads a directory of txt files, and for each file sets the document text in a CAS and calls the AE process method. For annotator development, this program can be modified to create arbitrary CAS content to drive the annotator. Because the entire application is C++, standard tools such as gdb or devenv can be easily used for debugging.
   </p>
   <p>
    <b>runAECpp</b> is a UIMA C++ application driver modeled closely after the Java tool <b>runAE</b>. Like ExampleApplication, this tool can read a directory of text files and exercise the given annotator. In addition, runAECpp can take input from XML format CAS files, call the annotator's process() method, and output the resultant CAS in XML format files. XML format CAS input files can be created from upstream UIMA components, or created manually with the content needed to develop and unit test an annotator.
   </p>
   <p>
     <table width="100%"><tr><td align="center" valign="middle">
       <img src="./images/getting-started/uimacppnative.png" alt="runAECpp - Native C++ Test Driver" border="0"/>
       <br>Figure 2 - runAECpp - Native C++ Test Driver.</br></td>
     </tr></table>
   </p>
  </subsection>

   <subsection name="UIMACPP Example - Running a C++ analytic in a JVM Process">
   <p>
    Using the UIMA or UIMA AS packages, a UIMA C++ Analysis Engine can be used anywhere a UIMA Java AE can be used, for example, as a delegate in an aggregate AE, or as a UIMA service (using JMS, Vinci or SOAP protocols). When used in the Java framework, by default a C++ AE is instantiated and called via the JNI, running as part of the JVM process.    
   </p>
   <p>
    When a UIMA component descriptor specifies the frameworkImplementation as <b>org.apache.uima.cpp</b>, UIMA's Java framework instantiates a proxy annotator that transparently creates the UIMACPP component through the JNI. When the process(cas) method is called on the proxy, the CAS is binary serialized through the JNI into the native environment. The UIMA C++ annotator operates on the native copy of the CAS, and then the CAS is serialized back to the Java environment.
   </p>
   <p>
     <table width="100%"><tr><td align="center" valign="middle">
       <img src="./images/getting-started/uimacppthrujni.png" alt="Colocated UIMA C++ Component" border="0"/>
       <br>Figure 3 - UIMA C++ Component Colocated with Java Framework.</br></td>
     </tr></table>
   </p>
   <p>
    There are some limitations to this configuration:
    <ol>
     <li>
      When more than one UIMA C++ component is colocated in the JVM, all must share identical versions of the UIMACPP framework.
     </li>
     <li>
      Runtime problems in the C++ code can crash the entire JVM process.
     </li>
     <li>
      Standard OS parameters for a process, such as program stack size, are different for a JVM process than a native process.
     </li>
     <li>
      Debugging native code running in a JVM process can be problematic.
     </li>
     </ol>
   </p>
  </subsection>

   <subsection name="UIMACPP Example - Running a C++ analytic as a Native UIMA AS Service">
   <p>
    With the UIMA AS package, a UIMA C++ component can be run as a UIMA AS service using the UIMA C++ application <b>deployCppService</b>. This application instantiates a UIMA C++ AE from the specified annotator descriptor, and then connects to the specified ActiveMQ broker and input queue. In order to take advantage of multi-core hardware, deployCppService supports instantiating multiple copies of the C++ analytic, each in a different thread; this option requires the analytic to be designed for multithreaded operation.
   </p>
   <p>
    Once deployed, the service can be utilized from UIMA applications and aggregate analysis engines in exactly the same way as other UIMA AS services written in Java.  <!-- need link to online documenation -->
   </p>
   <p>
     <table width="100%"><tr><td align="center" valign="middle">
       <img src="./images/getting-started/deploycppservice.png" alt="Native UIMA AS Service" border="0"/>
       <br>Figure 4 - UIMA C++ Component Running as Native UIMA AS Service.</br></td>
     </tr></table>
   </p>
   <br></br>
   <p>
    <b>Using Java to provide lifecycle management and monitoring</b>
   </p>
   <p>
    UIMA AS services written in Java are deployed using UIMA Deployment Descriptors. These descriptors, which specify the UIMA component descriptor to instantiate and the connectivity and error handling options, are used by the UIMA utility <b>deployAsyncService</b> to launch a Java service. Deployment Descriptors have special support for UIMA C++ services, with the ability to provide lifecycle management, JMX monitoring and integrated logging of C++ native services. This support is enabled when the UIMA AS Deployment Descriptor specifies
<pre>&lt;custom name="run_top_level_CPP_service_as_separate_process"/&gt;</pre>
in which case Java will launch deployCppService as a separate process on the same machine and establish socket connections for logging and monitoring.
   </p>
   <p>
Note that in this case the Deployment Descriptor can also specify the environment for the native process using entries such as
<pre>&lt;environmentVariable name="LD_LIBRARY_PATH"&gt;/home/user/apache-uima-as/uimacpp/lib&lt;/environmentVariable&gt;</pre>
This feature enables multiple UIMA C++ components with different levels of UIMACPP to be managed by the same JVM.
   </p>
   <p>
     <table width="100%"><tr><td align="center" valign="middle">
       <img src="./images/getting-started/managedcppservice.png" alt="Managed Native Service" border="0"/>
       <br>Figure 5 - Java Managed UIMA C++ Service.</br></td>
     </tr></table>
   </p>
  </subsection>

  </section>

 </body>

</document>

