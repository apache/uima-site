<?xml version="1.0" encoding="ISO-8859-1"?>

<!--
 Licensed to the Apache Software Foundation (ASF) under one
 or more contributor license agreements.  See the NOTICE file
 distributed with this work for additional information
 regarding copyright ownership.  The ASF licenses this file
 to you under the Apache License, Version 2.0 (the
 "License"); you may not use this file except in compliance
 with the License.  You may obtain a copy of the License at
 
 http://www.apache.org/licenses/LICENSE-2.0
 
 Unless required by applicable law or agreed to in writing,
 software distributed under the License is distributed on an
 "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 KIND, either express or implied.  See the License for the
 specific language governing permissions and limitations
 under the License.
-->

<document>

 <properties>
  <title>Getting Started: Apache UIMA Asynchronous Scaleout</title>
  <author email="dev@uima.apache.org">
   Apache UIMA Documentation Team
  </author>
 </properties>

 <body>
  <section name="Getting Started: Apache UIMA Asynchronous Scaleout">
   <p>
     The "Getting Started: Apache UIMA&#0153; Asynchronous Scaleout " guide should help you to understand UIMA AS: how it relates to the core UIMA framework, what are the main concepts of UIMA AS, and an example application scenario.
   </p>

  <subsection name="UIMA AS Relationship to UIMA">

   <p>
    UIMA AS is the next generation scalability replacement for the Collection Processing Manager (CPM). UIMA AS provides more flexible and powerful scaleout capability, and extends support to the UIMA components not supported by the CPM, the flow controller and CAS multiplier. UIMA components can be run within UIMA AS with no code or component descriptor changes. 
   </p>
   <p>
    UIMA AS introduces a new XML descriptor, the Deployment Descriptor. Unlike the CPM descriptor which specifies component aggregation, error handling and scalability, the UIMA AS Deployment Descriptor only specifies error handling and scalability options; component aggregation is done using the standard aggregate descriptor. The UIMA Component Descriptor Editor (CDE) has been enhanced to support the UIMA AS Deployment Descriptor.
   </p>
   <p>
    To use UIMA AS, you need to download UIMA AS binary package from <a href="http://uima.apache.org/downloads.cgi">UIMA Download Page</a> and unzip 
    it into a directory of your choice. The package includes base UIMA jars to simplify installation.
    In addition to base UIMA, the UIMA AS package also includes the Apache ActiveMQ implementation of JMS 
    which is used to provide connectivity between UIMA AS clients and services.
   </p>
	</subsection>
  
   <subsection name="UIMA AS Client - Service Architecture">
   <p>
    Like UIMA Vinci services, UIMA AS provides a service wrapper that creates a shared UIMA service from a UIMA analysis engine. UIMA services enable UIMA clients to utilize UIMA analysis engines running in separate processes on the same or different machines. There are a number of advantages with UIMA AS services:
    <ol>
     <li>
      UIMA AS services are asynchronous. A client can send multiple requests before receiving any responses. This can increase processing throughput over Vinci services which, being synchronous, prevent the client or service from doing work during request/reply transmission.
     </li>
     <li>
      Load balancing for UIMA AS services is excellent, because available services pull requests from a shared queue. Service instances can be dynamically added or removed at runtime
     </li>
     <li>
      Because of Apache ActiveMQ, connectivity to UIMA AS services is much more flexible than Vinci. A maximum of one port needs to be opened to expose one or more services thru a firewall. The HTTP protocol can be used for robust wide-area network connectivity.
     </li>
     <li>
      The UIMA AS design is based on JMS, a widely adopted standard. One goal for UIMA AS is that it can run with different JMS implementations, so that it can be integrated into popular middleware platforms.
     </li>
     <li>
      UIMA AS exposes numerous performance parameters via JMX, extending in a consistent manner the JMX parameters already exposed by core UIMA. Custom UIMA AS monitoring tools based on these JMX parameters are being developed to help identify bottlenecks in complex deployments.
     </li>
    </ol>
   </p>
   <p>
    The shared queue in front of each UIMA AS service is implemented using an Apache ActiveMQ broker. A separate reply queue is created for each client, and every request contains the address of the client's unique reply queue.
   </p>
   <p>
    UIMA AS services are compatible with core UIMA applications such as the Document Analyzer. However, the base UIMA interface to services is synchronous and non-thread safe. There is a new UIMA AS application API that exposes synchronous and asynchronous thread-safe interfaces to UIMA AS services. 
   </p>
   <p>
     <table width="100%"><tr><td align="center" valign="middle">
       <img src="./images/getting-started/uima-as-arch.png" alt="UIMA AS architecture" border="0"/>
       <br>Figure 1 - UIMA AS Client-Server Architecture</br></td>
      </tr></table>
   </p>
  </subsection>
  
   <subsection name="UIMA Aggregates vs. UIMA AS Aggregates">
   <p>
    A UIMA aggregate analysis engine is implemented as a synchronous, single-threaded object. That is, when the aggregate AE's process method is called, only one delegate can be working on that CAS at a time. 
   </p> 
   <p>
    For a UIMA AS aggregate, each delegate has its own input queue, and the aggregate controller sends requests to the delegates via their queues. By default a delegate is assumed to be collocated with the aggregate controller, but the Deployment Descriptor allows a delegate to be "remote", i.e. mapped to the input queue for another UIMA AS service. For collocated delegates, the Deployment Descriptor can specify how many instances of the delegate should be instantiated; each instance will have a listener thread to receive requests and execute user code.
   </p> 
   <p>
    When calling "remote" delegates, the CAS is serialized into CasXmi format for transfer. Colocated delegates share the in-process CAS object and have no serialization overhead. Remote delegates with no dependency on each others results can be called in parallel on the same CAS, providing opportunities for reducing latency in real-time applications.
   </p> 
   <p>
    UIMA AS aggregates optionally provide extensive error handling for service calls, including retry, ignore, delegate disable, service termination, and more. When combined with the UIMA flow controller, users can implement complex application flow/error handling logic.
   </p> 
   <p>
     <table width="100%"><tr><td align="center" valign="middle">
       <img src="./images/getting-started/async-aggregate.png" alt="UIMA AS asynchronous aggregate" border="0"/>
       <br>Figure 2 - UIMA AS Aggregate</br></td>
     </tr></table>
   </p>
  </subsection>
  
   <subsection name="UIMA AS - Example Application Scenarios">
   <p>
    One problem that has been raised on the UIMA mailing lists is how to "push" documents into a UIMA processing pipeline. The simple answer with UIMA AS is to implement the processing pipeline as a UIMA AS service, and push requests from a custom application. Multiple instances of the processing pipeline service could be instantiated to increase throughput.
   </p> 
   <p>
    Included with UIMA AS is a sample application, RunRemoteAsyncAE. This application demonstrates most of the features of the new UIMA asynchronous API, including the ability to use a UIMA Collection Reader to push documents to a specified service.
   </p>
   <p>
     <table width="100%"><tr><td align="center" valign="middle">
       <img src="./images/getting-started/runremoteasyncae.png" alt="RunRemoteAsyncAE application" border="0"/>
       <br>Figure 3 - Using RunRemoteAsyncAE to push documents into a UIMA AS service</br></td>
     </tr></table>
   </p><br></br><br></br>

   <p>
    A scaleout that corresponds to that provided by the Collection Processing Manager (CPM) is to have a single instance of collection reader and Cas Consumer(s) and scale out the other analysis components. Scaleout here is limited by the collection reader / Cas consumer bottleneck and the deserialization work required on the central driver. Scaleout efficiency is determined by the ratio of the processing done by the scaled out analysis engines to the serialization overhead in the services.
   </p>
   <p>
     <table width="100%"><tr><td align="center" valign="middle">
       <img src="./images/getting-started/singlecrscaleout.png" alt="Single Collection Reader Scaleout" border="0"/>
       <br>Figure 4 - Scaleout using a single set of Collection Reader and Cas Consumers</br></td>
     </tr></table>
   </p><br></br><br></br>

   <p>
    For very large scalability using UIMA AS, multiple copies of the collection reader and Cas consumers are needed. A central driver would distribute [references to] subsets of the input collection to the scaled out processing pipelines, where each pipeline contains a collection reader and the Cas consumers.
   </p>
   <p>
    Scalout limitations in this scenario could be in several places, examples being a common source of input documents or a shared writable resource used by Cas consumers.
   </p>
   <p>
     <table width="100%"><tr><td align="center" valign="middle">
       <img src="./images/getting-started/multiplecrscaleout.png" alt="Very large Scaleout" border="0"/>
       <br>Figure 5 - Scaleout using multiple Collection Readers and Cas Consumers.</br></td>
     </tr></table>
   </p>
  </subsection>
  
   <subsection name="UIMA AS - What next?">
   <p>
    A reference manual for UIMA-AS is viewable on the <a href="documentation.html">documentation</a> page.
    Go to the <a href="http://uima.apache.org/downloads.cgi">UIMA Download Page</a> 
    and get the "UIMA AS Asynchronous Scaleout" package in zip or tar format. 
    Unpack it into directory of your choice. 
    See the README file in the top level directory 
    for instructions on deploying and testing standard UIMA example annotators as UIMA AS services.
   </p> 
  </subsection>

  </section>

 </body>

</document>

